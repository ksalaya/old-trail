<style>
/* ==== OLD TRAIL – UI SHELL ================================================= */

.ot-root {
  font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", system-ui,
    -sans-serif;
  background: radial-gradient(circle at top, #202737 0, #050509 55%, #020104 100%);
  color: #f6f3ea;
  padding: 24px 24px 32px;
  box-sizing: border-box;
  max-width: 1200px;
  margin: 0 auto;
  border-radius: 18px;
  box-shadow: 0 24px 80px rgba(0, 0, 0, 0.85);
  position: relative;
}

.ot-root * {
  box-sizing: border-box;
}

.ot-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.ot-title-block {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.ot-title {
  letter-spacing: 0.3em;
  text-transform: uppercase;
  font-size: 13px;
  color: #f5d28b;
}

.ot-subtitle {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.18em;
  color: #b6b3ac;
}

.ot-header-right {
  display: flex;
  gap: 8px;
  align-items: center;
}

.ot-pill {
  border-radius: 999px;
  padding: 6px 14px;
  font-size: 11px;
  border: 1px solid rgba(245, 210, 139, 0.35);
  background: radial-gradient(circle at top, #604321, #2b1a0f);
  color: #f6f3ea;
  text-transform: uppercase;
  letter-spacing: 0.13em;
  white-space: nowrap;
}

.ot-pill-danger {
  background: radial-gradient(circle at top, #5b1818, #2b0c0c);
  border-color: rgba(255, 121, 121, 0.6);
}

/* ==== PANELS & LAYOUT ====================================================== */

.ot-screen {
  display: none;
}

.ot-screen-active {
  display: block;
}

.ot-screen-grid {
  display: grid;
  grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
  gap: 18px;
}

.ot-screen-travel {
  grid-template-columns: minmax(0, 0.95fr) minmax(0, 1.25fr);
}

.ot-panel {
  background: radial-gradient(circle at top left, #252838, #090910);
  border-radius: 14px;
  padding: 12px 14px 12px;
  border: 1px solid rgba(255, 255, 255, 0.04);
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.55);
  margin-bottom: 10px;
}

.ot-panel-header {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.16em;
  color: #b9b6ae;
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.ot-panel-body {
  font-size: 12px;
  color: #f4f1ea;
}

.ot-panel-body-sm {
  font-size: 11px;
}

/* ==== FORM ELEMENTS ======================================================== */

.ot-field {
  margin-bottom: 10px;
}

.ot-label {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: #b6b3ac;
  margin-bottom: 4px;
}

.ot-input,
.ot-select {
  width: 100%;
  padding: 8px 10px;
  font-size: 13px;
  border-radius: 9px;
  border: 1px solid rgba(255, 255, 255, 0.12);
  background: rgba(3, 3, 6, 0.9);
  color: #f6f3ea;
}

.ot-input::placeholder {
  color: #77746b;
}

.ot-input:focus,
.ot-select:focus {
  outline: none;
  border-color: rgba(245, 210, 139, 0.8);
  box-shadow: 0 0 0 1px rgba(245, 210, 139, 0.4);
}

.ot-narrator-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}

.ot-narrator-picker select {
  width: 100%;
}

/* ==== BUTTONS ============================================================== */

.ot-btn,
.ot-btn-outline,
.ot-btn-gold,
.ot-link-button {
  border-radius: 999px;
  padding: 8px 14px;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.16em;
  border: none;
  cursor: pointer;
  transition: all 0.12s ease-out;
  white-space: nowrap;
}

.ot-btn-gold {
  background: linear-gradient(90deg, #f7cf7f, #f0b75b);
  color: #2d1b09;
  box-shadow: 0 5px 16px rgba(0, 0, 0, 0.55);
}

.ot-btn-gold:hover {
  filter: brightness(1.06);
  transform: translateY(-1px);
}

.ot-btn-outline {
  background: transparent;
  border: 1px solid rgba(246, 238, 203, 0.45);
  color: #f4e9d4;
}

.ot-btn-outline:hover {
  background: rgba(246, 238, 203, 0.08);
}

.ot-btn[disabled],
.ot-btn-gold[disabled],
.ot-btn-outline[disabled] {
  opacity: 0.4;
  cursor: default;
  transform: none;
  box-shadow: none;
}

.ot-link-button {
  background: transparent;
  border: none;
  color: #f3cf84;
  padding: 4px 8px;
  font-size: 10px;
}

.ot-link-button:hover {
  text-decoration: underline;
}

/* ==== START SCREEN ========================================================= */

.ot-start-grid {
  grid-template-columns: minmax(0, 1.05fr) minmax(0, 1.1fr);
}

.ot-start-art {
  border-radius: 14px;
  min-height: 220px;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  margin-top: 10px;
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.7);
  border: 1px solid rgba(255, 255, 255, 0.06);
}

/* ==== OUTFITTING =========================================================== */

.ot-outfit-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}

.ot-outfit-table th,
.ot-outfit-table td {
  padding: 4px 4px;
  text-align: left;
  border-bottom: 1px solid rgba(255, 255, 255, 0.03);
}

.ot-outfit-table th {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.14em;
  color: #b6b3ac;
}

.ot-outfit-qty {
  width: 64px;
  padding: 5px 6px;
  border-radius: 7px;
  border: 1px solid rgba(255, 255, 255, 0.16);
  background: rgba(4, 4, 8, 0.93);
  color: #f6f3ea;
  font-size: 12px;
}

.ot-outfit-summary-row {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  margin-bottom: 3px;
}

.ot-text-muted {
  color: #a49f97;
}

.ot-text-warning {
  color: #ffce7d;
}

/* ==== TRAVEL SCREEN ======================================================== */

.ot-travel-scene-wrapper {
  position: relative;
  border-radius: 16px;
  overflow: hidden;
  margin-bottom: 12px;
  border: 1px solid rgba(255, 255, 255, 0.06);
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.75);
  min-height: 170px;
}

.ot-travel-view-toggle {
  display: inline-flex;
  gap: 4px;
  margin-bottom: 6px;
  font-size: 10px;
}

.ot-view-toggle-btn {
  border-radius: 999px;
  border: 1px solid rgba(255, 255, 255, 0.25);
  padding: 3px 8px;
  background: rgba(10, 10, 16, 0.8);
  color: #f5ead2;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  font-size: 9px;
  opacity: 0.78;
  cursor: pointer;
}

.ot-view-toggle-btn-active {
  background: radial-gradient(circle at top, #f5cf8b, #f0b463);
  color: #291608;
  opacity: 1;
}

.ot-trail-canvas {
  display: block;
  width: 100%;
  height: 180px;
  image-rendering: crisp-edges;
  image-rendering: pixelated;
}

/* View mode visibility helpers */
.ot-view-mode-journal #ot-trail-canvas {
  display: none;
}

.ot-view-mode-explorer #ot-scene,
.ot-view-mode-explorer #ot-scene-caption {
  display: none;
}

/* Temporal viewport overlays (scene + map) */

.ot-viewport-window {
  position: relative;
  overflow: hidden;
}

.ot-viewport-window::before {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  mix-blend-mode: screen;
  background:
    radial-gradient(circle at 20% 0%, rgba(255, 255, 255, 0.24), transparent 55%),
    radial-gradient(circle at 80% 0%, rgba(255, 255, 255, 0.18), transparent 60%),
    linear-gradient(to bottom, rgba(7, 10, 18, 0.9), transparent 40%, transparent 60%, rgba(0, 0, 0, 0.95)),
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.16) 0px,
      rgba(255, 255, 255, 0.04) 1px,
      rgba(0, 0, 0, 0) 2px,
      rgba(0, 0, 0, 0) 4px
    );
  opacity: 0.9;
  filter: saturate(1.06) contrast(1.04);
  z-index: 1;
}

.ot-viewport-window::after {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  box-shadow:
    inset 0 10px 40px rgba(0, 0, 0, 0.86),
    inset 0 -24px 46px rgba(0, 0, 0, 0.92),
    inset 18px 0 36px rgba(0, 0, 0, 0.88),
    inset -18px 0 36px rgba(0, 0, 0, 0.88);
  background:
    radial-gradient(circle at 22% 50%, rgba(255, 40, 0, 0.12), transparent 60%),
    radial-gradient(circle at 78% 50%, rgba(0, 210, 255, 0.12), transparent 60%);
  mix-blend-mode: soft-light;
  opacity: 0.9;
  z-index: 2;
}

.ot-travel-scene {
  min-height: 170px;
  background-size: cover;
  background-position: center;
  position: relative;
  z-index: 0;
}

.ot-travel-scene-overlay {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 10px 12px;
  background: linear-gradient(to top, rgba(0, 0, 0, 0.75), transparent);
  font-size: 11px;
  z-index: 5;
}

.ot-bar-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
}

.ot-bar-label {
  font-size: 11px;
  color: #bfb8ad;
  margin-right: 10px;
}

.ot-bar {
  flex: 1;
  height: 7px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.06);
  overflow: hidden;
}

.ot-bar-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, #f6d48a, #f0b75b);
  width: 50%;
}

.ot-bar-fill.cold {
  background: linear-gradient(90deg, #9fd8ff, #6eb0ff);
}

.ot-bar-fill.bad {
  background: linear-gradient(90deg, #ff7c7c, #dd3a3a);
}

.ot-manifest-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 3px 2px;
  border-radius: 6px;
  cursor: pointer;
}

.ot-manifest-row:hover {
  background: rgba(255, 255, 255, 0.04);
}

.ot-manifest-name {
  font-size: 12px;
}

.ot-manifest-role {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.16em;
  color: #9b968d;
}

.ot-manifest-selected {
  background: linear-gradient(90deg, rgba(247, 209, 128, 0.12), transparent);
}

.ot-tasks-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}

.ot-tasks-table td {
  padding: 3px 2px;
}

.ot-task-select {
  width: 100%;
  padding: 4px 10px 4px 8px;
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.16);
  background: rgba(5, 5, 10, 0.92);
  color: #f4f1ea;
  font-size: 11px;
}

/* Trail map */

.ot-map-viewport {
  margin-bottom: 8px;
  border-radius: 14px;
  border: 1px solid rgba(255, 255, 255, 0.07);
  box-shadow: 0 16px 44px rgba(0, 0, 0, 0.72);
  min-height: 150px;
  background-size: cover;
  background-position: center;
  background-image:
    linear-gradient(to top, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.15)),
    url("https://www.kylesalaya.com/uploads/9/3/7/0/93707764/chatgpt-image-nov-30-2025-at-02-18-05-am_orig.png");
}

.ot-trail-map {
  font-size: 11px;
  line-height: 1.4;
}

.ot-trail-dot-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 3px;
}

.ot-trail-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  border: 1px solid rgba(244, 220, 170, 0.7);
  background: transparent;
}

.ot-trail-dot-current {
  background: #f5d28b;
}

.ot-trail-dot-seen {
  background: rgba(245, 210, 139, 0.5);
  box-shadow: 0 0 0 1px rgba(245, 210, 139, 0.12);
}

/* Trail log */

.ot-log {
  height: 160px;
  max-height: 160px;
  overflow-y: auto;
}

.ot-log-entry {
  font-size: 11px;
  margin-bottom: 4px;
  color: #f4efe3;
}

/* Supplies overview */

.ot-supplies-grid {
  display: grid;
  gap: 2px 16px;
  grid-template-columns: 1.3fr 1fr;
  font-size: 11px;
}

.ot-supplies-label {
  color: #b6b1a7;
}

.ot-supplies-value {
  text-align: right;
}

/* Footer */

.ot-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 14px;
  padding-top: 10px;
  border-top: 1px solid rgba(255, 255, 255, 0.08);
  font-size: 11px;
  color: #c5c0b5;
}

.ot-footer-left {
  max-width: 60%;
}

.ot-footer-right {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

/* Inventory modal */

.ot-modal {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

.ot-modal.active {
  display: flex;
}

.ot-modal-backdrop {
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at top, rgba(0, 0, 0, 0.84), rgba(0, 0, 0, 0.96));
}

.ot-modal-content {
  position: relative;
  background: radial-gradient(circle at top left, #262739, #07060a);
  border-radius: 16px;
  padding: 16px 18px 14px;
  border: 1px solid rgba(252, 238, 197, 0.25);
  box-shadow: 0 24px 80px rgba(0, 0, 0, 0.95);
  width: min(520px, 100% - 32px);
  max-height: 80vh;
  overflow: auto;
}

.ot-modal-title {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.16em;
  color: #f4e4c2;
  margin-bottom: 6px;
}

.ot-modal-sub {
  font-size: 11px;
  color: #b6b1a7;
  margin-bottom: 8px;
}

.ot-inventory-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
  margin-bottom: 10px;
}

.ot-inventory-table th,
.ot-inventory-table td {
  padding: 4px 4px;
  text-align: left;
  border-bottom: 1px solid rgba(255, 255, 255, 0.04);
}

.ot-inventory-table th {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.16em;
  color: #b6b1a7;
}

.ot-inv-btn {
  padding: 4px 9px;
  border-radius: 999px;
  border: 1px solid rgba(244, 219, 160, 0.7);
  background: transparent;
  color: #f4e4c2;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.14em;
  cursor: pointer;
}

.ot-inv-btn:hover {
  background: rgba(245, 210, 139, 0.12);
}

/* Work priorities modal */

.ot-priorities-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 11px;
  margin-bottom: 6px;
}

.ot-priorities-table th,
.ot-priorities-table td {
  padding: 3px 4px;
  text-align: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.04);
}

.ot-priorities-table th:first-child,
.ot-priorities-table td:first-child {
  text-align: left;
}

.ot-priority-cell {
  min-width: 30px;
  padding: 3px 0;
  border-radius: 999px;
  border: 1px solid rgba(244, 219, 160, 0.6);
  background: transparent;
  color: #f4e4c2;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  cursor: pointer;
}

.ot-priority-cell.prio-off {
  opacity: 0.45;
  border-style: dashed;
}

.ot-priority-cell.prio-1 {
  background: radial-gradient(circle at top, #f7cf7f, #f0b75b);
  color: #2d1b09;
}

.ot-priority-cell.prio-2 {
  background: radial-gradient(circle at top, rgba(247, 207, 127, 0.5), rgba(240, 183, 91, 0.5));
}

.ot-priority-cell.prio-3 {
  background: rgba(246, 238, 203, 0.09);
}

.ot-priority-cell.prio-4 {
  background: transparent;
  opacity: 0.7;
}

.ot-priorities-legend {
  font-size: 10px;
  color: #b6b1a7;
  margin-bottom: 4px;
}

.ot-priorities-warnings {
  font-size: 10px;
  color: #ffce7d;
  margin-top: 2px;
}

/* Camp tasks overlay */
#ot-camp-overlay {
  position: fixed;
  inset: 0;
  background: rgba(2, 2, 4, 0.8);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 20;
  padding: 10px;
}

#ot-camp-overlay.ot-show {
  display: flex;
}

#ot-camp-overlay .ot-overlay-inner {
  position: relative;
  max-width: 920px;
  width: 100%;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}

#ot-camp-overlay .ot-overlay-close {
  position: absolute;
  top: 6px;
  right: 6px;
  z-index: 2;
}

/* Compact overlay chrome for camp planner */
#ot-camp-overlay .ot-overlay-panel {
  background: radial-gradient(circle at top, #171920, #0b0c11);
  border-radius: 14px;
  border: 1px solid rgba(255, 255, 255, 0.08);
  padding: 8px;
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.7);
}

/* Camp menu shell tweaks */
#oldtrail-camp-menu-widget .cm-shell {
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.7);
}

/* Crafting widget styling */
#oldtrail-crafting-widget,
#oldtrail-crafting-widget * {
  box-sizing: border-box;
}

#oldtrail-crafting-widget {
  font-family: "Georgia", "Times New Roman", serif;
  background: radial-gradient(circle at top, #1c222f, #0c0f16);
  color: #f5e9cf;
  padding: 8px;
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.05);
}

#oldtrail-crafting-widget .ot-craft-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 11px;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  margin-bottom: 6px;
}

#oldtrail-crafting-widget .ot-craft-grid {
  display: grid;
  grid-template-columns: repeat(3, 36px) 24px 80px;
  gap: 4px;
  align-items: center;
  margin-bottom: 6px;
}

#oldtrail-crafting-widget .ot-craft-cell {
  width: 36px;
  height: 36px;
  border-radius: 6px;
  background: rgba(255, 255, 255, 0.06);
  border: 1px solid rgba(255, 255, 255, 0.08);
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.5);
}

#oldtrail-crafting-widget .ot-craft-output {
  width: 80px;
  height: 48px;
  border-radius: 8px;
  background: linear-gradient(145deg, rgba(247, 207, 127, 0.2), rgba(240, 183, 91, 0.12));
  border: 1px solid rgba(247, 207, 127, 0.4);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  color: #f7cf7f;
}

#oldtrail-crafting-widget .ot-craft-status {
  font-size: 11px;
  color: #d7cfbf;
}

/* Trail log widget wrapper inside panel */
#old-trail-log-widget {
  width: 100%;
}

/* Thoughts bubble placement */
#oldtrail-thoughts-bubble {
  position: fixed;
  bottom: 16px;
  right: 16px;
  z-index: 15;
  cursor: pointer;
}

#oldtrail-thoughts-bubble .tb-window {
  width: 280px;
  background: radial-gradient(circle at top, #1d1f27, #0b0c11);
  border: 1px solid rgba(247, 207, 127, 0.35);
  border-radius: 12px;
  box-shadow: 0 12px 30px rgba(0, 0, 0, 0.65);
  overflow: hidden;
}

#oldtrail-thoughts-bubble .tb-header {
  background: linear-gradient(90deg, #4a2b1b, #23130d);
  color: #f6e7c6;
  padding: 6px 8px;
  font-size: 11px;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

#oldtrail-thoughts-bubble .tb-body {
  display: flex;
  padding: 8px;
  gap: 8px;
}

#oldtrail-thoughts-bubble .tb-avatar {
  width: 42px;
  height: 42px;
  border-radius: 9px;
  background: linear-gradient(135deg, #c2a070, #74512f);
  border: 1px solid rgba(247, 207, 127, 0.35);
}

#oldtrail-thoughts-bubble .tb-text {
  font-size: 12px;
  line-height: 1.35;
  color: #f4e8d4;
}

#oldtrail-thoughts-bubble .tb-mood-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-top: 6px;
}

#oldtrail-thoughts-bubble .tb-mood-bar {
  flex: 1;
  height: 8px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.08);
  overflow: hidden;
  border: 1px solid rgba(247, 207, 127, 0.25);
}

#oldtrail-thoughts-bubble .tb-mood-fill {
  height: 100%;
  width: 50%;
  background: linear-gradient(90deg, #a33a2b, #f0b75b);
  transition: width 160ms ease-out;
}

#oldtrail-thoughts-bubble .tb-footer {
  padding: 6px 8px 8px;
  font-size: 10px;
  letter-spacing: 0.12em;
  color: #b39b7c;
  text-transform: uppercase;
}

/* Small responsive tweak */

@media (max-width: 900px) {
  .ot-screen-grid,
  .ot-screen-travel {
    grid-template-columns: minmax(0, 1fr);
  }
  .ot-footer-left {
    max-width: 100%;
    margin-bottom: 10px;
  }
  .ot-footer {
    flex-direction: column;
    align-items: flex-start;
  }
}
</style>

<div id="oldtrail-root" class="ot-root">
  <div class="ot-header">
    <div class="ot-title-block">
      <div class="ot-title">OLD TRAIL</div>
      <div class="ot-subtitle">
        SURVIVAL JOURNAL · OREGON TRAIL, 1840s–1860s
      </div>
    </div>
    <div class="ot-header-right">
      <div id="ot-leader-pill" class="ot-pill">Leader — not yet chosen</div>
      <button id="ot-btn-reset" class="ot-pill ot-pill-danger">
        Reset journey
      </button>
    </div>
  </div>

  <!-- START SCREEN -->
  <div id="ot-screen-start" class="ot-screen ot-screen-active">
    <div class="ot-screen-grid ot-start-grid">
      <div>
        <div class="ot-panel">
          <div class="ot-panel-header">Assemble your party</div>
          <div class="ot-panel-body">
            <div class="ot-field">
              <div class="ot-label">Leader name</div>
              <input
                id="ot-leader-name"
                class="ot-input"
                placeholder="e.g., Amelia Knight"
              />
            </div>

            <div class="ot-field">
              <div class="ot-label">Background</div>
              <select id="ot-background" class="ot-select">
                <option value="farmer">Farmer from Illinois</option>
                <option value="banker">Banker from the East</option>
                <option value="carpenter">Carpenter from Ohio</option>
                <option value="teacher">Schoolteacher from New England</option>
              </select>
              <div
                id="ot-background-desc"
                class="ot-panel-body-sm ot-text-muted"
                style="margin-top: 4px;"
              ></div>
            </div>

            <div class="ot-field">
              <div class="ot-label">Departure town</div>
              <select id="ot-departure" class="ot-select">
                <option value="independence">Independence, Missouri</option>
                <option value="st_joseph">St. Joseph, Missouri</option>
                <option value="council_bluffs">Council Bluffs</option>
              </select>
            </div>

            <div class="ot-field">
              <div class="ot-label">Departure date</div>
              <select id="ot-departure-season" class="ot-select">
                <option value="early_april">Early April – swollen rivers, cold nights, sparse grass</option>
                <option value="late_april">Late April – historically ideal window (rivers falling, grass growing)</option>
                <option value="mid_may">Mid May – good grass, some storms, still safe for passes</option>
                <option value="early_june">Early June – hotter plains, stronger storms, still OK if you move well</option>
                <option value="mid_july">Mid July – high heat & dust, late for mountain passes</option>
              </select>
              <div
                id="ot-departure-season-desc"
                class="ot-panel-body-sm ot-text-muted"
                style="margin-top: 4px;"
              ></div>
            </div>

            <div class="ot-field">
              <div class="ot-label">Trail narrator</div>
              <select id="ot-storyteller-preset" class="ot-select"></select>
              <div
                id="ot-storyteller-desc"
                class="ot-panel-body-sm ot-text-muted"
                style="margin-top: 4px;"
              >
                Shapes how quickly tension rises, how often dramatic events strike, and how generous breathers feel.
              </div>
            </div>

            <div class="ot-field">
              <div class="ot-label">Companions (up to 4)</div>
              <input
                id="ot-companion-0"
                class="ot-input"
                placeholder="Companion 1"
                style="margin-bottom: 4px;"
              />
            <input
                id="ot-companion-1"
                class="ot-input"
                placeholder="Companion 2"
                style="margin-bottom: 4px;"
              />
              <input
                id="ot-companion-2"
                class="ot-input"
                placeholder="Companion 3"
                style="margin-bottom: 4px;"
              />
              <input
                id="ot-companion-3"
                class="ot-input"
                placeholder="Companion 4"
              />
              <div
                class="ot-panel-body-sm ot-text-muted"
                style="margin-top: 4px;"
              >
                Each person brings different strengths. You'll delegate cooking,
                hunting, scouting, and camp work hour by hour—or let them follow
                their own roles automatically.
              </div>
            </div>

            <button id="ot-btn-begin-outfit" class="ot-btn-gold">
              Begin outfitting
            </button>
          </div>
        </div>
      </div>

      <div>
        <div class="ot-panel">
          <div class="ot-panel-header">Trail brief</div>
          <div class="ot-panel-body ot-panel-body-sm">
            Your wagon party will travel roughly two thousand miles from the
            Missouri frontier to the Willamette Valley. Most days you'll walk
            beside the wagon for 8–10 hours, stopping at noon to rest the stock
            and again at night to cook, make camp, and stand watch.
            <br /><br />
            Time advances in hours. Each hour you can have your leader and
            companions travel, scout ahead, hunt, cook, gather wood or water,
            repair the wagon, or simply rest. Tasks use their skills and carry
            different risks. Weather and season matter: swollen rivers in early
            spring, searing heat and dust in midsummer.
            <br /><br />
            Keep everyone fed, watered, warm, and rested. A party in poor
            condition will slow to a crawl or fall apart long before Oregon.
          </div>
        </div>
        <div id="ot-start-art" class="ot-start-art"></div>
      </div>
    </div>
  </div>

  <!-- OUTFITTING -->
  <div id="ot-screen-outfit" class="ot-screen">
    <div class="ot-screen-grid">
      <div>
        <div class="ot-panel">
          <div class="ot-panel-header">Outfit your wagon</div>
          <div class="ot-panel-body">
            <div
              id="ot-outfit-intro"
              class="ot-panel-body-sm ot-text-muted"
              style="margin-bottom: 6px;"
            ></div>
            <table class="ot-outfit-table" id="ot-outfit-table">
              <thead>
                <tr>
                  <th>Item</th>
                  <th>Qty</th>
                  <th>Unit</th>
                  <th>Cost</th>
                  <th>Subtotal</th>
                </tr>
              </thead>
              <tbody id="ot-outfit-body"></tbody>
            </table>
            <div
              style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap;"
            >
              <button id="ot-btn-add-recommended" class="ot-btn-outline">
                Add recommended load
              </button>
              <button id="ot-btn-begin-journey" class="ot-btn-gold">
                Begin the journey
              </button>
            </div>
          </div>
        </div>
      </div>
      <div>
        <div class="ot-panel">
          <div class="ot-panel-header">Wagon summary</div>
          <div class="ot-panel-body ot-panel-body-sm">
            <div class="ot-outfit-summary-row">
              <div class="ot-supplies-label">Starting funds</div>
              <div id="ot-sum-starting" class="ot-supplies-value">$0.00</div>
            </div>
            <div class="ot-outfit-summary-row">
              <div class="ot-supplies-label">Money remaining</div>
              <div id="ot-sum-money" class="ot-supplies-value">$0.00</div>
            </div>
            <div class="ot-outfit-summary-row">
              <div class="ot-supplies-label">Total load</div>
              <div id="ot-sum-load" class="ot-supplies-value">0 lb</div>
            </div>
            <div class="ot-outfit-summary-row">
              <div class="ot-supplies-label">Draft power</div>
              <div id="ot-sum-draft" class="ot-supplies-value">
                0 lb pull
              </div>
            </div>
            <div class="ot-outfit-summary-row">
              <div class="ot-supplies-label">Load ratio</div>
              <div id="ot-sum-ratio" class="ot-supplies-value">0%</div>
            </div>
            <div
              class="ot-panel-body-sm ot-text-muted"
              style="margin-top: 6px;"
            >
              A heavily overloaded wagon will crawl along the trail and break
              down more often, but leaving too much behind risks starvation
              later.
            </div>
          </div>
        </div>
        <div id="ot-outfit-art" class="ot-start-art"></div>
      </div>
    </div>
  </div>

  <!-- TRAVEL SCREEN -->
  <div id="ot-screen-travel" class="ot-screen">
    <div class="ot-screen-grid ot-screen-travel">
      <div>
        <div class="ot-panel">
          <div class="ot-panel-header">On the trail</div>
          <div class="ot-panel-body ot-panel-body-sm">
            <div>Pace: <span id="ot-ontrail-pace">Steady</span></div>
            <div>Rations: <span id="ot-ontrail-rations">Full rations</span></div>
            <div>Mode: <span id="ot-ontrail-mode">In camp</span></div>
            <div>Daily block: <span id="ot-ontrail-block">Morning</span></div>
            <div>Weather: <span id="ot-weather-summary">—</span></div>
            <div class="ot-text-muted" id="ot-weather-note"></div>
          </div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">Narrator</div>
          <div class="ot-panel-body ot-panel-body-sm">
            <div class="ot-narrator-row">
              <div id="ot-narrator-label" class="ot-text-muted"></div>
              <button id="ot-btn-toggle-narrator" class="ot-link-button" type="button">
                Change narrator
              </button>
            </div>
            <div id="ot-narrator-picker" class="ot-narrator-picker" style="display: none; margin-top: 6px;">
              <select id="ot-storyteller-midrun" class="ot-select"></select>
              <div id="ot-narrator-hint" class="ot-panel-body-sm ot-text-muted" style="margin-top: 4px;"></div>
            </div>
          </div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">Leader status</div>
          <div class="ot-panel-body" id="ot-leader-status"></div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">Party manifest</div>
          <div class="ot-panel-body" id="ot-party-manifest"></div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">
            Hour tasks
            <button
              id="ot-btn-open-priorities"
              class="ot-link-button"
              type="button"
            >
              Work priorities
            </button>
          </div>
          <div class="ot-panel-body" id="ot-hour-tasks"></div>
        </div>
      </div>

      <div>
        <div class="ot-travel-view-toggle">
          <button
            id="ot-btn-view-journal"
            class="ot-view-toggle-btn ot-view-toggle-btn-active"
          >
            Journal view
          </button>
          <button id="ot-btn-view-explorer" class="ot-view-toggle-btn">
            Explorer view
          </button>
        </div>

        <div class="ot-travel-scene-wrapper ot-viewport-window">
          <canvas
            id="ot-trail-canvas"
            class="ot-trail-canvas"
            aria-hidden="true"
          ></canvas>
          <div id="ot-scene" class="ot-travel-scene"></div>
          <div class="ot-travel-scene-overlay" id="ot-scene-caption"></div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">Trail info</div>
          <div
            class="ot-panel-body ot-panel-body-sm"
            id="ot-trail-header"
          ></div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">
            Trail map
            <button
              id="ot-btn-toggle-maplist"
              class="ot-link-button"
              type="button"
            >
              Show waypoints
            </button>
          </div>
          <div class="ot-panel-body">
            <div
              class="ot-map-viewport ot-viewport-window"
              id="ot-map-viewport"
            ></div>
            <div class="ot-trail-map" id="ot-trail-map"></div>
          </div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">Companion detail</div>
          <div class="ot-panel-body" id="ot-companion-detail"></div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">Trail log</div>
          <div class="ot-panel-body" id="ot-trail-log-panel">
            <div id="old-trail-log-widget">
              <div class="ot-log-shell">
                <div class="ot-log-header">
                  <div class="ot-log-title">Trail Log</div>
                  <div class="ot-log-sub">Journal of the Journey</div>
                </div>
                <div class="ot-log-body">
                  <div class="ot-log-list"></div>
                </div>
                <div class="ot-log-footer">
                  <div>Recent entries</div>
                  <div class="ot-footer-pill">Handwritten mode</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">
            Supplies overview
            <button
              id="ot-btn-open-inventory"
              class="ot-link-button"
              type="button"
            >
              Inventory
            </button>
          </div>
          <div class="ot-panel-body" id="ot-supplies-overview"></div>
        </div>
      </div>
    </div>

    <div class="ot-footer">
      <div class="ot-footer-left" id="ot-footer-status"></div>
      <div class="ot-footer-right">
        <button id="ot-btn-advance-1" class="ot-btn-gold">
          Advance 1 hour
        </button>
        <button id="ot-btn-advance-4" class="ot-btn-gold">
          Advance 4 hours
        </button>
        <button id="ot-btn-toggle-mode" class="ot-btn-outline">
          Toggle travel / camp
        </button>
        <button id="ot-btn-change-pace" class="ot-btn-outline">
          Change pace
        </button>
        <button id="ot-btn-change-rations" class="ot-btn-outline">
          Change rations
        </button>
        <button id="ot-btn-evening-proper-camp" class="ot-btn-outline">
          Proper camp (2h)
        </button>
        <button id="ot-btn-evening-rushed-camp" class="ot-btn-outline">
          Rushed camp (1h)
        </button>
        <button id="ot-btn-open-camp-tasks" class="ot-btn-outline">
          Camp tasks
        </button>
      </div>
    </div>
  </div>

  <!-- Camp tasks & crafting overlay -->
  <div id="ot-camp-overlay">
    <div class="ot-overlay-inner">
      <div class="ot-overlay-panel">
        <div class="ot-panel-header" style="margin-bottom: 6px">
          Camp tasks planner
        </div>
        <div id="oldtrail-camp-menu-widget"></div>
        <div style="display: flex; gap: 8px; margin-top: 8px; align-items: center">
          <button id="ot-btn-camp-confirm" class="ot-btn-gold">Confirm chores</button>
          <button id="ot-btn-camp-auto" class="ot-btn-outline">Auto plan</button>
          <div class="ot-text-muted" id="ot-camp-summary-note"></div>
        </div>
      </div>
      <div class="ot-overlay-panel">
        <div class="ot-panel-header" style="margin-bottom: 6px">
          Crafting & repairs
        </div>
        <div id="oldtrail-crafting-widget"></div>
      </div>
      <button id="ot-btn-close-camp" class="ot-btn-outline ot-overlay-close">Close</button>
    </div>
  </div>

  <div id="oldtrail-thoughts-bubble" style="display: none">
    <div class="tb-window">
      <div class="tb-header">
        <span class="tb-name">Companion</span>
        <span class="tb-close">×</span>
      </div>
      <div class="tb-body">
        <div class="tb-avatar"></div>
        <div style="flex: 1">
          <div class="tb-text">Quiet thoughts by the fire.</div>
          <div class="tb-mood-row">
            <div class="tb-mood-bar">
              <div class="tb-mood-fill"></div>
            </div>
            <div class="tb-mood-label">Mood</div>
          </div>
        </div>
      </div>
      <div class="tb-footer">Tap to cycle thoughts</div>
    </div>
  </div>

  <!-- INVENTORY MODAL -->
  <div id="ot-inventory-modal" class="ot-modal">
    <div class="ot-modal-backdrop"></div>
    <div class="ot-modal-content">
      <div class="ot-modal-title">Wagon inventory</div>
      <div id="ot-inventory-sub" class="ot-modal-sub"></div>
      <table class="ot-inventory-table">
        <thead>
          <tr>
            <th>Item</th>
            <th>Qty</th>
            <th>Use</th>
          </tr>
        </thead>
        <tbody id="ot-inventory-body"></tbody>
      </table>
      <div style="display: flex; justify-content: flex-end; margin-top: 6px;">
        <button id="ot-btn-close-inventory" class="ot-btn-outline">
          Close
        </button>
      </div>
    </div>
  </div>

  <!-- WORK PRIORITIES MODAL -->
  <div id="ot-priorities-modal" class="ot-modal">
    <div class="ot-modal-backdrop"></div>
    <div class="ot-modal-content">
      <div class="ot-modal-title">Work priorities</div>
      <div id="ot-priorities-sub" class="ot-modal-sub ot-priorities-legend">
        Set what each person focuses on when set to “auto”. Lower numbers are
        higher priority; “—” means they rarely do that job unless you assign it
        directly. Toggling between travel and camp will reset hour-by-hour
        assignments so the auto system can re-balance jobs.
      </div>
      <table class="ot-priorities-table">
        <thead>
          <tr id="ot-priorities-head-row"></tr>
        </thead>
        <tbody id="ot-priorities-body"></tbody>
      </table>
      <div id="ot-priorities-warnings" class="ot-priorities-warnings"></div>
      <div style="display: flex; justify-content: flex-end; margin-top: 6px;">
        <button id="ot-btn-close-priorities" class="ot-btn-outline">
          Close
        </button>
      </div>
    </div>
  </div>
</div>

<script>
(function () {
  "use strict";

  /* ========= CONSTANTS & DATA ============================================= */

  const SAVE_KEY = "oldtrail_hourly_v2";
  const HOURS_PER_DAY = 24;

  const IMAGE_URLS = {
    start_screen:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/start-screen_orig.png",
    st_joseph_start:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/stjoseph-start2_orig.png",
    council_bluffs_start:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/councilbluff-start_orig.png",
    independence_start_edge:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/independence-start2_orig.png",
    leaving_independence:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/leaving-independnce_orig.png",
    kansas_bottomlands:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/kansasriver-bottomlands_orig.png",
    little_blue_spring:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/littlebluevalley-spring_orig.png",
    little_blue_burned:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/littlebluevalley-burned-out_orig.png",
    platte_clear:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/centralplatte-clear_orig.png",
    platte_heat_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/centralplatte-heat-storm_orig.png",
    buffalo_plains_heat:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/buffaloplains-summerheat_orig.png",
    buffalo_plains_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/buffaloplains-storm_orig.png",
    chimney_clear:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/chimney-clear_orig.png",
    chimney_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/chimney-storm_orig.png",
    fort_kearny_camp:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-kearny_orig.png",
    fort_laramie_approach:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-laramie_orig.png",
    register_cliffs:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/register-cliffs_orig.png",
    independence_rock:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/independence-rock_orig.png",
    devils_gate:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/devilsgate_orig.png",
    south_pass_clear:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/southpass-clear_orig.png",
    south_pass_midsummer:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/southpass-midsummer_orig.png",
    soda_springs_morning:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/sodasprings-earlymorning_orig.png",
    soda_springs_warm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/sodasprings-warmday_orig.png",
    snake_bench_heat:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/snakeriver-bench-heat_orig.png",
    snake_bench_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/snakeriver-bench-storm_orig.png",
    salmon_falls_dusk:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/salmonfalls-dusk_orig.png",
    salmon_falls_summer:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/salmonfalls-summer_orig.png",
    alkali_flats_evening:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/alkaliflats-evening_orig.png",
    alkali_flats_day:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/alkaliflats-summer_orig.png",
    three_island_calm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/threeislandcrossing-calm_orig.png",
    three_island_danger:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/threeislandcrossing-danger_orig.png",
    grande_ronde_autumn:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/granderonde-valley-autumn_orig.png",
    grande_ronde_summer:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/granderonde-valley-summer_orig.png",
    blue_mountains_clear:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/bluemtnsroad-clear_orig.png",
    blue_mountains_rain:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/bluemtnsroad-rain_orig.png",
    mountain_creek_calm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/mountaincreek-calm_orig.png",
    mountain_creek_danger:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/mountaincreek-danger_orig.png",
    columbia_gorge_primary:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/columbiagorge-primary_orig.png",
    columbia_gorge_rain:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/columbiagorge-rain_orig.png",
    dalles_primary:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/dalles-primary_orig.png",
    dalles_evening:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/dalles-evening_orig.png",
    barlow_clear:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/barlow-mthood-clear_orig.png",
    barlow_snow:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/barlow-mthood-snow_orig.png",
    oregon_city_primary:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/oregoncity-primary_orig.png",
    oregon_city_rain:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/oregoncity-rain_orig.png",
    oregon_city_spring:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/oregoncity-springmorning_orig.png",
    willamette_valley:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/willamette-valley-arrival_orig.png",
    generalstore_missouri:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/generalstore-missouri_orig.png",
    generalstore_missouri_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/generalstore-missouri-storm_orig.png",
    fort_kearny_sutler:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-kearny-sutler-primary_orig.png",
    fort_laramie_yard:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-laramie-parade_orig.png",
    fort_laramie_evening:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-laramie-evening_orig.png",
    fort_bridger_evening:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-bridger-evening_orig.png",
    fort_bridger_cold:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-bridger-cold2_orig.png",
    fort_hall_summer:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-hall-summer_orig.png",
    fort_hall_rain:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-hall-rain_orig.png",
    fort_boise_primary:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-boise-primary_orig.png",
    fort_boise_flood:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-boise-flooded_orig.png",
    generalstore_independence_day:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/generalstore-independence-day_orig.png",
    generalstore_independence_night:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/generalstore-interior-independence_orig.png",
    trail_trading_tent:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/trail-trading-tent_orig.png",
    fort_blacksmith:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-blacksmith_orig.png",
    fort_blacksmith_morning:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-blacksmith-morning_orig.png",
    fort_doctor_morning:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-doctor-morning_orig.png",
    fort_doctor_night:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-doctor-night2_orig.png",
    native_trade_lodge:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/native-trade-lodge_orig.png",
    mission_dining:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/mission-whitman-dining_orig.png",
    camp_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/camp-storm_orig.png",
    camp_sunrise_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/camp-sunrise-storm_orig.png",
    prairie_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/prairire-storm_orig.png",
    bluemtns_flurries:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/bluemtns-flurries_orig.png",
    dust_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/dust-storm_orig.png",
    prairie_fire:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/prairie-fire_orig.png",
    kansasriver_calm_day:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/kansasriver-calm_orig.png",
    kansasriver_calm_sunset:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/kansasriver-calm-sunset_orig.png",
    kansasriver_danger:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/kansasriver-danger_orig.png",
    kansasriver_ferry:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/kansasriver-ferry_orig.png",
    bigblueriver_crossing:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/bigblueriver-crossing_orig.png",
    snakeriver_threeisle_ford:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/snakeriver-threeisle-ford_orig.png",
    snakeriver_caulked:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/snakeriver-caulked_orig.png",
    columbiariver_rafting:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/columbiariver-rafting_orig.png",
    wagon_river_tipped:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-river-tipped_orig.png",
    wagon_brokenwheel:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-brokenwheel_orig.png",
    wagon_snappedaxle:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-snappedaxle_orig.png",
    wagon_snappedaxle_rain:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-snappedaxle-rain_orig.png",
    wagon_steep_descent:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-steep-descent_orig.png",
    wagon_stuck_mud:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-stuck-mud_orig.png",
    wagon_abandoned:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-abandoned_orig.png",
    camp_evening:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/camp-evening_orig.png",
    camp_hunting:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/camp-hunting_orig.png",
    foraging:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/foraging_orig.png",
    trade_salmon:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/trade-salmon_orig.png",
    feast_cayuse_nez:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/feast-cayuse-nez_orig.png",
    hunt_buffalo:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/hunt-buffalo_orig.png",
    hunt_buffalo_dead:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/hunt-buffalo-dead_orig.png",
    stalk_deer_primary:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/stalk-deer-primary_orig.png",
    stalk_deer_timberline:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/stalk-deer-timberline_orig.png",
    hunt_smallgame:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/hunt-smallgame_orig.png",
    illness_cholera:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/illness-cholera_orig.png",
    illness_dysentary:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/illness-dysentary_orig.png",
    illness_fever:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/illness-fever_orig.png",
    illness_snakebite:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/illness-snakebite_orig.png",
    illness_brokenleg:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/illness-brokenleg_orig.png",
    illness_frostbite:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/illness-frostbite_orig.png",
    death_burial:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/death_orig.png",
    travelers_in_need:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/travelers-in-need_orig.png",
    trade_native:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/trade-native_orig.png",
    hostile_tension:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/hostile-tension_orig.png",
    help_stranger:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/help-stranger_orig.png",
    wagon_lost:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-lost_orig.png",
    buffalo_stampede:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/buffalo-stampede_orig.png",
    alkali_water:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/alkali-water_orig.png",
  };

  const ROUTE_MILESTONES = [
    { mile: 0, name: "Independence", region: "plains" },
    { mile: 80, name: "Kansas River crossing", region: "plains" },
    { mile: 150, name: "Big Blue River", region: "plains" },
    { mile: 300, name: "Fort Kearny", region: "central_plains" },
    { mile: 450, name: "Chimney Rock", region: "central_plains" },
    { mile: 560, name: "Fort Laramie", region: "high_plains" },
    { mile: 700, name: "Independence Rock", region: "high_plains" },
    { mile: 820, name: "South Pass", region: "high_plains" },
    { mile: 980, name: "Fort Bridger", region: "mountains" },
    { mile: 1180, name: "Fort Hall", region: "snake_plain" },
    { mile: 1450, name: "Three Island Crossing", region: "snake_plain" },
    { mile: 1650, name: "Blue Mountains", region: "blue_mountains" },
    { mile: 1880, name: "The Dalles / Columbia", region: "columbia" },
    { mile: 2050, name: "Oregon City", region: "willamette" },
  ];

  const SCENE_BANDS = [
    {
      from: 0,
      to: 120,
      label: "Missouri farm country",
      clear: [IMAGE_URLS.leaving_independence, IMAGE_URLS.independence_start_edge],
      heat: [IMAGE_URLS.leaving_independence],
      storm: [IMAGE_URLS.prairie_storm],
    },
    {
      from: 120,
      to: 260,
      label: "Kansas River & bottomlands",
      clear: [IMAGE_URLS.kansas_bottomlands, IMAGE_URLS.kansasriver_calm_day],
      heat: [IMAGE_URLS.kansasriver_calm_day],
      storm: [IMAGE_URLS.kansasriver_danger],
    },
    {
      from: 260,
      to: 420,
      label: "Little Blue & central Platte",
      clear: [IMAGE_URLS.little_blue_spring, IMAGE_URLS.platte_clear],
      heat: [IMAGE_URLS.buffalo_plains_heat],
      storm: [IMAGE_URLS.buffalo_plains_storm],
    },
    {
      from: 420,
      to: 620,
      label: "Chimney Rock & Scotts Bluff",
      clear: [IMAGE_URLS.chimney_clear],
      heat: [IMAGE_URLS.chimney_clear],
      storm: [IMAGE_URLS.chimney_storm],
    },
    {
      from: 620,
      to: 820,
      label: "Fort Laramie & Sweetwater",
      clear: [IMAGE_URLS.fort_laramie_approach, IMAGE_URLS.register_cliffs],
      cold: [IMAGE_URLS.register_cliffs],
      storm: [IMAGE_URLS.prairie_storm],
    },
    {
      from: 820,
      to: 1050,
      label: "South Pass & high plains",
      clear: [IMAGE_URLS.south_pass_clear, IMAGE_URLS.independence_rock],
      cold: [IMAGE_URLS.south_pass_midsummer],
      storm: [IMAGE_URLS.bluemtns_flurries],
    },
    {
      from: 1050,
      to: 1400,
      label: "Snake River plain & Salmon Falls",
      clear: [IMAGE_URLS.soda_springs_warm, IMAGE_URLS.salmon_falls_summer],
      heat: [IMAGE_URLS.snake_bench_heat, IMAGE_URLS.alkali_flats_day],
      storm: [IMAGE_URLS.snake_bench_storm],
    },
    {
      from: 1400,
      to: 1700,
      label: "Grande Ronde & Blue Mountains",
      clear: [IMAGE_URLS.grande_ronde_summer, IMAGE_URLS.blue_mountains_clear],
      cold: [IMAGE_URLS.bluemtns_flurries],
      storm: [IMAGE_URLS.blue_mountains_rain],
    },
    {
      from: 1700,
      to: 1900,
      label: "Columbia Gorge & The Dalles",
      clear: [IMAGE_URLS.columbia_gorge_primary, IMAGE_URLS.dalles_primary],
      storm: [IMAGE_URLS.columbia_gorge_rain],
      cold: [IMAGE_URLS.dalles_evening],
    },
    {
      from: 1900,
      to: 2050,
      label: "Willamette Valley & Oregon City",
      clear: [IMAGE_URLS.oregon_city_primary, IMAGE_URLS.willamette_valley],
      storm: [IMAGE_URLS.oregon_city_rain],
      cold: [IMAGE_URLS.oregon_city_spring],
    },
  ];

  /* --- Monthly climate baselines by region (rough, era-appropriate) ------- */

  const CLIMATE = {
    GreatPlains: {
      monthly: {
        April: { pRain: 0.28, pStorm: 0.06, tMin: 2, tMax: 16, windKph: [8, 24] },
        May: { pRain: 0.34, pStorm: 0.1, tMin: 8, tMax: 22, windKph: [8, 28] },
        June: { pRain: 0.3, pStorm: 0.14, tMin: 13, tMax: 29, windKph: [10, 32] },
        July: { pRain: 0.25, pStorm: 0.12, tMin: 15, tMax: 33, windKph: [12, 36] },
        August: { pRain: 0.22, pStorm: 0.1, tMin: 14, tMax: 32, windKph: [10, 30] },
        September: { pRain: 0.2, pStorm: 0.08, tMin: 10, tMax: 27, windKph: [9, 26] },
      },
    },
    HighPlains: {
      monthly: {
        April: { pRain: 0.24, pStorm: 0.07, tMin: -1, tMax: 14, windKph: [10, 28] },
        May: { pRain: 0.28, pStorm: 0.1, tMin: 4, tMax: 19, windKph: [10, 30] },
        June: { pRain: 0.26, pStorm: 0.14, tMin: 9, tMax: 24, windKph: [12, 32] },
        July: { pRain: 0.22, pStorm: 0.12, tMin: 12, tMax: 29, windKph: [12, 34] },
        August: { pRain: 0.18, pStorm: 0.1, tMin: 10, tMax: 28, windKph: [10, 30] },
        September: { pRain: 0.18, pStorm: 0.08, tMin: 6, tMax: 23, windKph: [9, 28] },
      },
    },
    Rockies: {
      monthly: {
        April: { pRain: 0.26, pStorm: 0.1, tMin: -6, tMax: 11, windKph: [10, 32] },
        May: { pRain: 0.26, pStorm: 0.12, tMin: -2, tMax: 15, windKph: [10, 34] },
        June: { pRain: 0.24, pStorm: 0.16, tMin: 2, tMax: 20, windKph: [12, 36] },
        July: { pRain: 0.2, pStorm: 0.14, tMin: 6, tMax: 23, windKph: [12, 36] },
        August: { pRain: 0.18, pStorm: 0.12, tMin: 5, tMax: 22, windKph: [10, 32] },
        September: { pRain: 0.22, pStorm: 0.14, tMin: 0, tMax: 17, windKph: [10, 30] },
      },
    },
    SnakePlain: {
      monthly: {
        May: { pRain: 0.18, pStorm: 0.08, tMin: 7, tMax: 24, windKph: [8, 26] },
        June: { pRain: 0.14, pStorm: 0.1, tMin: 10, tMax: 30, windKph: [10, 30] },
        July: { pRain: 0.12, pStorm: 0.12, tMin: 13, tMax: 34, windKph: [10, 32] },
        August: { pRain: 0.1, pStorm: 0.1, tMin: 12, tMax: 33, windKph: [10, 30] },
        September: { pRain: 0.12, pStorm: 0.08, tMin: 8, tMax: 27, windKph: [8, 26] },
      },
    },
    Columbia: {
      monthly: {
        June: { pRain: 0.18, pStorm: 0.08, tMin: 9, tMax: 24, windKph: [8, 24] },
        July: { pRain: 0.16, pStorm: 0.08, tMin: 11, tMax: 27, windKph: [8, 24] },
        August: { pRain: 0.18, pStorm: 0.08, tMin: 11, tMax: 26, windKph: [8, 22] },
        September: { pRain: 0.22, pStorm: 0.12, tMin: 8, tMax: 22, windKph: [8, 22] },
        October: { pRain: 0.28, pStorm: 0.14, tMin: 5, tMax: 18, windKph: [8, 20] },
      },
    },
  };

  const PACE_CONFIG = {
    steady: { id: "steady", label: "Steady", milesPerHour: 1.5, staminaCost: 4 },
    slow: { id: "slow", label: "Slow", milesPerHour: 1.1, staminaCost: 2 },
    grueling: {
      id: "grueling",
      label: "Grueling",
      milesPerHour: 1.8,
      staminaCost: 7,
    },
  };

  const RATION_CONFIG = {
    filling: {
      id: "filling",
      label: "Full rations",
      targetHunger: 80,
      targetThirst: 80,
      hungerDrainPerHour: 3,
      thirstDrainPerHour: 4,
    },
    normal: {
      id: "normal",
      label: "Normal rations",
      targetHunger: 70,
      targetThirst: 75,
      hungerDrainPerHour: 3.5,
      thirstDrainPerHour: 4.5,
    },
    meager: {
      id: "meager",
      label: "Meager rations",
      targetHunger: 60,
      targetThirst: 70,
      hungerDrainPerHour: 4.2,
      thirstDrainPerHour: 5,
    },
    barebones: {
      id: "barebones",
      label: "Bare-bones",
      targetHunger: 55,
      targetThirst: 65,
      hungerDrainPerHour: 4.8,
      thirstDrainPerHour: 5.2,
    },
  };

  const TASKS = [
    { id: "auto", label: "Let them decide (auto)" },
    { id: "travel", label: "Travel with wagon" },
    { id: "scout", label: "Scout ahead" },
    { id: "hunt", label: "Hunt for game" },
    { id: "gather_wood", label: "Gather wood / chips" },
    { id: "fetch_water", label: "Fetch water" },
    { id: "cook", label: "Cook meals" },
    { id: "repair", label: "Repair wagon / gear" },
    { id: "guard", label: "Stand watch / guard" },
    { id: "rest", label: "Rest" },
    { id: "sleep", label: "Sleep" },
  ];

  // Delegation job definitions for the priority matrix
  const JOB_DEFS = [
    { id: "travel",      label: "Travel",      taskId: "travel",      relatedSkill: "travel",     vital: false },
    { id: "scout",       label: "Scout",       taskId: "scout",       relatedSkill: "travel",     vital: false },
    { id: "hunt",        label: "Hunt",        taskId: "hunt",        relatedSkill: "hunting",    vital: true  },
    { id: "cook",        label: "Cook",        taskId: "cook",        relatedSkill: "cooking",    vital: true  },
    { id: "gather_wood", label: "Wood",        taskId: "gather_wood", relatedSkill: "woodcutting", vital: false },
    { id: "fetch_water", label: "Water",       taskId: "fetch_water", relatedSkill: "travel",     vital: true  },
    { id: "repair",      label: "Repair",      taskId: "repair",      relatedSkill: "woodcutting", vital: true },
    { id: "guard",       label: "Guard",       taskId: "guard",       relatedSkill: "travel",     vital: true  },
    { id: "doctor",      label: "Doctor",      taskId: "rest",        relatedSkill: "doctoring",  vital: true  },
  ];

  // Supplies including prepared meal types
  const SUPPLY_ITEMS = [
    {
      id: "flour",
      name: "Flour",
      category: "FOOD",
      unit: "lb",
      cost: 0.02,
      weight: 1,
      recommended: 600,
    },
    {
      id: "bacon",
      name: "Bacon / salt pork",
      category: "FOOD",
      unit: "lb",
      cost: 0.08,
      weight: 1,
      recommended: 150,
    },
    {
      id: "beans_rice",
      name: "Beans & rice",
      category: "FOOD",
      unit: "lb",
      cost: 0.06,
      weight: 1,
      recommended: 80,
    },
    {
      id: "hardtack",
      name: "Hardtack biscuits",
      category: "FOOD",
      unit: "lb",
      cost: 0.03,
      weight: 1,
      recommended: 40,
    },
    {
      id: "dried_fruit",
      name: "Dried fruit",
      category: "FOOD",
      unit: "lb",
      cost: 0.06,
      weight: 1,
      recommended: 50,
    },
    {
      id: "coffee",
      name: "Coffee",
      category: "FOOD",
      unit: "lb",
      cost: 0.10,
      weight: 1,
      recommended: 8,
    },
    {
      id: "tea",
      name: "Tea",
      category: "FOOD",
      unit: "lb",
      cost: 0.10,
      weight: 1,
      recommended: 2,
    },
    {
      id: "sugar",
      name: "Sugar & molasses",
      category: "FOOD",
      unit: "lb",
      cost: 0.08,
      weight: 1,
      recommended: 40,
    },
    {
      id: "salt_soda",
      name: "Salt & soda",
      category: "FOOD",
      unit: "lb",
      cost: 0.06,
      weight: 1,
      recommended: 12,
    },
    {
      id: "fresh_meat",
      name: "Fresh game meat",
      category: "FOOD",
      unit: "lb",
      cost: 0.05,
      weight: 1,
      recommended: 0,
    },
    {
      id: "meal_simple",
      name: "Simple hot meals",
      category: "FOOD_PREPARED",
      unit: "meal",
      cost: 0,
      weight: 0.5,
      recommended: 0,
      readOnly: true,
    },
    {
      id: "meal_hearty",
      name: "Hearty suppers",
      category: "FOOD_PREPARED",
      unit: "meal",
      cost: 0,
      weight: 0.6,
      recommended: 0,
      readOnly: true,
    },
    {
      id: "meal_feast",
      name: "Trail feasts",
      category: "FOOD_PREPARED",
      unit: "meal",
      cost: 0,
      weight: 0.7,
      recommended: 0,
      readOnly: true,
    },
    {
      id: "cooked_meals",
      name: "Cooked meals (legacy)",
      category: "FOOD_PREPARED",
      unit: "meal",
      cost: 0,
      weight: 0.5,
      recommended: 0,
      readOnly: true,
    },
    {
      id: "water_barrels",
      name: "Water barrels",
      category: "WATER",
      unit: "barrel",
      cost: 3.0,
      weight: 40,
      recommended: 1,
    },
    {
      id: "water",
      name: "Water in camp (gallons)",
      category: "WATER",
      unit: "gal",
      cost: 0,
      weight: 8,
      recommended: 40,
      readOnly: true,
    },
    {
      id: "firewood",
      name: "Firewood",
      category: "FUEL",
      unit: "bundle",
      cost: 0.2,
      weight: 20,
      recommended: 4,
    },
    {
      id: "buffalo_chips",
      name: "Buffalo chips (fuel)",
      category: "FUEL",
      unit: "sack",
      cost: 0.25,
      weight: 10,
      recommended: 0,
    },
    {
      id: "oxen",
      name: "Oxen",
      category: "ANIMALS",
      unit: "head",
      cost: 30,
      weight: 0,
      recommended: 6,
    },
    {
      id: "milk_cows",
      name: "Milk cows",
      category: "ANIMALS",
      unit: "head",
      cost: 70,
      weight: 0,
      recommended: 1,
    },
    {
      id: "wheels",
      name: "Spare wheels",
      category: "PARTS",
      unit: "ea",
      cost: 10,
      weight: 60,
      recommended: 1,
    },
    {
      id: "axles",
      name: "Spare axles",
      category: "PARTS",
      unit: "ea",
      cost: 8,
      weight: 40,
      recommended: 1,
    },
    {
      id: "tongues",
      name: "Spare tongues",
      category: "PARTS",
      unit: "ea",
      cost: 8,
      weight: 40,
      recommended: 1,
    },
    {
      id: "ammo",
      name: "Ammunition",
      category: "AMMO",
      unit: "box",
      cost: 2.5,
      weight: 2,
      recommended: 10,
    },
    {
      id: "rifles",
      name: "Rifles",
      category: "AMMO",
      unit: "ea",
      cost: 15,
      weight: 8,
      recommended: 2,
    },
    {
      id: "med_kits",
      name: "Medicines & bandages",
      category: "MED",
      unit: "kit",
      cost: 6,
      weight: 2,
      recommended: 2,
    },
  ];

  // Food values for auto-eating & inventory
  const FOOD_VALUES = {
    flour: { lbsPerServing: 0.4, hungerGain: 18, moraleGain: 1 },
    bacon: { lbsPerServing: 0.4, hungerGain: 22, moraleGain: 2 },
    beans_rice: { lbsPerServing: 0.4, hungerGain: 20, moraleGain: 1 },
    hardtack: { lbsPerServing: 0.4, hungerGain: 14, moraleGain: 0 },
    dried_fruit: { lbsPerServing: 0.3, hungerGain: 10, moraleGain: 1 },
    fresh_meat: { lbsPerServing: 0.5, hungerGain: 24, moraleGain: 2, warmthGain: 1 },
    meal_simple: {
      lbsPerServing: 0.5,
      hungerGain: 28,
      moraleGain: 2,
      warmthGain: 2,
      isPrepared: true,
    },
    meal_hearty: {
      lbsPerServing: 0.6,
      hungerGain: 35,
      moraleGain: 3,
      warmthGain: 2,
      energyGain: 4,
      isPrepared: true,
    },
    meal_feast: {
      lbsPerServing: 0.7,
      hungerGain: 42,
      moraleGain: 5,
      warmthGain: 3,
      energyGain: 6,
      isPrepared: true,
    },
    cooked_meals: {
      lbsPerServing: 0.5,
      hungerGain: 35,
      moraleGain: 3,
      warmthGain: 2,
      isPrepared: true,
    },
    // NEW – drinks for morale / warmth
    coffee: {
      lbsPerServing: 0.05, // ~20 cups / lb
      hungerGain: 0,
      moraleGain: 2,
      warmthGain: 1,
      energyGain: 4,
      isPrepared: true,
    },
    tea: {
      lbsPerServing: 0.04,
      hungerGain: 0,
      moraleGain: 1,
      warmthGain: 1,
      energyGain: 2,
      isPrepared: true,
    },
  };

    // Nutrition tags for the long‑term diet system
  const NUTRITION_TAGS = {
    flour:       { staples: 1.0 },
    hardtack:    { staples: 0.9 },
    beans_rice:  { staples: 0.8, meatFat: 0.4 },
    bacon:       { meatFat: 1.2 },
    fresh_meat:  { meatFat: 1.0, fruitVeg: 0.2 }, // fresh meat carries a little vitamin C
    dried_fruit: { fruitVeg: 1.8 },
    meal_simple: { staples: 0.7, meatFat: 0.4, fruitVeg: 0.3 },
    meal_hearty: { staples: 0.6, meatFat: 0.6, fruitVeg: 0.5 },
    meal_feast:  { staples: 0.5, meatFat: 0.8, fruitVeg: 0.7 },
    cooked_meals:{ staples: 0.6, meatFat: 0.5, fruitVeg: 0.3 },
    coffee:      { coffeeTea: 1.0 },
    tea:         { coffeeTea: 0.8 },
  };


  const WATER_PER_DRINK = 0.25; // gallons per drink

  const BACKGROUNDS = {
    farmer: {
      label: "Farmer from Illinois",
      startingMoney: 700,
      skillBias: { travel: 2, hunting: 1, cooking: 1, woodcutting: 2, doctoring: 0 },
      desc:
        "Low on cash but used to livestock, rough work, and making do with simple food.",
    },
    banker: {
      label: "Banker from the East",
      startingMoney: 1100,
      skillBias: { travel: 1, hunting: 0, cooking: 0, woodcutting: 0, doctoring: 1 },
      desc:
        "Arrives with a long purse and fine clothes, but little experience of trail hardships.",
    },
    carpenter: {
      label: "Carpenter from Ohio",
      startingMoney: 800,
      skillBias: { travel: 2, hunting: 1, cooking: 0, woodcutting: 2, doctoring: 0 },
      desc:
        "Handy with tools and repairs. A good choice if you're worried about the wagon.",
    },
    teacher: {
      label: "Schoolteacher from New England",
      startingMoney: 750,
      skillBias: { travel: 1, hunting: 0, cooking: 1, woodcutting: 0, doctoring: 2 },
      desc:
        "Thoughtful and literate, with a knack for keeping spirits up and treating minor ailments.",
    },
  };

  const START_PROFILES = {
    early_april: {
      id: "early_april",
      label: "Early April – high rivers & cold",
      summary:
        "Snowmelt keeps the Missouri and Platte swollen; nights are cold and grass is weak.",
      riverHazard: "high",
      heatHazard: "low",
      forageBonus: "low",
      lateSeasonRisk: "low",
      startMonth: 3,
      startDay: 10,
    },
    late_april: {
      id: "late_april",
      label: "Late April – balanced window",
      summary:
        "Classic departure window as rivers fall and new grass appears across the plains.",
      riverHazard: "medium",
      heatHazard: "medium",
      forageBonus: "medium",
      lateSeasonRisk: "medium",
      startMonth: 3,
      startDay: 25,
    },
    mid_may: {
      id: "mid_may",
      label: "Mid May – good grass, some storms",
      summary:
        "Plenty of grass and milder nights, but spring storms can still sweep the prairie.",
      riverHazard: "medium",
      heatHazard: "medium",
      forageBonus: "high",
      lateSeasonRisk: "medium",
      startMonth: 4,
      startDay: 15,
    },
    early_june: {
      id: "early_june",
      label: "Early June – hot plains ahead",
      summary:
        "Most rivers have crested. Expect hotter days, stronger thunderstorms, and dusty drives.",
      riverHazard: "low",
      heatHazard: "high",
      forageBonus: "high",
      lateSeasonRisk: "medium",
      startMonth: 5,
      startDay: 5,
    },
    mid_july: {
      id: "mid_july",
      label: "Mid July – late for the passes",
      summary:
        "Heat and dust on the Platte and Snake, and an anxious race to beat autumn snows in the mountains.",
      riverHazard: "low",
      heatHazard: "high",
      forageBonus: "medium",
      lateSeasonRisk: "high",
      startMonth: 6,
      startDay: 10,
    },
  };

  const AFFLICTION_DEFS = {
    dysentery: {
      id: "dysentery",
      label: "Dysentery",
      type: "disease",
      baseHoursIncubation: [6, 24],
      baseHoursAcute: [24, 96],
      severityRange: [1, 2],
      cause: "bad water in cholera corridor",
    },
    camp_fever: {
      id: "camp_fever",
      label: "Camp fever",
      type: "disease",
      baseHoursIncubation: [24, 72],
      baseHoursAcute: [48, 144],
      severityRange: [1, 3],
      cause: "weeks of poor rest and damp camps",
    },
    sprain: {
      id: "sprain",
      label: "Sprained ankle",
      type: "injury",
      baseHoursIncubation: [0, 1],
      baseHoursAcute: [24, 72],
      severityRange: [1, 1],
      cause: "misstep on rough ground",
    },
  };

  const CAMP_TASKS = [
    {
      id: "cook_hot_meal",
      label: "Cook a hot meal",
      hours: 2,
      effects: { hunger: 18, morale: 4, warmth: 2 },
      desc: "Warm stew, coffee, and flour cakes for the group.",
      priority: "food",
    },
    {
      id: "gather_fuel",
      label: "Gather fuel",
      hours: 1.5,
      effects: { warmth: 6, energy: -2 },
      desc: "Collect wood or buffalo chips for the night fire.",
      priority: "safety",
    },
    {
      id: "fetch_and_boil_water",
      label: "Fetch & boil water",
      hours: 1.5,
      effects: { thirst: 18, condition: 1 },
      desc: "Haul water, boil to cut illness risk.",
      priority: "water",
    },
    {
      id: "mend_clothes_and_boots",
      label: "Mend clothes & boots",
      hours: 1.5,
      effects: { warmth: 4, condition: 3, morale: 2 },
      desc: "Patch canvas, resew soles.",
      priority: "repair",
    },
    {
      id: "repair_wagon_and_tackle",
      label: "Repair wagon & tackle",
      hours: 1.5,
      effects: { wagon: 6, energy: -2 },
      desc: "Tighten bolts, grease wheels, check yokes.",
      priority: "repair",
    },
    {
      id: "treat_wounds_and_ill",
      label: "Treat wounds & ill",
      hours: 1,
      effects: { condition: 4, morale: 2 },
      desc: "Clean cuts, tend the sick, share tonics.",
      priority: "care",
    },
    {
      id: "preserve_meat",
      label: "Preserve meat",
      hours: 2,
      effects: { supplies: { preserved_meat: 4, fresh_meat: -4 }, morale: 1 },
      desc: "Smoke or dry meat for the days ahead.",
      priority: "food",
    },
    {
      id: "set_snares_short_hunt",
      label: "Set snares / short hunt",
      hours: 2.5,
      effects: { supplies: { fresh_meat: 3, ammo: -1 }, energy: -4 },
      desc: "Chance at meat by dawn; tiring.",
      priority: "food",
    },
    {
      id: "stand_guard_night_watch",
      label: "Night watch",
      hours: 1.5,
      effects: { guard: 1, energy: -3 },
      desc: "Watch for raiders or stampede.",
      priority: "safety",
    },
    {
      id: "extra_sleep",
      label: "Extra sleep",
      hours: 3,
      effects: { energy: 12, condition: 5 },
      desc: "Turn in early and recover.",
      priority: "rest",
    },
    {
      id: "read_book",
      label: "Read by lantern light",
      hours: 1,
      effects: { morale: 4, energy: 2 },
      desc: "Quiet reading that lifts spirits.",
      priority: "rest",
    },
  ];

  const CRAFTING_RECIPES = [
    {
      id: "smoked_meat",
      name: "Smoked meat",
      pattern: "110110000",
      inputs: [
        { key: "fresh_meat", amount: 4 },
        { key: "salt", amount: 1 },
        { key: "fuel", amount: 1 },
      ],
      output: { key: "preserved_meat", amount: 4 },
      hoursCost: 2,
      skillTag: "cooking",
      desc: "Preserve meat for longer stretches of trail.",
      icon: "SM",
    },
    {
      id: "repaired_shoes",
      name: "Repair shoes",
      pattern: "010111010",
      inputs: [
        { key: "leather", amount: 1 },
        { key: "needle", amount: 1 },
      ],
      output: { key: "boot_durability", amount: 5 },
      hoursCost: 1.5,
      skillTag: "crafting",
      desc: "Patch soles and reduce future foot injuries.",
      icon: "RS",
    },
    {
      id: "patched_cover",
      name: "Patch wagon cover",
      pattern: "111111000",
      inputs: [
        { key: "cloth", amount: 2 },
        { key: "pitch", amount: 1 },
      ],
      output: { key: "wagonCondition", amount: 6 },
      hoursCost: 1.5,
      skillTag: "crafting",
      desc: "Seal tears to keep stores dry.",
      icon: "WC",
    },
    {
      id: "extra_ammo",
      name: "Hand-load ammo",
      pattern: "100010100",
      inputs: [
        { key: "lead", amount: 2 },
        { key: "powder", amount: 1 },
      ],
      output: { key: "ammo", amount: 4 },
      hoursCost: 1.5,
      skillTag: "crafting",
      desc: "Cast bullets and paper cartridges.",
      icon: "AM",
    },
    {
      id: "herbal_tonic",
      name: "Herbal tonic",
      pattern: "001111000",
      inputs: [
        { key: "water", amount: 1 },
        { key: "herbs", amount: 1 },
      ],
      output: { key: "medicine", amount: 1 },
      hoursCost: 1,
      skillTag: "doctoring",
      desc: "Brew a mild fever tonic.",
      icon: "HT",
    },
  ];

  /* ========= STATE ========================================================= */

  const dom = {};

  let PERSON_ID_COUNTER = 1;

  const gameState = {
    phase: "start",
    leader: null,
    companions: [],
    selectedIndex: 0, // 0 = leader
    supplies: {},
    money: 0,
    startingMoney: 0,
    date: new Date(1848, 3, 15, 16, 0, 0),
    milesTraveled: 0,
    targetMiles: 2050,
    pace: "steady",
    rations: "filling",
    mode: "camp", // "travel" or "camp"
    weather: "Mild",
    weatherState: null,
    weatherSeed: null,
    weatherSystem: null,
    weatherHistory: [],
    recentRainHours: 0,
    locationName: "Independence",
    region: "plains",
    wagonCondition: 100,
    guardLevel: 0,
    log: [],
    lastHourMiles: 0,
    seasonStart: "late_april",
    startProfileId: "late_april",
    startProfile: null,
    startDayOfYear: null,
    highRiverRisk: false,
    partyId: null,
    mapListVisible: false,
    dayRhythm: null,
    lastDayRhythmBonus: 0,
    nutritionHistory: [],
    currentNutrition: null,
    nutritionStatus: null,
    travelView: "journal",
    traillines: {
      visualMiles: 0,
      laneOffset: 0,
      fogMaxMile: 0,
      lastFrameTime: null,
    },
    storyState: null,
    storytellerPresetId: "classic",
  };

  function defaultTraillinesState() {
    return {
      visualMiles: gameState.milesTraveled || 0,
      laneOffset: 0,
      fogMaxMile: gameState.milesTraveled || 0,
      lastFrameTime: null,
    };
  }

  function ensureTraillinesState() {
    if (!gameState.travelView) {
      gameState.travelView = "journal";
    }
    if (!gameState.traillines) {
      gameState.traillines = defaultTraillinesState();
    } else {
      gameState.traillines.visualMiles =
        typeof gameState.traillines.visualMiles === "number"
          ? gameState.traillines.visualMiles
          : gameState.milesTraveled || 0;
      if (typeof gameState.traillines.laneOffset !== "number") {
        gameState.traillines.laneOffset = 0;
      }
      if (typeof gameState.traillines.fogMaxMile !== "number") {
        gameState.traillines.fogMaxMile = gameState.milesTraveled || 0;
      }
      if (!gameState.traillines.lastFrameTime) {
        gameState.traillines.lastFrameTime = null;
      }
    }
  }

  function ensureStoryState() {
    if (!gameState.storyState) {
      gameState.storyState = {
        tension: 12,
        hoursSinceMajorEvent: 0,
        hoursSinceMinorEvent: 0,
        eventFlags: {},
        risk: {},
        riskDurations: {},
        cascadeLog: [],
        presetId: gameState.storytellerPresetId || "classic",
      };
    }
    const ss = gameState.storyState;
    if (typeof ss.tension !== "number") ss.tension = 12;
    if (typeof ss.hoursSinceMajorEvent !== "number") ss.hoursSinceMajorEvent = 0;
    if (typeof ss.hoursSinceMinorEvent !== "number") ss.hoursSinceMinorEvent = 0;
    if (!ss.eventFlags) ss.eventFlags = {};
    if (!ss.risk) ss.risk = {};
    if (!ss.riskDurations) ss.riskDurations = {};
    if (!Array.isArray(ss.cascadeLog)) ss.cascadeLog = [];
    if (!ss.presetId) ss.presetId = gameState.storytellerPresetId || "classic";
    return ss;
  }

  const STORYTELLER_PRESETS = {
    gentle: {
      id: "gentle",
      label: "Calm Narrator",
      description:
        "Emphasizes breathers and lifelines; brutal cascades are rarer and shorter.",
      hint: "Gentler swings, more hope.",
      tensionBaseDrift: 0.03,
      tensionRiskScale: 0.2,
      tensionAfterMajorDrop: 30,
      tensionAfterMinorDrop: 15,
      minHoursBetweenMajor: 32,
      minHoursBetweenMinor: 7,
      breatherBias: 1.45,
      lifelineBias: 1.35,
    },
    classic: {
      id: "classic",
      label: "Classic Trail",
      description:
        "Balanced hardships and breathers with the familiar Oregon Trail rhythm.",
      hint: "Balanced tension and drama.",
      tensionBaseDrift: 0.06,
      tensionRiskScale: 0.25,
      tensionAfterMajorDrop: 35,
      tensionAfterMinorDrop: 18,
      minHoursBetweenMajor: 24,
      minHoursBetweenMinor: 4,
      breatherBias: 1.0,
      lifelineBias: 1.0,
    },
    harsh: {
      id: "harsh",
      label: "Harsh Frontier",
      description:
        "Pushes risk flags harder with shorter breathers and sharper cascades.",
      hint: "Unforgiving, for experienced players.",
      tensionBaseDrift: 0.1,
      tensionRiskScale: 0.38,
      tensionAfterMajorDrop: 46,
      tensionAfterMinorDrop: 22,
      minHoursBetweenMajor: 19,
      minHoursBetweenMinor: 3,
      breatherBias: 0.68,
      lifelineBias: 0.7,
    },
  };

  /* ========= UTILITIES ===================================================== */

  function clamp(v, min, max) {
    return v < min ? min : v > max ? max : v;
  }

  function randFloat(min, max) {
    return min + Math.random() * (max - min);
  }

  function randInt(min, max) {
    return Math.floor(randFloat(min, max + 1));
  }

  function adjustPersonStat(person, key, delta) {
    if (!person || typeof delta !== "number") return;
    const current = typeof person[key] === "number" ? person[key] : 0;
    person[key] = clamp(current + delta, 0, 100);
  }

  function choice(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function ensureAfflictions(person) {
    if (!person.afflictions) person.afflictions = [];
    return person.afflictions;
  }

  function ensurePersonStoryFields(person) {
    if (!person) return person;
    if (!person.id) {
      person.id = "p" + PERSON_ID_COUNTER++;
    } else {
      const numeric = parseInt(String(person.id).replace(/\D/g, ""), 10);
      if (!isNaN(numeric)) {
        PERSON_ID_COUNTER = Math.max(PERSON_ID_COUNTER, numeric + 1);
      }
    }
    if (!Array.isArray(person.thoughts)) person.thoughts = [];
    if (!person.moodState) person.moodState = "Upbeat";
    if (typeof person.optimism !== "number") person.optimism = 55;
    if (typeof person.lowMoraleHours !== "number") person.lowMoraleHours = 0;
    if (!person.relationships) person.relationships = {};
    if (!person.traits) person.traits = [];
    if (typeof person.morale !== "number") person.morale = 60;
    if (typeof person.lastBreakHour !== "number") person.lastBreakHour = 0;
    return person;
  }

  function hasAffliction(person, id) {
    if (!person || !person.afflictions) return false;
    return person.afflictions.some(function (a) {
      return a && a.id === id && !a.resolved;
    });
  }

  function hashToInt(str) {
    let h = 1779033703 ^ str.length;
    for (let i = 0; i < str.length; i++) {
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = (h << 13) | (h >>> 19);
    }
    return h >>> 0;
  }

  function mulberry32(a) {
    return function () {
      let t = (a += 0x6d2b79f5);
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function makeNoise3D(seed) {
    const rng = mulberry32(seed || 1);

    const gradients = {};
    function getGradient(ix, iy, iz) {
      const key = ix + "," + iy + "," + iz;
      if (!gradients[key]) {
        const theta = rng() * 2 * Math.PI;
        const phi = Math.acos(2 * rng() - 1);
        gradients[key] = [
          Math.sin(phi) * Math.cos(theta),
          Math.sin(phi) * Math.sin(theta),
          Math.cos(phi),
        ];
      }
      return gradients[key];
    }

    function fade(t) {
      return t * t * t * (t * (t * 6 - 15) + 10);
    }

    function dotGrid(ix, iy, iz, x, y, z) {
      const g = getGradient(ix, iy, iz);
      const dx = x - ix;
      const dy = y - iy;
      const dz = z - iz;
      return dx * g[0] + dy * g[1] + dz * g[2];
    }

    return function (x, y, z) {
      const x0 = Math.floor(x);
      const x1 = x0 + 1;
      const y0 = Math.floor(y);
      const y1 = y0 + 1;
      const z0 = Math.floor(z);
      const z1 = z0 + 1;

      const sx = fade(x - x0);
      const sy = fade(y - y0);
      const sz = fade(z - z0);

      const n000 = dotGrid(x0, y0, z0, x, y, z);
      const n100 = dotGrid(x1, y0, z0, x, y, z);
      const n010 = dotGrid(x0, y1, z0, x, y, z);
      const n110 = dotGrid(x1, y1, z0, x, y, z);
      const n001 = dotGrid(x0, y0, z1, x, y, z);
      const n101 = dotGrid(x1, y0, z1, x, y, z);
      const n011 = dotGrid(x0, y1, z1, x, y, z);
      const n111 = dotGrid(x1, y1, z1, x, y, z);

      const nx00 = lerp(n000, n100, sx);
      const nx10 = lerp(n010, n110, sx);
      const nx01 = lerp(n001, n101, sx);
      const nx11 = lerp(n011, n111, sx);

      const nxy0 = lerp(nx00, nx10, sy);
      const nxy1 = lerp(nx01, nx11, sy);

      const nxyz = lerp(nxy0, nxy1, sz);
      return nxyz; // roughly -1..1
    };
  }

  function formatMoney(n) {
    return "$" + n.toFixed(2);
  }

  function formatDateTime(d) {
    if (!(d instanceof Date)) {
      d = new Date(d);
    }
    if (isNaN(d.getTime())) return "";
    const months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ];
    const month = months[d.getMonth()];
    const day = d.getDate();
    const year = d.getFullYear();
    let hour = d.getHours();
    const mins = d.getMinutes();
    const ampm = hour >= 12 ? "PM" : "AM";
    hour = hour % 12;
    if (hour === 0) hour = 12;
    const mm = mins.toString().padStart(2, "0");
    return month + " " + day + ", " + year + " · " + hour + ":" + mm + " " + ampm;
  }

  function getMonthName(date) {
    if (!(date instanceof Date)) return "";
    const months = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December",
    ];
    return months[date.getMonth()];
  }

  function isNight(date) {
    const h = date.getHours();
    return h < 5 || h >= 21;
  }

  function getScheduleBlock(date) {
    const h = date.getHours();
    if (h >= 5 && h < 11) return "morning";
    if (h >= 11 && h < 15) return "noon";
    if (h >= 15 && h < 21) return "evening";
    return "night";
  }

  function getDayOfYear(date) {
    const start = new Date(date.getFullYear(), 0, 0);
    const diff = date - start;
    const oneDay = 1000 * 60 * 60 * 24;
    return Math.floor(diff / oneDay);
  }

  function getDayKey(date) {
    return (
      date.getFullYear() +
      "-" +
      (date.getMonth() + 1) +
      "-" +
      date.getDate()
    );
  }

  function ensureDayRhythmForDate(date) {
    const key = getDayKey(date);
    if (!gameState.dayRhythm || gameState.dayRhythm.dayKey !== key) {
      // Close out yesterday before starting a new day
      if (gameState.dayRhythm && gameState.dayRhythm.dayKey) {
        finalizeDayRhythm(gameState.dayRhythm);
      }
      gameState.dayRhythm = {
        dayKey: key,
        morningTravelHours: 0,
        noonCampHours: 0,
        noonEventTriggered: false,
        eveningCampChoice: null,
        nightTravelHours: 0,
        nightGuardHours: 0,
        morningSuggestionShown: false,
        noonSuggestionShown: false,
        eveningSuggestionShown: false,
      };
    }
    return gameState.dayRhythm;
  }

  function finalizeDayRhythm(prev) {
    if (!prev) return;

    const m = prev.morningTravelHours || 0;
    const noonCamp = prev.noonCampHours || 0;
    const nightTravel = prev.nightTravelHours || 0;
    const nightGuard = prev.nightGuardHours || 0;
    const campQuality = prev.eveningCampChoice;

    let score = 0;

    // Morning: aiming for roughly 3–5 hours of travel (diary pattern).:contentReference[oaicite:0]{index=0}
    const morningTarget = 4;
    const morningScore =
      1 - Math.min(Math.abs(m - morningTarget) / morningTarget, 1);
    score += morningScore * 0.4;

    // Nooning: breaking at midday to rest and water stock.:contentReference[oaicite:1]{index=1}
    if (noonCamp >= 1) score += 0.2;
    else score -= 0.15;

    // Camp quality
    if (campQuality === "proper") score += 0.2;
    else if (campQuality === "rough") score -= 0.1;
    else score -= 0.05; // never explicitly made camp

    // Night travel
    if (nightTravel <= 1) score += 0.2;
    else score -= 0.15 * Math.min(nightTravel - 1, 2);

    // Night guard
    if (nightGuard >= 1) score += 0.1;
    else score -= 0.1;

    score = clamp(score, -0.6, 0.6);
    const bonus = clamp(score * 0.1, -0.06, 0.06); // ±6% speed effect next day
    gameState.lastDayRhythmBonus = bonus;

    if (score > 0.25) {
      gameState.wagonCondition = clamp(gameState.wagonCondition + 2, 0, 100);
      addLog(
        "Yesterday's routine was well-paced; your stock and wagon seem to travel a little easier today."
      );
    } else if (score < -0.2) {
      gameState.wagonCondition = clamp(gameState.wagonCondition - 3, 0, 100);
      addLog(
        "Yesterday you pushed hard without proper rests. The team starts today stiff and tired."
      );
    }
  }

    // --- Nutrition tracking over a rolling window --------------------------------

  function ensureNutritionForDate(date) {
    const key = getDayKey(date);
    if (!gameState.currentNutrition || gameState.currentNutrition.dayKey !== key) {
      // Close out the previous day, if any
      if (gameState.currentNutrition) {
        if (!gameState.nutritionHistory) gameState.nutritionHistory = [];
        gameState.nutritionHistory.push(gameState.currentNutrition);
        if (gameState.nutritionHistory.length > 30) {
          gameState.nutritionHistory.splice(
            0,
            gameState.nutritionHistory.length - 30
          );
        }
        applyNutritionPenalties();
      }

      gameState.currentNutrition = {
        dayKey: key,
        staples: 0,
        meatFat: 0,
        fruitVeg: 0,
        coffeeTea: 0,
      };
    }
    return gameState.currentNutrition;
  }

  function recordNutrition(group, points) {
    if (!points || points <= 0) return;
    const entry = ensureNutritionForDate(gameState.date);
    if (typeof entry[group] !== "number") entry[group] = 0;
    entry[group] += points;
  }

  function applyNutritionFromFood(itemId, lbsUsed) {
    if (!lbsUsed || lbsUsed <= 0) return;
    const tags = NUTRITION_TAGS[itemId];
    if (!tags) return;
    const entry = ensureNutritionForDate(gameState.date);
    Object.keys(tags).forEach(function (group) {
      const factor = tags[group];
      if (!factor) return;
      if (typeof entry[group] !== "number") entry[group] = 0;
      entry[group] += lbsUsed * factor;
    });
  }

  function applyNutritionPenalties() {
    const hist = gameState.nutritionHistory || [];
    const window = hist.slice(-14); // last ~2 weeks
    const days = window.length;
    if (!days) return;

    const sums = { staples: 0, meatFat: 0, fruitVeg: 0, coffeeTea: 0 };
    window.forEach(function (d) {
      if (!d) return;
      sums.staples += d.staples || 0;
      sums.meatFat += d.meatFat || 0;
      sums.fruitVeg += d.fruitVeg || 0;
      sums.coffeeTea += d.coffeeTea || 0;
    });

    const mouths = Math.max(1, mouthsCount());
    const avgStaples = sums.staples / days / mouths;
    const avgMeat   = sums.meatFat  / days / mouths;
    const avgFruit  = sums.fruitVeg / days / mouths;
    const avgCoffee = sums.coffeeTea / days / mouths;

    gameState.nutritionStatus = {
      avgStaples: avgStaples,
      avgMeat: avgMeat,
      avgFruit: avgFruit,
      avgCoffee: avgCoffee,
    };

    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    if (!people.length) return;

    // Fruit/veg deficiency → scurvy‑like problems over time
    if (avgFruit < 0.4) {
      people.forEach(function (p) {
        p.condition = clamp(p.condition - 1.5, 0, 100);
        p.energy    = clamp(p.energy    - 1,   0, 100);
        p.morale    = clamp(p.morale    - 1,   0, 100);
      });
      if (Math.random() < 0.25) {
        addLog(
          "Lack of fresh greens or fruit is showing: gums are tender and cuts heal slowly."
        );
      }
    }
    if (avgFruit < 0.2) {
      people.forEach(function (p) {
        p.condition = clamp(p.condition - 2, 0, 100);
      });
      if (Math.random() < 0.2) {
        addLog(
          "Several in the party show bleeding gums and aching legs—signs of camp fever from months on preserved rations."
        );
      }
    }

    // Low meat/fat → chronic fatigue
    if (avgMeat < 0.35) {
      people.forEach(function (p) {
        p.energy = clamp(p.energy - 2, 0, 100);
      });
      if (Math.random() < 0.25) {
        addLog(
          "With little meat or fat, everyone feels hollow and slow to regain their strength."
        );
      }
    }

    // Little coffee/tea → morale sag
    if (avgCoffee < 0.25) {
      people.forEach(function (p) {
        p.morale = clamp(p.morale - 1, 0, 100);
      });
      if (Math.random() < 0.2) {
        addLog(
          "There has been no coffee or tea for days; nerves fray and tempers are short around the fire."
        );
      }
    }
  }


  function triggerNoonRestEvent() {
    const people = getAllPeople();
    if (!people.length) return;
    people.forEach(function (p) {
      if (!p || !p.alive) return;
      p.energy = clamp(p.energy + 3, 0, 110);
      p.morale = clamp(p.morale + 1, 0, 100);
    });
    gameState.wagonCondition = clamp(gameState.wagonCondition + 1, 0, 100);
    addLog(
      "You make a noon halt: animals are watered and graze while everyone eats cold fare and tightens yokes and harness."
    );
  }

  function updateDayRhythmForCurrentHour(milesThisHour) {
    const dr = gameState.dayRhythm;
    if (!dr) return;

    const block = getScheduleBlock(gameState.date);
    const hour = gameState.date.getHours();

    // Morning suggestion: get moving in the cool hours.
    if (
      block === "morning" &&
      !dr.morningSuggestionShown &&
      hour >= 5 &&
      hour < 9
    ) {
      addLog(
        "At first light the camp stirs—stock rounded up and yokes checked. Most trains try to make several miles in the cool morning hours."
      );
      dr.morningSuggestionShown = true;
    }

    if (
      block === "morning" &&
      milesThisHour > 0.01 &&
      gameState.mode === "travel"
    ) {
      dr.morningTravelHours += 1;
    }

    // Nooning: bonus if you actually stop at midday.
    if (block === "noon") {
      if (gameState.mode === "camp") {
        dr.noonCampHours += 1;
        if (!dr.noonEventTriggered) {
          triggerNoonRestEvent();
          dr.noonEventTriggered = true;
        }
      } else if (!dr.noonSuggestionShown) {
        addLog(
          "Midday heat builds. Most trains halt to 'noon'—rest the stock, eat a cold lunch, and check the wagons."
        );
        dr.noonSuggestionShown = true;
      }
    }

    // Evening suggestion: look for camp.
    if (block === "evening" && !dr.eveningSuggestionShown) {
      if (gameState.mode === "travel") {
        addLog(
          "Evening comes on. This is when most emigrants look for grass, water, and fuel and make a careful camp for the night."
        );
      }
      dr.eveningSuggestionShown = true;
    }

    // Night travel & guard tracking
    if (block === "night") {
      if (milesThisHour > 0.01 && gameState.mode === "travel") {
        dr.nightTravelHours += 1;
      }
      if (gameState.mode === "camp" && gameState.guardLevel >= 1) {
        dr.nightGuardHours += 1;
      }
    }
  }

  function applyCampQualityEffects(context) {
    if (!context || !context.campQuality) return;
    const quality = context.campQuality;
    const block = getScheduleBlock(gameState.date);
    if (gameState.mode !== "camp") return;
    if (block !== "evening" && block !== "night") return;

    const people = getAllPeople();
    const ss = ensureStoryState();
    if (quality === "proper") {
      // Proper camp: small comfort & rest boost
      people.forEach(function (p) {
        if (!p || !p.alive) return;
        p.energy = clamp(p.energy + 1.2, 0, 110);
        p.morale = clamp(p.morale + 1.2, 0, 100);
        p.warmth = clamp(p.warmth + 0.8, 0, 100);
        addThought(p, {
          id: "camp_rest",
          label: "Rested by the fire",
          value: 5,
          hoursLeft: 12,
          source: "camp",
        });
      });
      ss.eventFlags.rushedCampChain = 0;
    } else if (quality === "rough") {
      // Rushed camp: more ragged
      people.forEach(function (p) {
        if (!p || !p.alive) return;
        p.energy = clamp(p.energy - 0.8, 0, 100);
        p.warmth = clamp(p.warmth - 0.8, 0, 100);
      });
      ss.eventFlags.rushedCampChain = (ss.eventFlags.rushedCampChain || 0) + 1;
      if (ss.eventFlags.rushedCampChain > 1) {
        people.forEach(function (p) {
          addThought(p, {
            id: "rough_camp_chain",
            label: "Rushed camps",
            value: -3,
            hoursLeft: 8,
            source: "camp",
          });
        });
      }
    }
  }

  function tempCtoF(c) {
    return Math.round((c * 9) / 5 + 32);
  }

  function regionAltitude(region) {
    switch (region) {
      case "plains":
      case "GreatPlains":
        return 300;
      case "central_plains":
        return 500;
      case "high_plains":
      case "HighPlains":
        return 1200;
      case "mountains":
      case "Rockies":
        return 2100;
      case "snake_plain":
      case "SnakePlain":
        return 1500;
      case "blue_mountains":
        return 1700;
      case "columbia":
      case "Columbia":
        return 400;
      case "willamette":
        return 150;
      default:
        return 400;
    }
  }

  function describeWeatherLabel(tempC, precip, storm, clouds) {
    let label = "";
    if (precip === "snow") {
      if (storm) label = "Snowstorm";
      else if (tempC <= -10) label = "Bitter snow";
      else label = "Light snow";
    } else if (precip === "rain") {
      if (storm) label = "Thunderstorms";
      else if (clouds > 0.7) label = "Steady rain";
      else label = "Showers";
    } else {
      if (tempC <= -5) label = "Bitter cold";
      else if (tempC <= 0) label = "Frosty";
      else if (tempC < 8) label = "Chilly";
      else if (tempC < 16) label = "Cool";
      else if (tempC < 24) label = "Mild";
      else if (tempC < 30) label = "Warm";
      else label = "Scorching heat";

      if (precip === "none") {
        if (clouds > 0.7) label = "Overcast " + label.toLowerCase();
        else if (clouds < 0.25) label = "Clear " + label.toLowerCase();
      }
    }
    return label;
  }

  function formatWeatherSummary(w) {
    if (!w) return "Unknown";
    const parts = [];
    if (typeof w.tempC === "number") parts.push(tempCtoF(w.tempC) + "°F");
    if (w.precip && w.precip !== "none") parts.push(w.precip === "snow" ? "snow" : "rain");
    else parts.push("dry");
    if (w.storm) parts.push("storm");
    if (typeof w.windKph === "number") parts.push("wind " + w.windKph + " km/h");
    return parts.join(", ");
  }

  function describeWeatherFlavor(region, weather) {
    if (!weather) return "";
    const hot = weather.tempC >= 30;
    const cold = weather.tempC <= -2;
    const cloudy = weather.clouds >= 0.6;
    if (weather.storm && region === "GreatPlains") {
      return "Black anvil clouds boil over the prairie; lightning flickers on the horizon.";
    }
    if (weather.storm && region === "SnakePlain") {
      return "Heat lightning pulses above distant buttes while dust devils tear across the plain.";
    }
    if (hot && region === "SnakePlain") {
      return "Heat shimmer and dust haze blur the Snake River plain.";
    }
    if (cold && region === "Rockies") {
      return "Thin mountain air bites at fingers and cheeks; snow lingers in the shadows.";
    }
    if (cloudy && region === "Columbia") {
      return "Low gray clouds hang over the gorge, the air damp with river spray.";
    }
    if (cloudy) {
      return "High clouds veil the sun, softening the light on the trail ahead.";
    }
    return "The sky feels vast and clear, wagon tracks stretching toward the horizon.";
  }

  function describeSeasonRisk(region, date, profile) {
    if (!date) return "";
    const month = date.getMonth();
    const lateSeason = month >= 8; // September or later
    if (!profile) {
      profile = START_PROFILES[gameState.startProfileId];
    }
    if (
      profile &&
      profile.riverHazard === "high" &&
      (region === "GreatPlains" || region === "HighPlains") &&
      gameState.highRiverRisk
    ) {
      return "High water from spring runoff makes crossings treacherous.";
    }
    if (
      profile &&
      profile.heatHazard === "high" &&
      (region === "GreatPlains" || region === "SnakePlain") &&
      month >= 5 &&
      month <= 7
    ) {
      return "Heat and dust grind at the stock; keep water and rest in mind.";
    }
    if (
      profile &&
      profile.lateSeasonRisk === "high" &&
      lateSeason &&
      (region === "Rockies" || region === "Columbia")
    ) {
      return "Snow threatens early on the passes; you are running late for the season.";
    }
    return "";
  }

  function getAllPeople() {
    const arr = [];
    if (gameState.leader) {
      ensurePersonStoryFields(gameState.leader);
      arr.push(gameState.leader);
    }
    if (gameState.companions && gameState.companions.length) {
      gameState.companions.forEach(function (p) {
        if (p) {
          ensurePersonStoryFields(p);
          arr.push(p);
        }
      });
    }
    return arr;
  }

  function addAffliction(person, afflictionId, opts) {
    const def = AFFLICTION_DEFS[afflictionId];
    if (!person || !def) return null;
    ensureAfflictions(person);

    const existing = person.afflictions.find(function (a) {
      return a.id === afflictionId && !a.resolved;
    });
    if (existing) {
      existing.severity = Math.max(
        existing.severity || 1,
        (opts && typeof opts.severity === "number" ? opts.severity : 1) || 1
      );
      return existing;
    }

    const rng =
      (gameState.weatherSystem && gameState.weatherSystem.rng) || Math.random;
    function pickRange(range) {
      const min = range[0];
      const max = range[1];
      return min + (max - min) * rng();
    }

    const severity =
      opts && typeof opts.severity === "number"
        ? opts.severity
        : Math.round(pickRange(def.severityRange));

    const incubation = pickRange(def.baseHoursIncubation);
    const acute = pickRange(def.baseHoursAcute);
    const recoveryBuffer = 24 + severity * 12 + rng() * 18;

    const aff = {
      id: def.id,
      label: def.label,
      type: def.type,
      stage: "incubation",
      severity: severity,
      hoursActive: 0,
      hoursIncubation: incubation,
      hoursAcute: acute,
      recoveryBuffer: recoveryBuffer,
      cause: def.cause,
      startedAt: new Date(gameState.date.getTime()),
      resolved: false,
      reliefHours: 0,
      lastNotified: 0,
    };

    person.afflictions.push(aff);

    const onsetText =
      def.id === "sprain"
        ? person.name +
          " favors an injured ankle and knows it will be painful to walk for a while."
        :
          person.name +
          " doesn’t feel quite right: stomach cramps and unease set in.";
    addLog(onsetText);
    return aff;
  }

  function getBestDoctor() {
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    if (!people.length) return null;
    return people.reduce(function (best, p) {
      const skill = p.skills && p.skills.doctoring ? p.skills.doctoring : 0;
      if (!best) return p;
      const bestSkill =
        best.skills && best.skills.doctoring ? best.skills.doctoring : 0;
      return skill > bestSkill ? p : best;
    }, null);
  }

  function activeAfflictions(person) {
    if (!person || !person.afflictions) return [];
    return person.afflictions.filter(function (a) {
      return a && !a.resolved;
    });
  }

  function ensurePersonDelegationFields(person) {
    if (!person) return;
    if (!person.priorities) {
      person.priorities = {};
    }
    if (!person.skillXP) {
      person.skillXP = {
        travel: 0,
        hunting: 0,
        cooking: 0,
        woodcutting: 0,
        doctoring: 0,
      };
    }
    ["travel", "hunting", "cooking", "woodcutting", "doctoring"].forEach(function (k) {
      if (typeof person.skillXP[k] !== "number") {
        person.skillXP[k] = 0;
      }
    });
  }

  function skillIdLabel(id) {
    if (id === "travel") return "trailcraft";
    if (id === "hunting") return "hunting";
    if (id === "cooking") return "cooking";
    if (id === "woodcutting") return "woodcraft";
    if (id === "doctoring") return "doctoring";
    return id;
  }

  function gainSkillXP(person, skillId, amount) {
    if (!person || !skillId) return;
    ensurePersonDelegationFields(person);
    const skills = person.skills || {};
    let level = typeof skills[skillId] === "number" ? skills[skillId] : 0;
    let xp = person.skillXP[skillId] || 0;
    xp += amount || 1;
    let leveled = false;
    while (level < 5) {
      const needed = 12 + level * 10;
      if (xp < needed) break;
      xp -= needed;
      level += 1;
      leveled = true;
      addLog(
        person.name +
          "'s " +
          skillIdLabel(skillId) +
          " improves from hard use."
      );
    }
    person.skillXP[skillId] = xp;
    skills[skillId] = level;
    person.skills = skills;
  }

  function initializePartyPriorities() {
    const people = getAllPeople();
    if (!people.length) return;
    JOB_DEFS.forEach(function (job) {
      const skillId = job.relatedSkill;
      const sorted = people
        .map(function (p) {
          const skills = p.skills || {};
          return {
            person: p,
            skill: typeof skills[skillId] === "number" ? skills[skillId] : 0,
          };
        })
        .sort(function (a, b) {
          return b.skill - a.skill;
        });
      sorted.forEach(function (entry, idx) {
        const p = entry.person;
        ensurePersonDelegationFields(p);
        if (!p.priorities) p.priorities = {};
        let prio = 0;
        const s = entry.skill;
        if (s <= 0) {
          prio = 0;
        } else if (idx === 0) {
          prio = 1;
        } else if (idx === 1) {
          prio = 2;
        } else if (idx === 2) {
          prio = 3;
        } else {
          prio = 4;
        }
        if (job.id === "travel" && p.isLeader) {
          prio = 1;
        }
        p.priorities[job.id] = prio;
      });
    });
  }

  function ensureDelegationState() {
    const people = getAllPeople();
    if (!gameState.companions) gameState.companions = [];
    people.forEach(ensurePersonDelegationFields);
    let hasAny = false;
    people.forEach(function (p) {
      if (!p || !p.priorities) return;
      for (const k in p.priorities) {
        if (p.priorities[k] > 0) {
          hasAny = true;
          break;
        }
      }
    });
    if (!hasAny && people.length) {
      initializePartyPriorities();
    }
  }

  function jobToTaskId(jobId) {
    const def = JOB_DEFS.find(function (j) {
      return j.id === jobId;
    });
    return def ? def.taskId : jobId;
  }

  function resolveTasksForHour() {
    const people = getAllPeople();
    const resolved = [];
    const autoIndices = [];
    const date = gameState.date;
    const block = getScheduleBlock(date);
    const mode = gameState.mode;
    const nightNow = isNight(date);

    const s = gameState.supplies || {};
    const mouths = mouthsCount();
    const waterGal = s.water || 0;
    const cookedMeals =
      (s.meal_simple || 0) +
      (s.meal_hearty || 0) +
      (s.meal_feast || 0) +
      (s.cooked_meals || 0);
    const fuelUnits = (s.firewood || 0) + (s.buffalo_chips || 0);
    const wagonHurt = gameState.wagonCondition < 70;

    const lowWater = waterGal < mouths * 0.4;
    const fewMeals = cookedMeals < mouths * 1.5;
    const essentialJobs = {};

    if (mode === "camp" && nightNow) {
      essentialJobs.guard = true;
    }
    if (mode === "camp" && !nightNow && lowWater) {
      essentialJobs.fetch_water = true;
    }
    if (mode === "camp" && block === "evening" && fewMeals && fuelUnits > 0.1) {
      essentialJobs.cook = true;
    }
    if (wagonHurt && mode === "camp") {
      essentialJobs.repair = true;
    }
    if (mode === "travel") {
      essentialJobs.travel = true;
    }

    people.forEach(function (p, idx) {
      if (!p || !p.alive) {
        resolved[idx] = null;
        return;
      }
      const t = p.task || "travel";
      if (t !== "auto") {
        resolved[idx] = t;
      } else {
        autoIndices.push(idx);
      }
    });

    function assignEssential(jobId) {
      if (!essentialJobs[jobId]) return;
      const taskId = jobToTaskId(jobId);
      for (let i = 0; i < resolved.length; i++) {
        if (resolved[i] === taskId) return;
      }
      let bestIdx = null;
      let bestScore = null;
      autoIndices.forEach(function (idx) {
        const p = people[idx];
        if (!p) return;
        ensurePersonDelegationFields(p);
        const priorities = p.priorities || {};
        const prioVal = typeof priorities[jobId] === "number" ? priorities[jobId] : 0;
        if (prioVal <= 0) return;
        const def = JOB_DEFS.find(function (j) {
          return j.id === jobId;
        });
        const skills = p.skills || {};
        const sVal = def && def.relatedSkill ? (skills[def.relatedSkill] || 0) : 0;
        const score = prioVal * 10 - sVal;
        if (bestIdx === null || score < bestScore) {
          bestIdx = idx;
          bestScore = score;
        }
      });
      if (bestIdx != null) {
        resolved[bestIdx] = taskId;
        const pos = autoIndices.indexOf(bestIdx);
        if (pos >= 0) autoIndices.splice(pos, 1);
      }
    }

    ["guard", "cook", "fetch_water", "repair", "travel"].forEach(assignEssential);

    function chooseScheduledJob(person, jobListPrimary) {
      ensurePersonDelegationFields(person);
      const priorities = person.priorities || {};
      let bestJob = null;
      let bestScore = null;
      function consider(jobId) {
        const prioVal = typeof priorities[jobId] === "number" ? priorities[jobId] : 0;
        if (prioVal <= 0) return;
        const def = JOB_DEFS.find(function (j) {
          return j.id === jobId;
        });
        const skills = person.skills || {};
        const sVal = def && def.relatedSkill ? (skills[def.relatedSkill] || 0) : 0;
        const score = prioVal * 10 - sVal;
        if (bestJob === null || score < bestScore) {
          bestJob = jobId;
          bestScore = score;
        }
      }
      jobListPrimary.forEach(consider);
      if (!bestJob) {
        JOB_DEFS.forEach(function (j) {
          consider(j.id);
        });
      }
      return bestJob ? jobToTaskId(bestJob) : null;
    }

    autoIndices.forEach(function (idx) {
      const p = people[idx];
      if (!p || !p.alive) return;
      let jobList = [];
      if (mode === "travel") {
        if (block === "night") {
          jobList = ["guard", "sleep", "rest"];
        } else {
          jobList = ["travel", "hunt", "scout", "fetch_water", "gather_wood"];
        }
      } else {
        if (block === "morning") {
          jobList = ["cook", "gather_wood", "fetch_water", "repair", "travel"];
        } else if (block === "noon") {
          jobList = ["rest", "cook", "repair", "gather_wood"];
        } else if (block === "evening") {
          jobList = ["cook", "gather_wood", "repair", "guard"];
        } else {
          jobList = ["guard", "sleep", "rest", "cook"];
        }
      }
      const primaryJobs = jobList.filter(function (j) {
        return j !== "rest" && j !== "sleep";
      });
      let taskId = null;
      if (primaryJobs.length) {
        taskId = chooseScheduledJob(p, primaryJobs);
      }
      if (!taskId) {
        if (nightNow && mode !== "travel") taskId = "sleep";
        else taskId = "rest";
      }
      resolved[idx] = taskId || "rest";
    });

    return resolved;
  }

  /* ========= GAME INITIALIZATION ========================================== */

  function initDom() {
    dom.root = document.getElementById("oldtrail-root");
    dom.screens = {
      start: document.getElementById("ot-screen-start"),
      outfit: document.getElementById("ot-screen-outfit"),
      travel: document.getElementById("ot-screen-travel"),
    };
    dom.leaderPill = document.getElementById("ot-leader-pill");
    dom.btnReset = document.getElementById("ot-btn-reset");

    dom.leaderName = document.getElementById("ot-leader-name");
    dom.backgroundSelect = document.getElementById("ot-background");
    dom.backgroundDesc = document.getElementById("ot-background-desc");
    dom.departureSelect = document.getElementById("ot-departure");
    dom.departureSeason = document.getElementById("ot-departure-season");
    dom.departureSeasonDesc = document.getElementById(
      "ot-departure-season-desc"
    );
    dom.storytellerPreset = document.getElementById("ot-storyteller-preset");
    dom.companionInputs = [
      document.getElementById("ot-companion-0"),
      document.getElementById("ot-companion-1"),
      document.getElementById("ot-companion-2"),
      document.getElementById("ot-companion-3"),
    ];
    dom.startArt = document.getElementById("ot-start-art");
    dom.btnBeginOutfit = document.getElementById("ot-btn-begin-outfit");

    dom.outfitIntro = document.getElementById("ot-outfit-intro");
    dom.outfitBody = document.getElementById("ot-outfit-body");
    dom.outfitTable = document.getElementById("ot-outfit-table");
    dom.outfitArt = document.getElementById("ot-outfit-art");
    dom.btnAddRecommended = document.getElementById("ot-btn-add-recommended");
    dom.btnBeginJourney = document.getElementById("ot-btn-begin-journey");
    dom.sumStarting = document.getElementById("ot-sum-starting");
    dom.sumMoney = document.getElementById("ot-sum-money");
    dom.sumLoad = document.getElementById("ot-sum-load");
    dom.sumDraft = document.getElementById("ot-sum-draft");
    dom.sumRatio = document.getElementById("ot-sum-ratio");

    dom.ontrailPace = document.getElementById("ot-ontrail-pace");
    dom.ontrailRations = document.getElementById("ot-ontrail-rations");
    dom.ontrailMode = document.getElementById("ot-ontrail-mode");
    dom.ontrailBlock = document.getElementById("ot-ontrail-block");
    dom.weatherSummary = document.getElementById("ot-weather-summary");
    dom.weatherNote = document.getElementById("ot-weather-note");
    dom.leaderStatus = document.getElementById("ot-leader-status");
    dom.partyManifest = document.getElementById("ot-party-manifest");
    dom.hourTasks = document.getElementById("ot-hour-tasks");
    dom.scene = document.getElementById("ot-scene");
    dom.sceneCaption = document.getElementById("ot-scene-caption");
    dom.trailCanvas = document.getElementById("ot-trail-canvas");
    dom.btnViewJournal = document.getElementById("ot-btn-view-journal");
    dom.btnViewExplorer = document.getElementById("ot-btn-view-explorer");
    dom.trailHeader = document.getElementById("ot-trail-header");
    dom.trailMap = document.getElementById("ot-trail-map");
    dom.mapViewport = document.getElementById("ot-map-viewport");
    dom.btnToggleMapList = document.getElementById("ot-btn-toggle-maplist");
    dom.companionDetail = document.getElementById("ot-companion-detail");
    dom.trailLog = document.getElementById("old-trail-log-widget");
    dom.suppliesOverview = document.getElementById("ot-supplies-overview");
    dom.footerStatus = document.getElementById("ot-footer-status");
    dom.btnAdvance1 = document.getElementById("ot-btn-advance-1");
    dom.btnAdvance4 = document.getElementById("ot-btn-advance-4");
    dom.btnToggleMode = document.getElementById("ot-btn-toggle-mode");
    dom.btnChangePace = document.getElementById("ot-btn-change-pace");
    dom.btnChangeRations = document.getElementById("ot-btn-change-rations");
    dom.btnOpenInventory = document.getElementById("ot-btn-open-inventory");
    dom.btnOpenCamp = document.getElementById("ot-btn-open-camp-tasks");

    dom.inventoryModal = document.getElementById("ot-inventory-modal");
    dom.modalBackdrop = dom.inventoryModal
      ? dom.inventoryModal.querySelector(".ot-modal-backdrop")
      : null;
    dom.inventorySub = document.getElementById("ot-inventory-sub");
    dom.inventoryBody = document.getElementById("ot-inventory-body");
    dom.btnCloseInventory = document.getElementById("ot-btn-close-inventory");

    dom.btnOpenPriorities = document.getElementById("ot-btn-open-priorities");
    dom.prioritiesModal = document.getElementById("ot-priorities-modal");
    dom.prioritiesBackdrop = dom.prioritiesModal
      ? dom.prioritiesModal.querySelector(".ot-modal-backdrop")
      : null;
    dom.prioritiesHeadRow = document.getElementById("ot-priorities-head-row");
    dom.prioritiesBody = document.getElementById("ot-priorities-body");
    dom.prioritiesWarnings = document.getElementById("ot-priorities-warnings");
    dom.btnClosePriorities = document.getElementById("ot-btn-close-priorities");
    dom.btnEveningProperCamp = document.getElementById("ot-btn-evening-proper-camp");
    dom.btnEveningRushedCamp = document.getElementById("ot-btn-evening-rushed-camp");
    dom.campOverlay = document.getElementById("ot-camp-overlay");
    dom.btnCloseCamp = document.getElementById("ot-btn-close-camp");
    dom.btnCampConfirm = document.getElementById("ot-btn-camp-confirm");
    dom.btnCampAuto = document.getElementById("ot-btn-camp-auto");
    dom.campSummaryNote = document.getElementById("ot-camp-summary-note");
    dom.craftingWidget = document.getElementById("oldtrail-crafting-widget");
    dom.thoughtsBubble = document.getElementById("oldtrail-thoughts-bubble");

    dom.storytellerDesc = document.getElementById("ot-storyteller-desc");
    dom.storytellerMidrun = document.getElementById("ot-storyteller-midrun");
    dom.narratorLabel = document.getElementById("ot-narrator-label");
    dom.narratorPicker = document.getElementById("ot-narrator-picker");
    dom.narratorHint = document.getElementById("ot-narrator-hint");
    dom.btnToggleNarrator = document.getElementById("ot-btn-toggle-narrator");

  }

  function showScreen(name) {
    Object.keys(dom.screens).forEach(function (key) {
      dom.screens[key].classList.remove("ot-screen-active");
    });
    if (dom.screens[name]) {
      dom.screens[name].classList.add("ot-screen-active");
    }
    gameState.phase = name;

    if (name === "travel") {
      setTravelView(gameState.travelView || "journal");
    }
  }

  function resetSupplies() {
    gameState.supplies = {};
    SUPPLY_ITEMS.forEach(function (item) {
      gameState.supplies[item.id] = 0;
    });
  }

  function createPerson(name, isLeader, bias) {
    const base = 100;
    const person = {
      name: name || (isLeader ? "Leader" : "Companion"),
      isLeader: !!isLeader,
      condition: base,
      hunger: 100,
      thirst: 100,
      warmth: 85,
      energy: 95,
      morale: 85,
      moodState: "Upbeat",
      thoughts: [],
      optimism: 58,
      lowMoraleHours: 0,
      relationships: {},
      traits: [],
      id: "p" + PERSON_ID_COUNTER++,
      skills: {
        travel: 1,
        hunting: 1,
        cooking: 1,
        woodcutting: 1,
        doctoring: 1,
      },
      task: "travel",
      alive: true,
      priorities: {},
      skillXP: {
        travel: 0,
        hunting: 0,
        cooking: 0,
        woodcutting: 0,
        doctoring: 0,
      },
      afflictions: [],
      lastBreakHour: 0,
    };
    if (bias) {
      Object.keys(bias).forEach(function (k) {
        person.skills[k] = clamp(person.skills[k] + bias[k], 0, 5);
      });
    }
    return person;
  }

  function pickStartDateFromSeason() {
    const profileId = dom.departureSeason
      ? dom.departureSeason.value
      : "late_april";
    const profile = START_PROFILES[profileId] || START_PROFILES.late_april;
    gameState.seasonStart = profileId;
    gameState.startProfileId = profileId;
    gameState.startProfile = profile;
    const startDate = new Date(
      1848,
      profile.startMonth,
      profile.startDay,
      16,
      0,
      0
    );
    gameState.startDayOfYear = getDayOfYear(startDate);
    gameState.highRiverRisk = profile.riverHazard === "high";
    return startDate;
  }

  function setRelationship(a, b, opinion, tags) {
    if (!a || !b) return;
    ensurePersonStoryFields(a);
    ensurePersonStoryFields(b);
    if (!a.relationships) a.relationships = {};
    if (!b.relationships) b.relationships = {};
    a.relationships[b.id] = {
      opinion: clamp(typeof opinion === "number" ? opinion : 0, -100, 100),
      tags: tags ? tags.slice() : [],
    };
    b.relationships[a.id] = {
      opinion: clamp(typeof opinion === "number" ? opinion : 0, -100, 100),
      tags: tags ? tags.slice() : [],
    };
  }

  function getRelationship(a, b) {
    if (!a || !b) return null;
    ensurePersonStoryFields(a);
    ensurePersonStoryFields(b);
    if (!a.relationships) a.relationships = {};
    if (!b.relationships) b.relationships = {};
    if (!a.relationships[b.id]) {
      a.relationships[b.id] = { opinion: 0, tags: [] };
    }
    if (!b.relationships[a.id]) {
      b.relationships[a.id] = { opinion: 0, tags: [] };
    }
    return a.relationships[b.id];
  }

  function adjustOpinion(a, b, delta, tag) {
    if (!a || !b || typeof delta !== "number") return;
    const relAB = getRelationship(a, b);
    const relBA = getRelationship(b, a);
    relAB.opinion = clamp((relAB.opinion || 0) + delta, -100, 100);
    relBA.opinion = clamp((relBA.opinion || 0) + delta * 0.8, -100, 100);
    if (tag && relAB.tags.indexOf(tag) < 0) relAB.tags.push(tag);
    if (tag && relBA.tags.indexOf(tag) < 0) relBA.tags.push(tag);
  }

  function seedTraitsAndRelationships() {
    const people = getAllPeople();
    if (!people.length) return;
    people.forEach(ensurePersonStoryFields);

    const companions = gameState.companions || [];
    if (companions.length >= 2) {
      setRelationship(companions[0], companions[1], 55, ["sibling"]);
    } else if (companions.length >= 1) {
      setRelationship(companions[0], gameState.leader, 48, ["fellow_traveler"]);
    }

    if (people[0] && people[0].traits.indexOf("Steady") < 0) {
      people[0].traits.push("Steady");
    }
    if (people[1] && people[1].traits.indexOf("Cheerful") < 0) {
      people[1].traits.push("Cheerful");
    }
    if (people[2] && people[2].traits.indexOf("Argumentative") < 0) {
      people[2].traits.push("Argumentative");
    }
  }

  function renderDepartureSeasonDesc() {
    if (!dom.departureSeasonDesc) return;
    const profileId = dom.departureSeason
      ? dom.departureSeason.value
      : "late_april";
    const profile = START_PROFILES[profileId] || START_PROFILES.late_april;
    dom.departureSeasonDesc.textContent = profile.summary;
  }

  function renderStorytellerOptions(selectEl, selectedId) {
    if (!selectEl) return;
    selectEl.innerHTML = "";
    Object.keys(STORYTELLER_PRESETS).forEach(function (key) {
      const preset = STORYTELLER_PRESETS[key];
      const opt = document.createElement("option");
      opt.value = preset.id;
      opt.textContent =
        preset.label + " – " + (preset.hint || "Narrator mood");
      if (preset.hint) opt.title = preset.hint;
      if (preset.id === selectedId) opt.selected = true;
      selectEl.appendChild(opt);
    });
  }

  function renderStorytellerDescription(presetId) {
    const preset = STORYTELLER_PRESETS[presetId] || STORYTELLER_PRESETS.classic;
    if (dom.storytellerDesc) {
      dom.storytellerDesc.textContent = preset.description || "";
    }
    if (dom.narratorLabel) {
      dom.narratorLabel.textContent = "Narrator: " + preset.label;
      dom.narratorLabel.title = preset.hint || preset.description || "";
    }
    if (dom.narratorHint) {
      dom.narratorHint.textContent = preset.description || "";
    }
  }

  function startNewGameFromForm() {
    const bgId = dom.backgroundSelect.value;
    const bg = BACKGROUNDS[bgId] || BACKGROUNDS.farmer;

    const leaderName = dom.leaderName.value.trim() || "Unnamed leader";
    const leader = createPerson(leaderName, true, bg.skillBias);

    const companions = [];
    dom.companionInputs.forEach(function (input) {
      const v = input.value.trim();
      if (v) companions.push(createPerson(v, false, null));
    });
    if (companions.length === 0) {
      companions.push(createPerson("Unnamed companion", false, null));
    }

    gameState.leader = leader;
    gameState.companions = companions;
    gameState.selectedIndex = 0;

    gameState.leader.task = "travel";
    gameState.companions.forEach(function (c) {
      c.task = "auto";
    });

    seedTraitsAndRelationships();

    const presetId = dom.storytellerPreset
      ? dom.storytellerPreset.value
      : "classic";
    gameState.storytellerPresetId = presetId;

    gameState.startingMoney = bg.startingMoney;
    gameState.money = bg.startingMoney;
    resetSupplies();

    gameState.date = pickStartDateFromSeason();
    const partyKey =
      (leaderName + "-" + dom.departureSelect.value + "-" + gameState.startProfileId)
        .replace(/\s+/g, "-")
        .toLowerCase();
    gameState.partyId = partyKey;
    gameState.weatherSeed = hashToInt(partyKey + "-" + gameState.date.getFullYear());
    initWeatherSystem(gameState.date.getFullYear(), partyKey);
    gameState.weatherHistory = [];
    gameState.milesTraveled = 0;
    gameState.pace = "steady";
    gameState.rations = "filling";
    gameState.mode = "camp";
    gameState.wagonCondition = 100;
    gameState.guardLevel = 0;
    gameState.log = [];
    gameState.recentRainHours = 0;
    gameState.mapListVisible = false;
    gameState.travelView = "journal";
    gameState.traillines = defaultTraillinesState();

    updateRegionAndLocation();
    refreshWeather();
    addLog(
      "You make camp near the Missouri River and begin preparing your wagon."
    );

    dom.leaderPill.textContent =
      "Leader  " + bg.label.replace("from", "from");

    updateStartArt();
    buildOutfitTable();
    updateOutfitSummary();
    updateOutfitIntro();
    updateOutfitArt();

    ensureDelegationState();
    showScreen("outfit");
    saveGame();
    renderAll();
  }

  /* ========= REGION, WEATHER, LOG ========================================= */

  function regionToWeatherRegion(region) {
    switch (region) {
      case "plains":
      case "central_plains":
        return "GreatPlains";
      case "high_plains":
        return "HighPlains";
      case "mountains":
        return "Rockies";
      case "snake_plain":
        return "SnakePlain";
      case "blue_mountains":
        return "Rockies";
      case "columbia":
      case "willamette":
        return "Columbia";
      default:
        return "GreatPlains";
    }
  }

  function initWeatherSystem(year, partyId) {
    const baseSeed =
      gameState.weatherSeed || hashToInt(`${year || 1848}-${partyId || "party"}`);
    gameState.weatherSeed = baseSeed;
    gameState.weatherSystem = {
      seed: baseSeed,
      rng: mulberry32(baseSeed),
      noise: makeNoise3D(baseSeed),
    };
    if (!Array.isArray(gameState.weatherHistory)) {
      gameState.weatherHistory = [];
    }
  }

  function ensureWeatherRuntime() {
    if (!gameState.weatherSystem || !gameState.weatherSystem.seed) {
      const year = gameState.date ? gameState.date.getFullYear() : 1848;
      initWeatherSystem(year, gameState.partyId || "party");
    }
    if (!gameState.weatherSystem.rng) {
      const seed = gameState.weatherSystem.seed || gameState.weatherSeed || 1;
      gameState.weatherSystem.rng = mulberry32(seed);
    }
    if (!gameState.weatherSystem.noise) {
      const seed = gameState.weatherSystem.seed || gameState.weatherSeed || 1;
      gameState.weatherSystem.noise = makeNoise3D(seed);
    }
  }

  function getClimateBaseline(regionKey, monthName) {
    const monthly = CLIMATE[regionKey] && CLIMATE[regionKey].monthly;
    if (monthly && monthly[monthName]) return monthly[monthName];
    if (monthly) {
      const first = Object.keys(monthly)[0];
      if (first) return monthly[first];
    }
    return { pRain: 0.2, pStorm: 0.08, tMin: 4, tMax: 20, windKph: [8, 22] };
  }


  function updateWeatherHistory(weather) {
    if (!Array.isArray(gameState.weatherHistory)) {
      gameState.weatherHistory = [];
    }
    gameState.weatherHistory.push({
      ...weather,
      loggedAt: new Date(gameState.date.getTime()),
    });
    const maxLen = 48;
    if (gameState.weatherHistory.length > maxLen) {
      gameState.weatherHistory.splice(0, gameState.weatherHistory.length - maxLen);
    }
  }

  function getWeather(state) {
    ensureWeatherRuntime();
    const ws = gameState.weatherSystem || {};
    const noise3 = ws.noise || ((x, y, t) => 0);
    const rng = ws.rng || Math.random;
    const climate = getClimateBaseline(state.region, state.month);
    const tScale = (state.dayOfYear + state.hour / 24) * 0.05;
    const sx = (state.x || 0) * 0.005;
    const sy = (state.y || 0) * 0.003;

    const profile =
      gameState.startProfile || START_PROFILES[gameState.startProfileId];

    const tempNoise = noise3(sx, sy, tScale);
    const diurnal = Math.cos(((state.hour - 15) / 24) * 2 * Math.PI) * 5.2;
    let tempC =
      lerp(climate.tMin, climate.tMax, 0.5 + 0.35 * tempNoise) + diurnal;
    tempC -= 0.006 * (state.altitude || 0);
    if (profile) {
      if (profile.heatHazard === "high") tempC += 2.2;
      else if (profile.heatHazard === "low") tempC -= 1.2;
      if (profile.riverHazard === "high" && state.month === "April") {
        tempC -= 0.8;
      }
    }

    const cloudBase = noise3(sx + 12, sy - 5, tScale * 0.7);
    const frontDrift = noise3(sx + state.dayOfYear * 0.02, sy, tScale * 0.35);
    const clouds = clamp(0.55 + 0.35 * cloudBase + 0.15 * frontDrift, 0, 1);

    let pRain =
      climate.pRain * (0.6 + 0.8 * clouds) * (0.75 + 0.5 * frontDrift);
    let pStorm = climate.pStorm * (0.55 + 0.8 * Math.max(frontDrift, 0));

    if (profile) {
      if (
        profile.riverHazard === "high" &&
        (state.month === "April" || state.month === "May")
      ) {
        pRain *= 1.1;
      }
      if (
        profile.heatHazard === "high" &&
        (state.month === "July" || state.month === "August")
      ) {
        tempC += 1.2;
        pRain *= 0.9;
        pStorm *= 1.15;
      }
    }

    pRain = clamp(pRain, 0, 0.95);
    pStorm = clamp(pStorm, 0, 0.65);

    const precipHit = rng() < pRain;
    const stormHit = precipHit && rng() < pStorm;
    let precip = "none";
    if (precipHit) {
      const isSnow = tempC <= 1 || (state.altitude || 0) >= 1900;
      precip = isSnow ? "snow" : "rain";
    }

    const windSample = noise3(sx + 5, sy - 7, tScale * 1.3);
    let windKph = lerp(
      climate.windKph[0],
      climate.windKph[1],
      0.5 + 0.35 * windSample
    );
    if (stormHit) windKph += 6;

    return {
      tempC: Math.round(tempC * 10) / 10,
      windKph: Math.round(windKph),
      clouds: clouds,
      precip: precip,
      storm: !!stormHit,
    };
  }

  function applyWeatherToParty(party, weather, history) {
    // TODO: Hook future survival effects here (speed, illness, morale, river depth).
    if (!weather) return;
    const recent = history && history[history.length - 1];
    if (!recent) return;
    if (weather.storm && Math.random() < 0.05) {
      addLog("Storm gusts batter the wagon covers and everyone hunches against the rain.");
    }
    if (weather.tempC >= 32 && Math.random() < 0.04) {
      addLog("The heat and dust leave the oxen lathered and thirsty.");
    }
    if (weather.tempC <= -5 && Math.random() < 0.03) {
      addLog("Biting cold makes the party huddle close to share warmth.");
    }
  }

  function refreshWeather() {
    ensureWeatherRuntime();
    const d = gameState.date;
    const doy = getDayOfYear(d);
    const hour = d.getHours() + d.getMinutes() / 60;
    const weatherRegion = regionToWeatherRegion(gameState.region || "plains");
    const altitude = regionAltitude(gameState.region || weatherRegion);
    const monthName = getMonthName(d) || "April";

    const weather = getWeather({
      x: gameState.milesTraveled || 0,
      y: altitude || 0,
      dayOfYear: doy,
      hour: hour,
      region: weatherRegion,
      month: monthName,
      altitude: altitude,
    });

    if (!gameState.recentRainHours) gameState.recentRainHours = 0;
    if (weather.precip === "rain" || weather.precip === "snow") {
      gameState.recentRainHours = Math.min(72, gameState.recentRainHours + 1);
    } else {
      gameState.recentRainHours = Math.max(0, gameState.recentRainHours - 0.5);
    }

    gameState.weatherState = weather;
    gameState.weather = describeWeatherLabel(
      weather.tempC,
      weather.precip,
      weather.storm,
      weather.clouds
    );

    const daysSinceStart =
      gameState.startDayOfYear != null
        ? Math.max(0, doy - gameState.startDayOfYear)
        : 0;
    const plainsPhase =
      gameState.region === "plains" || gameState.region === "central_plains";
    const profile =
      gameState.startProfile || START_PROFILES[gameState.startProfileId];
    gameState.highRiverRisk =
      profile && profile.riverHazard === "high" && plainsPhase && daysSinceStart < 45;

    updateWeatherHistory(weather);
    applyWeatherToParty(getAllPeople(), weather, gameState.weatherHistory);
  }

  function updateRegionAndLocation() {
    const miles = gameState.milesTraveled;
    let last = ROUTE_MILESTONES[0];
    ROUTE_MILESTONES.forEach(function (m) {
      if (miles >= m.mile) last = m;
    });
    gameState.locationName = last.name;
    gameState.region = last.region;
  }

  function addLog(text, meta) {
    const opts = meta || {};
    const entry = {
      date: new Date(gameState.date.getTime()),
      text: text,
      tone: opts.tone,
      tag: opts.tag,
      location: opts.location,
      characters: opts.characters || [],
    };
    gameState.log.push(entry);
    if (gameState.log.length > 120) {
      gameState.log.splice(0, gameState.log.length - 120);
    }

    if (window.ksOldTrailLog && ksOldTrailLog.add) {
      const dayTag =
        gameState.startDayOfYear != null
          ? Math.max(1, getDayOfYear(gameState.date) - gameState.startDayOfYear + 1)
          : getDayOfYear(gameState.date);
      ksOldTrailLog.add(text, {
        tag: opts.tag || "DAY " + dayTag,
        location: opts.location || gameState.locationName || "On the trail",
        tone: opts.tone,
        day: dayTag,
        characters: opts.characters,
      });
    }
  }

  function addThought(person, cfg) {
    if (!person || !cfg) return;
    ensurePersonStoryFields(person);
    const id = cfg.id || "thought_" + Date.now();
    const value = clamp(cfg.value || 0, -20, 20);
    const hoursLeft = cfg.hoursLeft != null ? cfg.hoursLeft : 8;
    const existing = person.thoughts.find(function (t) {
      return t && t.id === id;
    });
    if (existing) {
      existing.hoursLeft = Math.max(existing.hoursLeft || 0, hoursLeft);
      existing.value = value;
      existing.source = cfg.source || existing.source;
      existing.label = cfg.label || existing.label;
    } else {
      person.thoughts.push({
        id: id,
        label: cfg.label || id,
        value: value,
        hoursLeft: hoursLeft,
        source: cfg.source || "",
      });
    }
  }

  /* ========= OUTFITTING LOGIC ============================================= */

  const outfitDom = {
    inputs: {},
    totals: {},
  };

  function buildOutfitTable() {
    dom.outfitBody.innerHTML = "";
    outfitDom.inputs = {};
    outfitDom.totals = {};

    SUPPLY_ITEMS.forEach(function (item) {
      const tr = document.createElement("tr");

      const tdName = document.createElement("td");
      tdName.textContent = item.name;
      tr.appendChild(tdName);

      const tdQty = document.createElement("td");
      if (item.readOnly) {
        tdQty.textContent = "—";
      } else {
        const input = document.createElement("input");
        input.type = "number";
        input.min = "0";
        input.step = "1";
        input.className = "ot-outfit-qty";
        input.value = gameState.supplies[item.id] || 0;
        input.addEventListener("change", function () {
          const val = parseFloat(input.value) || 0;
          gameState.supplies[item.id] = Math.max(0, val);
          updateOutfitSummary();
          saveGame();
        });
        outfitDom.inputs[item.id] = input;
        tdQty.appendChild(input);
      }
      tr.appendChild(tdQty);

      const tdUnit = document.createElement("td");
      tdUnit.textContent = item.unit;
      tr.appendChild(tdUnit);

      const tdCost = document.createElement("td");
      tdCost.textContent = "$" + item.cost.toFixed(2);
      tr.appendChild(tdCost);

      const tdSubtotal = document.createElement("td");
      tdSubtotal.textContent = "$0.00";
      outfitDom.totals[item.id] = tdSubtotal;
      tr.appendChild(tdSubtotal);

      dom.outfitBody.appendChild(tr);
    });
  }

  function computeTotalWeight() {
    let total = 0;
    SUPPLY_ITEMS.forEach(function (item) {
      const qty = gameState.supplies[item.id] || 0;
      total += qty * item.weight;
    });
    return total;
  }

  function computeDraftPower() {
    const oxen = gameState.supplies.oxen || 0;
    const cows = gameState.supplies.milk_cows || 0;
    return oxen * 650 + cows * 300;
  }

  function updateOutfitSummary() {
    let spent = 0;
    SUPPLY_ITEMS.forEach(function (item) {
      const qty = gameState.supplies[item.id] || 0;
      const subtotal = item.cost * qty;
      spent += subtotal;
      if (outfitDom.totals[item.id]) {
        outfitDom.totals[item.id].textContent = formatMoney(subtotal);
      }
    });

    gameState.money = gameState.startingMoney - spent;
    dom.sumStarting.textContent = formatMoney(gameState.startingMoney);
    dom.sumMoney.textContent = formatMoney(gameState.money);
    dom.sumMoney.classList.toggle("ot-text-warning", gameState.money < 0.01);

    const totalWeight = computeTotalWeight();
    const draft = computeDraftPower();

    dom.sumLoad.textContent = Math.round(totalWeight) + " lb";
    if (draft > 0) {
      dom.sumDraft.textContent = Math.round(draft) + " lb pull";
      const ratio = totalWeight / draft;
      const pct = Math.round(ratio * 100);
      dom.sumRatio.textContent = pct + "%";
      dom.sumRatio.classList.toggle("ot-text-warning", ratio > 0.9);
    } else {
      dom.sumDraft.textContent = "No draft animals";
      dom.sumRatio.textContent = "—";
      dom.sumRatio.classList.add("ot-text-warning");
    }

    const okToDepart = gameState.money >= 0 && draft > 0 && totalWeight > 0;
    dom.btnBeginJourney.disabled = !okToDepart;
  }

  function addRecommendedLoad() {
    SUPPLY_ITEMS.forEach(function (item) {
      if (item.readOnly) return;
      const target = item.recommended || 0;
      if (target > (gameState.supplies[item.id] || 0)) {
        gameState.supplies[item.id] = target;
        if (outfitDom.inputs[item.id]) {
          outfitDom.inputs[item.id].value = target;
        }
      }
    });
    updateOutfitSummary();
    saveGame();
  }

  function updateOutfitIntro() {
    const mouths = 1 + gameState.companions.length;
    dom.outfitIntro.textContent =
      "You begin with " +
      formatMoney(gameState.startingMoney) +
      " and a party of " +
      mouths +
      ". Outfit them for five to six months on the trail.";
  }

  function updateStartArt() {
    const dep = dom.departureSelect.value;
    let url = IMAGE_URLS.start_screen;
    if (dep === "independence") url = IMAGE_URLS.independence_start_edge;
    else if (dep === "st_joseph") url = IMAGE_URLS.st_joseph_start;
    else if (dep === "council_bluffs") url = IMAGE_URLS.council_bluffs_start;
    dom.startArt.style.backgroundImage =
      "linear-gradient(to top, rgba(0,0,0,.7), rgba(0,0,0,.15)), url('" +
      url +
      "')";
  }

  function updateOutfitArt() {
    dom.outfitArt.style.backgroundImage =
      "linear-gradient(to top, rgba(0,0,0,.7), rgba(0,0,0,.15)), url('" +
      IMAGE_URLS.generalstore_missouri +
      "')";
  }

  function beginJourney() {
    const barrels = gameState.supplies.water_barrels || 0;
    if (!gameState.supplies.water) gameState.supplies.water = 0;
    gameState.supplies.water += barrels * 30;
    addLog("You roll out from " + gameState.locationName + " and head west.");
    showScreen("travel");
    saveGame();
    renderAll();
  }

  /* ========= HOURLY SIMULATION ============================================ */

  function mouthsCount() {
    return (
      (gameState.leader && gameState.leader.alive ? 1 : 0) +
      gameState.companions.filter(function (c) {
        return c.alive;
      }).length
    );
  }

  function computeMilesForHour() {
    if (gameState.mode !== "travel") return 0;
    const paceCfg = PACE_CONFIG[gameState.pace] || PACE_CONFIG.steady;
    const conditionFactor = 0.6 + (gameState.wagonCondition / 100) * 0.6;
    const w = gameState.weatherState || {};
    let weatherFactor = 1;

    if (w.precip === "rain") {
      weatherFactor -= 0.12;
      if (gameState.recentRainHours > 18) weatherFactor -= 0.1;
    } else if (w.precip === "snow") {
      weatherFactor -= 0.2;
    }
    if (w.tempC >= 30) weatherFactor -= 0.08;
    else if (w.tempC >= 24) weatherFactor -= 0.04;
    if (w.tempC >= 10 && w.tempC <= 20 && w.precip === "none") {
      weatherFactor += 0.04;
    }

    weatherFactor = clamp(weatherFactor, 0.4, 1.15);

    const baseMiles = paceCfg.milesPerHour * conditionFactor * weatherFactor;
    const rhythmBonus = gameState.lastDayRhythmBonus || 0;
    let mobilityPenalty = 1;
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    people.forEach(function (p) {
      activeAfflictions(p).forEach(function (aff) {
        if (aff.id === "sprain") {
          if (aff.stage === "acute") mobilityPenalty *= 0.9;
          else if (aff.stage === "recovery") mobilityPenalty *= 0.97;
        }
      });
    });

    const finalMiles = baseMiles * (1 + rhythmBonus) * mobilityPenalty;
    return finalMiles;
  }


  function autoConsumeFor(person) {
    const rationCfg = RATION_CONFIG[gameState.rations] || RATION_CONFIG.filling;
    if (!person.alive) return;

    if (person.hunger < rationCfg.targetHunger) {
      eatUntil(person, rationCfg.targetHunger);
    }
    if (person.thirst < rationCfg.targetThirst) {
      drinkUntil(person, rationCfg.targetThirst);
    }
  }

  function eatUntil(person, target) {
    while (person.hunger < target - 3) {
      if (useFood("meal_feast", person)) continue;
      if (useFood("meal_hearty", person)) continue;
      if (useFood("meal_simple", person)) continue;
      if (useFood("cooked_meals", person)) continue;
      if (useFood("fresh_meat", person)) continue;
      if (useFood("bacon", person)) continue;
      if (useFood("flour", person)) continue;
      if (useFood("beans_rice", person)) continue;
      if (useFood("hardtack", person)) continue;
      if (useFood("dried_fruit", person)) continue;
      break;
    }
  }

  function drinkUntil(person, target) {
    while (person.thirst < target - 5) {
      if (gameState.supplies.water <= 0) break;
      gameState.supplies.water = Math.max(
        0,
        gameState.supplies.water - WATER_PER_DRINK
      );
      person.thirst = clamp(person.thirst + 30, 0, 100);
      person.morale = clamp(person.morale + 1, 0, 100);
    }
  }

  function isCholeraCorridor(region, miles) {
    if (region === "central_plains" || region === "plains") {
      return miles >= 260 && miles <= 620;
    }
    return false;
  }

  function afflictionSeverityLabel(sev) {
    if (sev >= 3) return "severe";
    if (sev >= 2) return "moderate";
    return "mild";
  }

  function logAfflictionStageChange(person, aff, prevStage) {
    if (!person || !aff) return;
    if (aff.stage === "acute" && prevStage !== "acute") {
      if (aff.id === "dysentery") {
        addLog(
          "After drinking from a stagnant pool along the Platte, " +
            person.name +
            " is struck with violent cramps and diarrhea."
        );
      } else if (aff.id === "camp_fever") {
        addLog(
          person.name +
            " is shivering with fever and complains of aching bones."
        );
      } else if (aff.id === "sprain") {
        addLog(person.name + " is laid up by a sprained ankle.");
      }
    } else if (aff.stage === "recovery" && prevStage !== "recovery") {
      addLog(
        person.name +
          " seems to be past the worst of " +
          aff.label.toLowerCase() +
          " and is slowly regaining strength."
      );
    } else if (aff.resolved && prevStage !== "resolved") {
      addLog(
        person.name +
          " is finally able to keep food down and rest; the illness lifts."
      );
    }
  }

  function tickAfflictionsForHour() {
    const doctor = getBestDoctor();
    const hasMedicine = (gameState.supplies && gameState.supplies.med_kits) > 0;
    const docSkill = doctor && doctor.skills ? doctor.skills.doctoring || 0 : 0;
    const treatBonusBase = 1 + docSkill * 0.2 + (hasMedicine ? 0.5 : 0);
    const rng =
      (gameState.weatherSystem && gameState.weatherSystem.rng) || Math.random;

    getAllPeople().forEach(function (person) {
      if (!person || !person.alive) return;
      ensureAfflictions(person);
      person.afflictions.forEach(function (aff) {
        if (!aff || aff.resolved) return;
        aff.hoursActive += 1;

        if (aff.stage === "acute" && treatBonusBase > 1) {
          aff.reliefHours = (aff.reliefHours || 0) + 0.05 * (treatBonusBase - 1);
          if (hasMedicine && !aff.medicineUsed && aff.severity >= 2) {
            gameState.supplies.med_kits = Math.max(
              0,
              (gameState.supplies.med_kits || 0) - 1
            );
            aff.medicineUsed = true;
            if (doctor) {
              addLog(
                doctor.name +
                  " tends to " +
                  person.name +
                  " with medicines, easing the worst of the sickness."
              );
            }
          }
        }

        const progress = aff.hoursActive + (aff.reliefHours || 0);
        const incubationEnd = aff.hoursIncubation || 0;
        const acuteEnd = incubationEnd + (aff.hoursAcute || 0);
        const recoveryEnd = acuteEnd + (aff.recoveryBuffer || 24);

        let stageBefore = aff.stage;
        if (aff.stage === "incubation" && progress >= incubationEnd) {
          aff.stage = "acute";
          logAfflictionStageChange(person, aff, stageBefore);
          stageBefore = aff.stage;
        }
        if (aff.stage === "acute" && progress >= acuteEnd) {
          stageBefore = aff.stage;
          aff.stage = "recovery";
          aff.lastNotified = aff.hoursActive;
          logAfflictionStageChange(person, aff, stageBefore);
        }
        if (aff.stage === "recovery" && progress >= recoveryEnd) {
          stageBefore = aff.stage;
          aff.stage = "resolved";
          aff.resolved = true;
          logAfflictionStageChange(person, aff, stageBefore);
          return;
        }

        let conditionLoss = 0;
        const treatDivisor = aff.stage === "acute" ? treatBonusBase : 1.0;

        if (aff.id === "dysentery") {
          if (aff.stage === "incubation") {
            person.morale = clamp(person.morale - 0.5, 0, 100);
          } else if (aff.stage === "acute") {
            person.hunger = clamp(
              person.hunger - (6 * aff.severity) / treatDivisor,
              0,
              100
            );
            person.thirst = clamp(
              person.thirst - (9 * aff.severity) / treatDivisor,
              0,
              100
            );
            person.energy = clamp(
              person.energy - (5 * aff.severity) / treatDivisor,
              0,
              110
            );
            person.morale = clamp(person.morale - 4, 0, 100);
            conditionLoss += (1.3 * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            person.energy = clamp(person.energy + 0.5, 0, 110);
            person.morale = clamp(person.morale + 0.5, 0, 100);
            conditionLoss += 0.2;
          }
        } else if (aff.id === "camp_fever") {
          if (aff.stage === "incubation") {
            person.energy = clamp(person.energy - 1.2, 0, 110);
          } else if (aff.stage === "acute") {
            person.energy = clamp(
              person.energy - (4 * aff.severity) / treatDivisor,
              0,
              110
            );
            person.warmth = clamp(
              person.warmth - (3 + aff.severity),
              0,
              100
            );
            person.morale = clamp(person.morale - 2.5, 0, 100);
            person.thirst = clamp(person.thirst - 2, 0, 100);
            conditionLoss += (0.9 * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            person.warmth = clamp(person.warmth + 0.4, 0, 100);
            person.morale = clamp(person.morale + 0.4, 0, 100);
            conditionLoss += 0.25;
          }
        } else if (aff.id === "sprain") {
          if (aff.stage === "acute") {
            person.energy = clamp(person.energy - 1, 0, 110);
            person.morale = clamp(person.morale - 0.8, 0, 100);
            conditionLoss += 0.35 / treatDivisor;
          } else if (aff.stage === "recovery") {
            person.energy = clamp(person.energy - 0.25, 0, 110);
          }
        }

        person.condition = clamp(person.condition - conditionLoss, 0, 100);

        const needsProgressLog =
          aff.stage === "acute" &&
          (aff.lastNotified == null || aff.hoursActive - aff.lastNotified >= 12);
        if (needsProgressLog) {
          aff.lastNotified = aff.hoursActive;
          if (aff.id === "dysentery") {
            addLog(
              person.name +
                " is too weak to walk and rides in the wagon while the illness grips them."
            );
          } else if (aff.id === "camp_fever") {
            addLog(
              person.name +
                " burns with fever and needs tending; travel slows while they rest."
            );
          } else if (aff.id === "sprain") {
            addLog(person.name + " keeps weight off a swollen ankle.");
          }
        }


        if (person.condition <= 0 && person.alive) {
          person.alive = false;
          addLog(
            person.name +
              " dies after a brutal bout of " +
              aff.label.toLowerCase() +
              " on the trail."
          );
          onPersonDeath(person);
        }
      });
    });
  }

  function maybeTriggerIllnessForHour() {
    const rng =
      (gameState.weatherSystem && gameState.weatherSystem.rng) || Math.random;
    const region = gameState.region;
    const w = gameState.weatherState || {};
    const tempC = typeof w.tempC === "number" ? w.tempC : 15;
    const hot = tempC >= 24;
    const wetRecently = w.precip === "rain" || gameState.recentRainHours > 24;
    const mouths = mouthsCount();
    const s = gameState.supplies || {};
    const waterGal = s.water || 0;
    const miles = gameState.milesTraveled || 0;
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    const avgConditionEnergy = people.length
      ?
          people.reduce(function (sum, p) {
            return sum + ((p.condition || 0) + (p.energy || 0)) / 2;
          }, 0) / people.length
      : 100;

    if (isCholeraCorridor(region, miles)) {
      let base = 0.0005;
      if (hot && wetRecently) base *= 1.5;
      if (waterGal < mouths * 0.4) base *= 1.5;
      if (avgConditionEnergy < 50) base *= 1.5;

      let newCase = false;
      people.some(function (p) {
        if (hasAffliction(p, "dysentery")) return false;
        if (rng() < base) {
          addAffliction(p, "dysentery", { severity: rng() < 0.35 ? 2 : 1 });
          newCase = true;
          return true;
        }
        return false;
      });
      if (newCase) return; // avoid multiple clustered cases in one hour
    }

    const coldWet =
      tempC <= 5 || ((w.precip === "rain" && tempC < 10) || w.precip === "snow");
    if (gameState.mode === "camp" && coldWet) {
      const roughCamp =
        gameState.dayRhythm &&
        gameState.dayRhythm.eveningCampChoice === "rushed";
      people.forEach(function (p) {
        if (!p || hasAffliction(p, "camp_fever")) return;
        const warmthLow = p.warmth < 30;
        const energyLow = p.energy < 30;
        if (!warmthLow && !energyLow) return;
        let risk = 0.0003;
        if (warmthLow) risk *= 1.6;
        if (energyLow) risk *= 1.6;
        if (roughCamp) risk *= 1.3;
        if (rng() < risk) {
          addAffliction(p, "camp_fever", { severity: tempC <= 0 ? 2 : 1 });
        }
      });
    }
  }

  function isCholeraCorridor(region, miles) {
    if (region === "central_plains" || region === "plains") {
      return miles >= 260 && miles <= 620;
    }
    return false;
  }

  function afflictionSeverityLabel(sev) {
    if (sev >= 3) return "severe";
    if (sev >= 2) return "moderate";
    return "mild";
  }

  function logAfflictionStageChange(person, aff, prevStage) {
    if (!person || !aff) return;
    if (aff.stage === "acute" && prevStage !== "acute") {
      if (aff.id === "dysentery") {
        addLog(
          "After drinking from a stagnant pool along the Platte, " +
            person.name +
            " is struck with violent cramps and diarrhea."
        );
      } else if (aff.id === "camp_fever") {
        addLog(
          person.name +
            " is shivering with fever and complains of aching bones."
        );
      } else if (aff.id === "sprain") {
        addLog(person.name + " is laid up by a sprained ankle.");
      }
    } else if (aff.stage === "recovery" && prevStage !== "recovery") {
      addLog(
        person.name +
          " seems to be past the worst of " +
          aff.label.toLowerCase() +
          " and is slowly regaining strength."
      );
    } else if (aff.resolved && prevStage !== "resolved") {
      addLog(
        person.name +
          " is finally able to keep food down and rest; the illness lifts."
      );
    }
  }

  function tickAfflictionsForHour() {
    const doctor = getBestDoctor();
    const hasMedicine = (gameState.supplies && gameState.supplies.med_kits) > 0;
    const docSkill = doctor && doctor.skills ? doctor.skills.doctoring || 0 : 0;
    const treatBonusBase = 1 + docSkill * 0.2 + (hasMedicine ? 0.5 : 0);
    const rng =
      (gameState.weatherSystem && gameState.weatherSystem.rng) || Math.random;

    getAllPeople().forEach(function (person) {
      if (!person || !person.alive) return;
      ensureAfflictions(person);
      person.afflictions.forEach(function (aff) {
        if (!aff || aff.resolved) return;
        aff.hoursActive += 1;

        if (aff.stage === "acute" && treatBonusBase > 1) {
          aff.reliefHours = (aff.reliefHours || 0) + 0.05 * (treatBonusBase - 1);
          if (hasMedicine && !aff.medicineUsed && aff.severity >= 2) {
            gameState.supplies.med_kits = Math.max(
              0,
              (gameState.supplies.med_kits || 0) - 1
            );
            aff.medicineUsed = true;
            if (doctor) {
              addLog(
                doctor.name +
                  " tends to " +
                  person.name +
                  " with medicines, easing the worst of the sickness."
              );
            }
          }
        }

        const progress = aff.hoursActive + (aff.reliefHours || 0);
        const incubationEnd = aff.hoursIncubation || 0;
        const acuteEnd = incubationEnd + (aff.hoursAcute || 0);
        const recoveryEnd = acuteEnd + (aff.recoveryBuffer || 24);

        let stageBefore = aff.stage;
        if (aff.stage === "incubation" && progress >= incubationEnd) {
          aff.stage = "acute";
          logAfflictionStageChange(person, aff, stageBefore);
          stageBefore = aff.stage;
        }
        if (aff.stage === "acute" && progress >= acuteEnd) {
          stageBefore = aff.stage;
          aff.stage = "recovery";
          aff.lastNotified = aff.hoursActive;
          logAfflictionStageChange(person, aff, stageBefore);
        }
        if (aff.stage === "recovery" && progress >= recoveryEnd) {
          stageBefore = aff.stage;
          aff.stage = "resolved";
          aff.resolved = true;
          logAfflictionStageChange(person, aff, stageBefore);
          return;
        }

        let conditionLoss = 0;
        const treatDivisor = aff.stage === "acute" ? treatBonusBase : 1.0;

        if (aff.id === "dysentery") {
          if (aff.stage === "incubation") {
            person.morale = clamp(person.morale - 0.5, 0, 100);
          } else if (aff.stage === "acute") {
            person.hunger = clamp(
              person.hunger - (6 * aff.severity) / treatDivisor,
              0,
              100
            );
            person.thirst = clamp(
              person.thirst - (9 * aff.severity) / treatDivisor,
              0,
              100
            );
            person.energy = clamp(
              person.energy - (5 * aff.severity) / treatDivisor,
              0,
              110
            );
            person.morale = clamp(person.morale - 4, 0, 100);
            conditionLoss += (1.3 * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            person.energy = clamp(person.energy + 0.5, 0, 110);
            person.morale = clamp(person.morale + 0.5, 0, 100);
            conditionLoss += 0.2;
          }
        } else if (aff.id === "camp_fever") {
          if (aff.stage === "incubation") {
            person.energy = clamp(person.energy - 1.2, 0, 110);
          } else if (aff.stage === "acute") {
            person.energy = clamp(
              person.energy - (4 * aff.severity) / treatDivisor,
              0,
              110
            );
            person.warmth = clamp(
              person.warmth - (3 + aff.severity),
              0,
              100
            );
            person.morale = clamp(person.morale - 2.5, 0, 100);
            person.thirst = clamp(person.thirst - 2, 0, 100);
            conditionLoss += (0.9 * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            person.warmth = clamp(person.warmth + 0.4, 0, 100);
            person.morale = clamp(person.morale + 0.4, 0, 100);
            conditionLoss += 0.25;
          }
        } else if (aff.id === "sprain") {
          if (aff.stage === "acute") {
            person.energy = clamp(person.energy - 1, 0, 110);
            person.morale = clamp(person.morale - 0.8, 0, 100);
            conditionLoss += 0.35 / treatDivisor;
          } else if (aff.stage === "recovery") {
            person.energy = clamp(person.energy - 0.25, 0, 110);
          }
        }

        person.condition = clamp(person.condition - conditionLoss, 0, 100);

        const needsProgressLog =
          aff.stage === "acute" &&
          (aff.lastNotified == null || aff.hoursActive - aff.lastNotified >= 12);
        if (needsProgressLog) {
          aff.lastNotified = aff.hoursActive;
          if (aff.id === "dysentery") {
            addLog(
              person.name +
                " is too weak to walk and rides in the wagon while the illness grips them."
            );
          } else if (aff.id === "camp_fever") {
            addLog(
              person.name +
                " burns with fever and needs tending; travel slows while they rest."
            );
          } else if (aff.id === "sprain") {
            addLog(person.name + " keeps weight off a swollen ankle.");
          }
        }

        if (person.condition <= 0 && person.alive) {
          person.alive = false;
          addLog(
            person.name +
              " dies after a brutal bout of " +
              aff.label.toLowerCase() +
              " on the trail."
          );
          onPersonDeath(person);
        }
      });
    });
  }

  function maybeTriggerIllnessForHour() {
    const rng =
      (gameState.weatherSystem && gameState.weatherSystem.rng) || Math.random;
    const region = gameState.region;
    const w = gameState.weatherState || {};
    const tempC = typeof w.tempC === "number" ? w.tempC : 15;
    const hot = tempC >= 24;
    const wetRecently = w.precip === "rain" || gameState.recentRainHours > 24;
    const mouths = mouthsCount();
    const s = gameState.supplies || {};
    const waterGal = s.water || 0;
    const miles = gameState.milesTraveled || 0;
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    const avgConditionEnergy = people.length
      ?
          people.reduce(function (sum, p) {
            return sum + ((p.condition || 0) + (p.energy || 0)) / 2;
          }, 0) / people.length
      : 100;

    if (isCholeraCorridor(region, miles)) {
      let base = 0.0005;
      if (hot && wetRecently) base *= 1.5;
      if (waterGal < mouths * 0.4) base *= 1.5;
      if (avgConditionEnergy < 50) base *= 1.5;

      let newCase = false;
      people.some(function (p) {
        if (hasAffliction(p, "dysentery")) return false;
        if (rng() < base) {
          addAffliction(p, "dysentery", { severity: rng() < 0.35 ? 2 : 1 });
          newCase = true;
          return true;
        }
        return false;
      });
      if (newCase) return; // avoid multiple clustered cases in one hour
    }

    const coldWet =
      tempC <= 5 || ((w.precip === "rain" && tempC < 10) || w.precip === "snow");
    if (gameState.mode === "camp" && coldWet) {
      const roughCamp =
        gameState.dayRhythm &&
        gameState.dayRhythm.eveningCampChoice === "rushed";
      people.forEach(function (p) {
        if (!p || hasAffliction(p, "camp_fever")) return;
        const warmthLow = p.warmth < 30;
        const energyLow = p.energy < 30;
        if (!warmthLow && !energyLow) return;
        let risk = 0.0003;
        if (warmthLow) risk *= 1.6;
        if (energyLow) risk *= 1.6;
        if (roughCamp) risk *= 1.3;
        if (rng() < risk) {
          addAffliction(p, "camp_fever", { severity: tempC <= 0 ? 2 : 1 });
        }
      });
    }
  }

  function useFood(itemId, person) {
    const cfg = FOOD_VALUES[itemId];
    if (!cfg) return false;

    const supplyItem = SUPPLY_ITEMS.find(function (s) {
      return s.id === itemId;
    });
    if (!supplyItem) return false;

    const stock = gameState.supplies[itemId] || 0;
    if (stock <= 0) return false;

    let perUnit = 1;
    if (
      supplyItem.category === "FOOD" ||
      supplyItem.category === "FOOD_PREPARED"
    ) {
      perUnit = supplyItem.weight || 1;
    }
    const neededUnits = cfg.lbsPerServing / perUnit;
    if (stock < neededUnits) return false;

    const lbsUsed = neededUnits * perUnit;
    gameState.supplies[itemId] = stock - neededUnits;

    // NEW – long‑term diet tracking
    applyNutritionFromFood(itemId, lbsUsed);

    person.hunger = clamp(
      person.hunger + (cfg.hungerGain || 0),
      0,
      100
    );
    if (cfg.energyGain) {
      person.energy = clamp(
        person.energy + cfg.energyGain,
        0,
        110
      );
    }
    if (cfg.warmthGain) {
      person.warmth = clamp(
        person.warmth + cfg.warmthGain,
        0,
        100
      );
    }
    if (cfg.moraleGain != null) {
      person.morale = clamp(
        person.morale + cfg.moraleGain,
        0,
        100
    );
    } else if (cfg.isPrepared) {
      person.morale = clamp(person.morale + 3, 0, 100);
    } else {
      person.morale = clamp(person.morale + 1, 0, 100);
    }
    if (
      cfg.isPrepared &&
      (itemId === "meal_hearty" || itemId === "meal_feast") &&
      Math.random() < 0.45
    ) {
      addThought(person, {
        id: "hearty_meal",
        label: "Hearty meal",
        value: 5,
        hoursLeft: 12,
        source: "meal",
      });
    }
    return true;
  }

  function brewCoffeeWithMeal(block) {
    const s = gameState.supplies;
    let coffeeLbs = s.coffee || 0;
    if (coffeeLbs <= 0) {
      if (Math.random() < 0.18) {
        addLog(
          "Someone wishes aloud for coffee, but the coffee barrel has been empty for days."
        );
      }
      return;
    }

    const mouths = mouthsCount();
    if (mouths <= 0) return;

    const cupsPerLb = 20;
    const maxCups = Math.floor(coffeeLbs * cupsPerLb);
    if (maxCups <= 0) return;

    const cups   = Math.min(maxCups, mouths);
    const lbsUsed = cups / cupsPerLb;

    s.coffee = clamp(coffeeLbs - lbsUsed, 0, coffeeLbs);
    applyNutritionFromFood("coffee", lbsUsed);

    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    people.forEach(function (p) {
      p.morale = clamp(p.morale + 1.5, 0, 100);
      p.energy = clamp(p.energy + 1.5, 0, 110);
      p.warmth = clamp(p.warmth + 0.5, 0, 100);
    });

    addLog(
      "A pot of coffee is brewed and passed around the " +
        (block === "morning" ? "breakfast" : "evening") +
        " fire."
    );
  }



  function performCooking(person, context) {
    const s = gameState.supplies;
    let fuelBefore = (s.firewood || 0) + (s.buffalo_chips || 0);
    if (fuelBefore <= 0.05) {
      addLog(
        person.name +
          " tries to cook, but you have no dry wood or buffalo chips for a cooking fire."
      );
      return;
    }

    const skill    = person.skills.cooking || 1;
    const block    = getScheduleBlock(gameState.date);
    const rationId = gameState.rations || "filling";
    const wState   = gameState.weatherState || {};
    const wetFuel  =
      (gameState.recentRainHours || 0) > 8 ||
      wState.precip === "rain" ||
      wState.precip === "snow";
    const effort =
      context && context.campQuality === "proper" ? "proper" : "quick";

    // How many meals can we plausibly turn out in this hour?
    let maxMealsBase = 1 + skill;
    if (block === "evening") maxMealsBase += 1;
    if (effort === "proper") maxMealsBase += 1 + skill * 0.7;
    const maxMeals = clamp(maxMealsBase, 1, 10);

    // Fuel and burn chance tuned by fuel condition and effort.
    let fuelPerMeal   = effort === "proper" ? 0.25 : 0.18;
    let fuelAvailable = fuelBefore;

    let burnChance = 0.32 - skill * 0.05;
    if (wetFuel) burnChance += 0.12;
    if (effort === "proper") burnChance -= 0.07;
    burnChance = clamp(burnChance, 0.06, 0.55);

    // Ration tier gates which recipes we're willing to attempt.
    let allowFeast  = rationId === "filling" || rationId === "normal";
    let allowHearty = rationId !== "barebones";
    if (effort === "quick" && block !== "evening") {
      // Breakfast / rushed camp → mostly quick fry‑ups.
      allowFeast  = false;
      allowHearty = rationId !== "barebones" && rationId !== "meager";
    }
    if (rationId === "meager") {
      // You can still splurge now and then, but it’s rare.
      if (Math.random() < 0.7) allowFeast = false;
    }

    const made = { meal_simple: 0, meal_hearty: 0, meal_feast: 0 };
    let burnedMeals = 0;

    function haveLbs(id, lbs) {
      const item = SUPPLY_ITEMS.find(function (i) {
        return i.id === id;
      });
      if (!item) return false;
      const qty     = gameState.supplies[id] || 0;
      const perUnit = item.weight || 1;
      return qty * perUnit >= lbs - 1e-4;
    }

    function takeLbs(id, lbs) {
      const item = SUPPLY_ITEMS.find(function (i) {
        return i.id === id;
      });
      if (!item) return false;
      const perUnit     = item.weight || 1;
      const unitsNeeded = lbs / perUnit;
      const have        = gameState.supplies[id] || 0;
      if (have < unitsNeeded - 1e-4) return false;
      gameState.supplies[id] = have - unitsNeeded;
      return true;
    }

    function tryFeastType() {
      if (!allowFeast) return null;
      // Trail stew: fresh meat + bit of flour + dried fruit/roots.
      if (
        haveLbs("fresh_meat", 0.6) &&
        haveLbs("flour", 0.2) &&
        haveLbs("dried_fruit", 0.2)
      ) {
        if (
          !takeLbs("fresh_meat", 0.6) ||
          !takeLbs("flour", 0.2) ||
          !takeLbs("dried_fruit", 0.2)
        ) {
          return null;
        }
        return "trail_stew";
      }
      // Fallback: rich meat‑heavy fry‑up.
      if (haveLbs("fresh_meat", 0.8) && haveLbs("flour", 0.1)) {
        if (!takeLbs("fresh_meat", 0.8) || !takeLbs("flour", 0.1)) return null;
        return "meat_feast";
      }
      return null;
    }

    function tryHeartyType() {
      if (!allowHearty) return null;
      // Classic beans & bacon pot.
      if (haveLbs("beans_rice", 0.4) && haveLbs("bacon", 0.35)) {
        if (!takeLbs("beans_rice", 0.4) || !takeLbs("bacon", 0.35)) return null;
        return "beans_bacon";
      }
      // Thick mush & bacon for a hearty breakfast.
      if (block === "morning" && haveLbs("flour", 0.45) && haveLbs("bacon", 0.25)) {
        if (!takeLbs("flour", 0.45) || !takeLbs("bacon", 0.25)) return null;
        return "mush_bacon";
      }
      return null;
    }

    function trySimpleType() {
      // Bread / mush from flour/beans/hardtack/dried fruit.
      const options = [
        { id: "flour",      lbs: 0.4,  type: "bread" },
        { id: "beans_rice", lbs: 0.4,  type: "bean_mush" },
        { id: "hardtack",   lbs: 0.35, type: "hardtack" },
        { id: "dried_fruit",lbs: 0.3,  type: "fruit_mush" },
      ];
      for (let i = 0; i < options.length; i++) {
        const opt = options[i];
        if (haveLbs(opt.id, opt.lbs) && takeLbs(opt.id, opt.lbs)) {
          return opt.type;
        }
      }
      return null;
    }

    const dishSamples = [];

    for (let i = 0; i < maxMeals; i++) {
      if (fuelAvailable < fuelPerMeal) break;

      let tier = null;
      let dishType = null;

      if (block === "morning") {
        // Morning: mostly simple mush / slapjacks, occasional hearty pan.
        dishType = trySimpleType();
        tier     = dishType ? "meal_simple" : null;
        if (!tier) {
          const ht = tryHeartyType();
          if (ht) {
            dishType = ht;
            tier     = "meal_hearty";
          }
        }
      } else if (block === "evening") {
        // Evening: stew and beans get priority.
        const feastRoll = Math.random();
        if (feastRoll < 0.4) {
          const ft = tryFeastType();
          if (ft) {
            dishType = ft;
            tier     = "meal_feast";
          }
        }
        if (!tier) {
          const ht = tryHeartyType();
          if (ht) {
            dishType = ht;
            tier     = "meal_hearty";
          }
        }
        if (!tier) {
          const st = trySimpleType();
          if (st) {
            dishType = st;
            tier     = "meal_simple";
          }
        }
      } else {
        // Noon / night: quick fry‑ups if anything at all.
        const st = trySimpleType();
        if (st) {
          dishType = st;
          tier     = "meal_simple";
        }
      }

      if (!tier) break;

      fuelAvailable -= fuelPerMeal;

      if (Math.random() < burnChance) {
        burnedMeals++;
        continue;
      }

      made[tier]++;
      if (dishSamples.length < 3 && dishType) {
        dishSamples.push(dishType);
      }
    }

    const totalMeals =
      made.meal_simple + made.meal_hearty + made.meal_feast;

    if (totalMeals <= 0) {
      if (fuelAvailable < fuelPerMeal) {
        addLog(
          person.name +
            " tends a smoky little fire, but there isn’t enough fuel or food for a proper hot meal."
        );
      } else {
        addLog(
          person.name +
            " works at the fire, but inexperience and thin stores mean little is fit to eat."
        );
      }
      return;
    }

    if (!s.meal_simple) s.meal_simple = 0;
    if (!s.meal_hearty) s.meal_hearty = 0;
    if (!s.meal_feast)  s.meal_feast  = 0;
    s.meal_simple += made.meal_simple;
    s.meal_hearty += made.meal_hearty;
    s.meal_feast  += made.meal_feast;

    // Adjust fuel stores back into wood vs chips.
    const fuelUsed = fuelBefore - fuelAvailable;
    let use = fuelUsed;
    const useFromWood = Math.min(use, s.firewood || 0);
    s.firewood = (s.firewood || 0) - useFromWood;
    use -= useFromWood;
    if (use > 0) {
      const useFromChips = Math.min(use, s.buffalo_chips || 0);
      s.buffalo_chips = (s.buffalo_chips || 0) - useFromChips;
    }

    person.morale = clamp(
      person.morale + 2 + Math.round(skill / 2),
      0,
      100
    );

    // Brew coffee alongside hearty breakfasts / suppers when possible.
    if (
      (block === "morning" || block === "evening") &&
      (made.meal_hearty + made.meal_feast) > 0
    ) {
      brewCoffeeWithMeal(block);
    }

    // Build a flavorful description.
    let desc = "";
    const rLabel =
      rationId === "barebones"
        ? "scant"
        : rationId === "meager"
        ? "meager"
        : rationId === "normal"
        ? "steady"
        : "hearty";

    if (block === "morning") {
      if (made.meal_hearty + made.meal_feast > 0) {
        desc =
          "a " +
          rLabel +
          " breakfast of mush, slapjacks, and bacon";
      } else {
        desc =
          "simple trail mush and bacon for breakfast";
      }
    } else if (block === "evening") {
      if (made.meal_hearty + made.meal_feast > 0) {
        let stewName = "beans and bacon";
        if (made.meal_feast > 0) {
          const loc = (gameState.locationName || "").toLowerCase();
          if (loc.indexOf("salmon falls") >= 0) {
            stewName = "salmon pot with traded roots and herbs";
          } else if (
            gameState.region === "plains" ||
            gameState.region === "central_plains"
          ) {
            stewName = "buffalo or antelope stew with dumplings";
          } else if (
            gameState.region === "snake_plain" ||
            gameState.region === "columbia"
          ) {
            stewName = "game and dried-fruit stew simmered in a big pot";
          } else if (
            gameState.region === "blue_mountains" ||
            gameState.region === "willamette"
          ) {
            stewName =
              "elk or venison stew thickened with flour and whatever roots can be found";
          }
        }
        desc =
          "a " +
          rLabel +
          " supper pot of " +
          stewName;
      } else {
        desc = "warm bread and bacon for supper";
      }
    } else {
      desc = totalMeals + " quick hot meal" + (totalMeals > 1 ? "s" : "");
    }

    let burnDesc = "";
    if (burnedMeals > 0) {
      if (wetFuel && skill <= 2) {
        burnDesc =
          " The damp chips smoke and sputter; a few biscuits end up scorched on the bottom and doughy on top.";
      } else {
        burnDesc =
          " A few portions are spoiled or burned in the rush.";
      }
    }

    addLog(
      person.name +
        " cooks for the camp: " +
        desc +
        " (" +
        totalMeals +
        " serving" +
        (totalMeals > 1 ? "s" : "") +
        " prepared)." +
        burnDesc
    );
  }


  function performHunt(person) {
    const ammoBoxes = gameState.supplies.ammo || 0;
    const rifles = gameState.supplies.rifles || 0;
    if (ammoBoxes <= 0 || rifles <= 0) {
      addLog(
        person.name +
          " goes hunting but you are short on arms or ammunition."
      );
      return;
    }

    const bullets = ammoBoxes * 20;
    const shots = Math.min(10, bullets);
    const skill = person.skills.hunting || 1;

    const regionBase =
      gameState.region === "plains"
        ? 0.22
        : gameState.region === "central_plains"
        ? 0.28
        : gameState.region === "snake_plain"
        ? 0.18
        : 0.16;

    let meat = 0;
    for (let i = 0; i < shots; i++) {
      if (Math.random() < regionBase + skill * 0.03) {
        meat += randFloat(4, 18);
      }
    }

    const inefficiency = skill <= 1 ? 1.3 : skill >= 4 ? 0.8 : 1.0;
    const usedBullets = Math.min(Math.round(shots * inefficiency), bullets);
    const boxesUsed = usedBullets / 20;
    gameState.supplies.ammo = Math.max(0, ammoBoxes - boxesUsed);

    if (meat > 0) {
      gameState.supplies.fresh_meat =
        (gameState.supplies.fresh_meat || 0) + meat;
      person.morale = clamp(person.morale + 4, 0, 100);
      addLog(
        person.name +
          " brings back about " +
          Math.round(meat) +
          " lb of fresh game."
      );
    } else {
      addLog(person.name + " returns from the hunt empty-handed.");
    }

    const injuryChance = clamp(0.08 - skill * 0.012, 0.02, 0.08);
    if (Math.random() < injuryChance) {
      person.condition = clamp(person.condition - 8, 0, 100);
      addAffliction(person, "sprain", { severity: 1 });
      addLog(
        person.name + " twists an ankle scrambling over rough ground and limps back to camp."
      );
    }
  }

  function performGatherWood(person) {
    const yieldBase =
      gameState.region === "plains"
        ? 4
        : gameState.region === "central_plains"
        ? 6
        : gameState.region === "blue_mountains"
        ? 10
        : 5;
    const skill = person.skills.woodcutting || 1;
    const bundles = yieldBase * (0.3 + skill * 0.2);
    if (!gameState.supplies.firewood) gameState.supplies.firewood = 0;
    gameState.supplies.firewood += bundles * 0.2;

    if (
      gameState.region === "plains" ||
      gameState.region === "central_plains"
    ) {
      if (!gameState.supplies.buffalo_chips)
        gameState.supplies.buffalo_chips = 0;
      gameState.supplies.buffalo_chips += bundles * 0.3;
    }

    addLog(
      person.name +
        " gathers fuel around camp — enough for a couple of fires if kept dry."
    );

    const mishapChance = clamp(0.05 - skill * 0.01, 0.01, 0.05);
    if (Math.random() < mishapChance) {
      person.condition = clamp(person.condition - 5, 0, 100);
      addLog(
        person.name +
          " nicks a hand on rough wood, but the injury is minor."
      );
    }
  }

  function performFetchWater(person) {
    let factor = 0.5;
    const name = gameState.locationName.toLowerCase();
    if (
      name.indexOf("river") >= 0 ||
      name.indexOf("ford") >= 0 ||
      name.indexOf("creek") >= 0 ||
      name.indexOf("falls") >= 0 ||
      name.indexOf("springs") >= 0
    ) {
      factor = 1.0;
    } else if (
      gameState.region === "snake_plain" ||
      gameState.region === "mountains"
    ) {
      factor = 0.7;
    } else if (gameState.region === "blue_mountains") {
      factor = 0.8;
    }

    const gallons = 3 * factor;
    if (!gameState.supplies.water) gameState.supplies.water = 0;
    gameState.supplies.water += gallons;
    addLog(
      person.name +
        " hauls water for camp — about " +
        gallons.toFixed(1) +
        " gallons."
    );
  }

  function performRepair(person) {
    const hasParts =
      (gameState.supplies.wheels || 0) +
        (gameState.supplies.axles || 0) +
        (gameState.supplies.tongues || 0) >
      0;
    const skill = person.skills.woodcutting || 1;
    const gain = hasParts ? 4 + skill * 1.5 : 2 + skill;
    gameState.wagonCondition = clamp(
      gameState.wagonCondition + gain,
      0,
      100
    );
    addLog(
      person.name +
        " spends the hour tightening bolts, checking wheels, and greasing the wagon."
    );
  }

  function performTask(person, taskIdOverride, context) {
    if (!person || !person.alive) return;

    const w = gameState.weatherState || {};
    const rationCfg = RATION_CONFIG[gameState.rations] || RATION_CONFIG.filling;

    let hungerDrain = rationCfg.hungerDrainPerHour;
    let thirstDrain = rationCfg.thirstDrainPerHour;
    let energyDrain = 2.0;

    const task = taskIdOverride || person.task || "travel";
    const isTravelMode = gameState.mode === "travel";

    const workTask =
      task === "travel" ||
      task === "scout" ||
      task === "hunt" ||
      task === "gather_wood" ||
      task === "repair";

    // Extra strain for active work
    if (workTask) {
      hungerDrain += 0.6;
      thirstDrain += 0.6;
      energyDrain += 1.2;
    }

    // Weather effects on drains
    if (w.tempC >= 28) {
      thirstDrain += 1.2;
      hungerDrain += 0.4;
    } else if (w.tempC <= 0) {
      hungerDrain += 0.3;
    }

    // Apply drains
    person.hunger = clamp(person.hunger - hungerDrain, 0, 100);
    person.thirst = clamp(person.thirst - thirstDrain, 0, 100);
    person.energy = clamp(person.energy - energyDrain, 0, 100);

    // Skill XP by doing
    if (task === "travel" || task === "scout") {
      gainSkillXP(person, "travel", 1);
    } else if (task === "hunt") {
      gainSkillXP(person, "hunting", 1.2);
    } else if (task === "cook") {
      gainSkillXP(person, "cooking", 1.1);
    } else if (task === "gather_wood" || task === "repair") {
      gainSkillXP(person, "woodcutting", 1);
    } else if (task === "guard") {
      gainSkillXP(person, "travel", 0.5);
    }

    // Task-specific effects
    if (task === "travel" && isTravelMode) {
      const paceCfg = PACE_CONFIG[gameState.pace] || PACE_CONFIG.steady;
      person.energy = clamp(
        person.energy - (paceCfg.staminaCost || 4) * 0.4,
        0,
        100
      );
    } else if (task === "scout" && isTravelMode) {
      person.energy = clamp(person.energy - 3, 0, 100);
      if (Math.random() < 0.05) {
        addLog(person.name + " scouts ahead and spots a better ford.");
        gameState.wagonCondition = clamp(gameState.wagonCondition + 1, 0, 100);
      }
    } else if (task === "hunt") {
      person.energy = clamp(person.energy - 4, 0, 100);
      performHunt(person);
    } else if (task === "gather_wood") {
      person.energy = clamp(person.energy - 3.5, 0, 100);
      performGatherWood(person);
    } else if (task === "fetch_water") {
      person.energy = clamp(person.energy - 3, 0, 100);
      performFetchWater(person);
    } else if (task === "cook") {
      person.energy = clamp(person.energy - 2.5, 0, 100);
      // IMPORTANT: pass context so camp-quality & meal macros work
      performCooking(person, context || null);
    } else if (task === "repair") {
      person.energy = clamp(person.energy - 3, 0, 100);
      performRepair(person);
    } else if (task === "guard") {
      person.energy = clamp(person.energy - 2, 0, 100);
      gameState.guardLevel += 0.5;
    } else if (task === "rest") {
      person.energy = clamp(person.energy + 4, 0, 100);
      person.morale = clamp(person.morale + 1, 0, 100);
    } else if (task === "sleep") {
      if (isNight(gameState.date)) {
        person.energy = clamp(person.energy + 10, 0, 110);
        person.morale = clamp(person.morale + 2, 0, 100);
      } else {
        person.energy = clamp(person.energy + 2, 0, 100);
      }
    }

    // Warmth changes after the hour’s work/rest
    let warmthDelta = -0.4;
    if (w.precip === "snow" || w.tempC <= -2) warmthDelta -= 2.0;
    if (w.precip === "rain" && w.tempC < 8)  warmthDelta -= 1.5;
    if (w.precip === "rain" && w.tempC >= 8) warmthDelta -= 0.5;
    if (w.tempC >= 26)                        warmthDelta += 2.0;

    if (task === "cook" || task === "rest" || (task === "sleep" && !isTravelMode)) {
      warmthDelta += 0.6; // by the fire / wrapped up
    } else if (task === "scout" || task === "hunt") {
      warmthDelta -= 0.4;
    }

    person.warmth = clamp(person.warmth + warmthDelta, 0, 100);

    // Auto-eating & drinking to hit ration targets
    autoConsumeFor(person);

    const avgNeeds =
      (person.hunger + person.thirst + person.warmth + person.energy) / 4;
    const moodDelta = avgNeeds < 40 ? -2 : avgNeeds > 80 ? 1.5 : 0;
    person.morale = clamp(person.morale + moodDelta, 0, 100);

    person.condition = clamp(
      0.15 * person.hunger +
        0.15 * person.thirst +
        0.25 * person.energy +
        0.15 * person.warmth +
        0.3  * person.morale,
      0,
      100
    );

    if (person.condition <= 0 && person.alive) {
      person.alive = false;
      addLog(person.name + " dies on the trail.");
      onPersonDeath(person);
    }
  }



  function advanceOneHour(context) {
    const ss = ensureStoryState();
    gameState.date = new Date(gameState.date.getTime() + 60 * 60 * 1000);

    // Track daily rhythm and diet per calendar day
    ensureDayRhythmForDate(gameState.date);
    ensureNutritionForDate(gameState.date);

    refreshWeather();
    gameState.guardLevel = 0;

    const people = getAllPeople();
    const resolvedTasks = resolveTasksForHour();

    people.forEach(function (p, idx) {
      if (!p) return;
      const t =
        resolvedTasks && resolvedTasks[idx]
          ? resolvedTasks[idx]
          : p.task || "travel";
      performTask(p, t, context);
    });

    if (ss.eventFlags && ss.eventFlags.forcedCampHours > 0) {
      gameState.mode = "camp";
      ss.eventFlags.forcedCampHours -= 1;
    }

    const miles = gameState.mode === "camp" ? 0 : computeMilesForHour();
    gameState.lastHourMiles = miles;
    gameState.milesTraveled = clamp(
      gameState.milesTraveled + miles,
      0,
      gameState.targetMiles
    );

    updateDayRhythmForCurrentHour(miles);

    if (context && context.campQuality) {
      applyCampQualityEffects(context);
    }

    updateRegionAndLocation();
    if (gameState.traillines) {
      gameState.traillines.fogMaxMile = Math.max(
        gameState.traillines.fogMaxMile || 0,
        gameState.milesTraveled || 0
      );
    }
    tickAfflictionsForHour();
    maybeTriggerIllnessForHour();
    updateNeedsAndMoodForHour();
    showCompanionThoughtForHour();
    eventDirectorTick();

    if (gameState.milesTraveled >= gameState.targetMiles) {
      addLog(
        "After months on the trail, your wagon rolls into Oregon City to the cheers of other emigrants."
      );
    }
  }

  function advanceHours(count, context) {
    // Ensure at least 1 hour, and make sure it's an integer
    count = count || 1;
    count = count < 1 ? 1 : Math.floor(count);

    for (let i = 0; i < count; i++) {
      advanceOneHour(context);
    }

    // After the block of time, persist and redraw
    saveGame();
    renderAll();
  }



  function maybeRandomEvent() {
    const r = Math.random();
    const w = gameState.weatherState || {};
    const loc = gameState.locationName.toLowerCase();

    if (
      (loc.indexOf("river") >= 0 || loc.indexOf("ford") >= 0) &&
      (w.precip === "rain" || gameState.recentRainHours > 18)
    ) {
      const riverRisk = gameState.highRiverRisk ? 0.12 : 0.07;
      if (r < riverRisk) {
        const lost = Math.min(gameState.lastHourMiles || 0, 1.5);
        gameState.milesTraveled = clamp(
          gameState.milesTraveled - lost,
          0,
          gameState.targetMiles
        );
        addLog(
          "High water at " +
            gameState.locationName +
            " forces you to wait and scout for a safer crossing." +
            (gameState.highRiverRisk
              ? " Spring runoff from the early start keeps the current fierce."
              : "")
        );
        return;
      }
    }

    if (r < 0.02 && gameState.wagonCondition < 75) {
      gameState.wagonCondition = clamp(gameState.wagonCondition - 8, 0, 100);
      addLog(
        "The wagon hits a deep rut and something cracks. You make repairs as best you can."
      );
    } else if (r < 0.04 && w.storm) {
      addLog(
        "Lightning forks across the sky and heavy rain turns the trail to mud."
      );
    } else if (r < 0.055 && gameState.region === "plains") {
      addLog(
        "You pass fresh graves along the trail, a sobering reminder of how many never reach Oregon."
      );
      if (gameState.leader) {
        gameState.leader.morale = clamp(
          gameState.leader.morale - 3,
          0,
          100
        );
      }
    }

    const r2 = Math.random();
    if (isNight(gameState.date) && gameState.mode === "camp") {
      if (gameState.guardLevel <= 0 && r2 < 0.06) {
        const roll = Math.random();

        // 1) Stock stampede
        if ((gameState.supplies.oxen || 0) > 0 && roll < 0.4) {
          const lost =
            Math.random() < 0.5 ? 1 : 0; // usually just shaken, sometimes a lost ox
          if (lost > 0) {
            gameState.supplies.oxen = Math.max(
              0,
              (gameState.supplies.oxen || 0) - lost
            );
            addLog(
              "With no one on watch, the stock stampede in the darkness. By morning you're short " +
                lost +
                " head of oxen and the rest are blown and nervous."
            );
          } else {
            addLog(
              "With no one on guard, your stock startles at some unseen noise and you spend part of the night rounding them up."
            );
          }
        }
        // 2) Theft / prowlers
        else if (roll < 0.75) {
          let stoleSomething = false;
          if ((gameState.supplies.flour || 0) > 0) {
            const amt = Math.min(20, gameState.supplies.flour || 0);
            gameState.supplies.flour -= amt;
            stoleSomething = true;
          }
          if ((gameState.supplies.ammo || 0) > 0 && Math.random() < 0.6) {
            const boxes = Math.min(2, gameState.supplies.ammo || 0);
            gameState.supplies.ammo -= boxes;
            stoleSomething = true;
          }
          if (stoleSomething) {
            addLog(
              "Sometime in the small hours, prowlers slip through the unguarded camp. A little food and ammunition are gone by dawn."
            );
          } else {
            addLog(
              "The wagons sit in uneasy silence under the stars. You sleep lightly, half expecting trouble that, mercifully, never comes."
            );
          }
        }
        // 3) Predator / hostile-tension style scare
        else {
          const people = getAllPeople().filter(function (p) {
            return p && p.alive;
          });
          const victim = people.length ? choice(people) : gameState.leader;
          if (victim) {
            victim.condition = clamp(victim.condition - 8, 0, 100);
            victim.morale = clamp(victim.morale - 4, 0, 100);
          }
          addLog(
            "Wolves or some other prowler nose near the wagons. Without a night watch, the camp wakes in confusion and someone is hurt in the scramble."
          );
        }

        if (gameState.leader) {
          gameState.leader.energy = clamp(
            gameState.leader.energy - 6,
            0,
            100
          );
          gameState.leader.morale = clamp(
            gameState.leader.morale - 2,
            0,
            100
          );
        }
      } else if (gameState.guardLevel >= 1.5 && r2 < 0.04) {
        addLog(
          "Those on watch spot trouble early—a stray animal or prowler—and quietly head it off before it reaches camp."
        );
      }
    }
  }

  /* ========= STORYTELLER / MOOD SYSTEM ==================================== */

  function updateRiskFlags() {
    const ss = ensureStoryState();
    const s = gameState.supplies || {};
    const mouths = mouthsCount();
    const cookedMeals =
      (s.meal_simple || 0) + (s.meal_hearty || 0) + (s.meal_feast || 0);
    ss.risk.water_shortage = (s.water || 0) < mouths * 0.4;
    ss.risk.starvation = cookedMeals < Math.max(1, mouths * 1.2);

    const ratio = computeDraftPower() > 0
      ? computeTotalWeight() / computeDraftPower()
      : 2;
    ss.risk.overloaded_wagon = ratio > 0.95;

    const w = gameState.weatherState || {};
    const avgWarmth = getAllPeople().reduce(function (sum, p) {
      return sum + (p && p.warmth ? p.warmth : 0);
    }, 0) / Math.max(1, getAllPeople().length);
    ss.risk.cold_exposure = (w.tempC || 0) < -2 && avgWarmth < 55;
    ss.risk.soaked = w.storm || gameState.recentRainHours > 18;

    const dayKeyStart = gameState.startDayOfYear || getDayOfYear(gameState.date);
    const daysOut = Math.max(0, getDayOfYear(gameState.date) - dayKeyStart);
    const expectedMiles = daysOut * 11.5;
    ss.risk.behind_schedule = gameState.milesTraveled < expectedMiles - 60;

    const block = getScheduleBlock(gameState.date);
    ss.risk.no_guard =
      block === "night" && gameState.mode === "camp" && gameState.guardLevel < 1;

    ss.risk.low_morale = (gameState.lastAvgMorale || 60) < 35;

    ss.riskDurations = ss.riskDurations || {};
    Object.keys(ss.risk).forEach(function (key) {
      const active = !!ss.risk[key];
      const current = ss.riskDurations[key] || 0;
      ss.riskDurations[key] = clamp(current + (active ? 1 : -1.2), 0, 240);
    });
    ss.risk.extended_water_shortage = (ss.riskDurations.water_shortage || 0) > 10;
    ss.risk.extended_starvation = (ss.riskDurations.starvation || 0) > 14;
    ss.risk.extended_cold_exposure = (ss.riskDurations.cold_exposure || 0) > 10;
  }

  function updateNeedsAndMoodForHour() {
    const ss = ensureStoryState();
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    if (!people.length) return;

    let totalMorale = 0;
    let totalNeedScore = 0;

    people.forEach(function (p) {
      ensurePersonStoryFields(p);
      p.thoughts = (p.thoughts || [])
        .map(function (t) {
          if (!t) return null;
          t.hoursLeft = (t.hoursLeft || 0) - 1;
          return t.hoursLeft > 0 ? t : null;
        })
        .filter(Boolean);

      const needsScore =
        (p.hunger + p.thirst + p.warmth + p.energy + p.condition) / 5;
      totalNeedScore += needsScore;

      let thoughtBonus = 0;
      (p.thoughts || []).forEach(function (t) {
        thoughtBonus += t && t.value ? t.value : 0;
      });

      Object.keys(p.relationships || {}).forEach(function (key) {
        const rel = p.relationships[key];
        if (!rel) return;
        const other = people.find(function (x) {
          return x && x.id === key && x.alive;
        });
        if (other && rel.opinion >= 50) {
          thoughtBonus += 1.5;
        }
      });

      let morale =
        needsScore * 0.6 +
        (p.morale || 50) * 0.25 +
        thoughtBonus * 1.5;

      const optimismFactor = clamp((p.optimism || 0) / 100, 0.25, 0.85);
      const deficit = Math.max(0, 70 - needsScore);
      morale -= deficit * (1 - optimismFactor * 0.7);
      morale = clamp(morale, 0, 100);

      p.morale = morale;
      p.optimism = clamp((p.optimism || 0) - 0.06 - (needsScore < 45 ? 0.08 : 0), 0, 85);
      p.moodState =
        morale > 70
          ? "Upbeat"
          : morale >= 35
          ? "Uneasy"
          : morale >= 15
          ? "Worn"
          : "Broken";

      if (morale < 25) {
        p.lowMoraleHours = (p.lowMoraleHours || 0) + 1;
      } else {
        p.lowMoraleHours = Math.max(0, (p.lowMoraleHours || 0) - 0.5);
      }
      if (p.lowMoraleHours > 8 && !ss.eventFlags["pending_break_" + p.id]) {
        ss.eventFlags["pending_break_" + p.id] = true;
      }

      totalMorale += morale;
    });

    gameState.lastAvgMorale = totalMorale / Math.max(1, people.length);
    gameState.lastAvgNeeds = totalNeedScore / Math.max(1, people.length);

    updateRiskFlags();
  }

  function onPersonDeath(person) {
    if (!person) return;
    const others = getAllPeople().filter(function (p) {
      return p && p.alive && p.id !== person.id;
    });
    others.forEach(function (p) {
      const rel = p.relationships && p.relationships[person.id];
      if (rel && rel.opinion >= 50) {
        addThought(p, {
          id: "loss_" + person.id,
          label: "Lost a loved one",
          value: -15,
          hoursLeft: 48,
          source: "loss",
        });
      }
    });
  }

  function updateStoryTension(storyState, ctx) {
    const preset =
      STORYTELLER_PRESETS[storyState.presetId || gameState.storytellerPresetId] ||
      STORYTELLER_PRESETS.classic;
    const riskPull = ctx.riskCount * preset.tensionRiskScale;
    const moodPull = ctx.avgMorale > 70 ? -0.25 : ctx.avgMorale < 40 ? 0.35 : 0;
    const drift = preset.tensionBaseDrift;
    storyState.tension = clamp(
      (storyState.tension || 0) + drift + riskPull + moodPull,
      0,
      100
    );
  }

  const EVENT_DEFS = [
    {
      id: "clear_skies_breather",
      kind: "breather",
      minTension: 15,
      condition: function (ctx) {
        return (
          ctx.storyState.tension > 25 &&
          ctx.avgMorale < 65 &&
          ctx.weather.precip === "none"
        );
      },
      weight: function (ctx) {
        return 6 + (ctx.risk.low_morale ? 3 : 0);
      },
      run: function (ctx) {
        addLog(
          "A clear stretch of trail and calm weather steadies everyone's nerves.",
          {
            tone: "morale",
            tag: "DAY " + ctx.dayTag,
            location: ctx.location,
          }
        );
        ctx.people.forEach(function (p) {
          addThought(p, {
            id: "calm_weather",
            label: "Calm weather",
            value: 4,
            hoursLeft: 12,
            source: "weather",
          });
        });
        ctx.storyState.tension = clamp(ctx.storyState.tension - 10, 0, 100);
        ctx.storyState.hoursSinceMinorEvent = 0;
      },
    },
    {
      id: "soaked_shivers",
      kind: "minor",
      maxTension: 90,
      condition: function (ctx) {
        return ctx.risk.soaked || ctx.risk.cold_exposure;
      },
      weight: function (ctx) {
        return 8 + (ctx.risk.cold_exposure ? 4 : 0);
      },
      run: function (ctx) {
        const target = ctx.people.length ? choice(ctx.people) : null;
        if (target) {
          target.warmth = clamp(target.warmth - 6, 0, 100);
          addThought(target, {
            id: "chilled",
            label: "Chilled and soaked",
            value: -6,
            hoursLeft: 10,
            source: "weather",
          });
          addLog(
            target.name +
              " can't shake the cold after marching in the wet. Spirits dip as everyone tries to dry gear by the fire.",
            {
              tone: "warning",
              characters: [target.id],
              tag: "DAY " + ctx.dayTag,
              location: ctx.location,
            }
          );
        }
        ctx.storyState.tension = clamp(ctx.storyState.tension + 4, 0, 100);
        ctx.storyState.hoursSinceMinorEvent = 0;
      },
    },
    {
      id: "rival_snapping",
      kind: "minor",
      condition: function (ctx) {
        return ctx.rivalPair && ctx.risk.low_morale;
      },
      weight: function () {
        return 7;
      },
      run: function (ctx) {
        const pair = ctx.rivalPair;
        if (!pair) return;
        addLog(
          pair[0].name +
            " snaps at " +
            pair[1].name +
            " over chores, fraying tempers for the evening.",
          {
            tone: "social",
            characters: [pair[0].id, pair[1].id],
            tag: "DAY " + ctx.dayTag,
            location: ctx.location,
          }
        );
        addThought(pair[0], {
          id: "argument",
          label: "Argument at camp",
          value: -4,
          hoursLeft: 12,
          source: "social",
        });
        addThought(pair[1], {
          id: "argument",
          label: "Argument at camp",
          value: -4,
          hoursLeft: 12,
          source: "social",
        });
        const relA = pair[0].relationships[pair[1].id];
        const relB = pair[1].relationships[pair[0].id];
        if (relA) relA.opinion = clamp((relA.opinion || 0) - 4, -100, 100);
        if (relB) relB.opinion = clamp((relB.opinion || 0) - 4, -100, 100);
        ctx.storyState.hoursSinceMinorEvent = 0;
        ctx.storyState.tension = clamp(ctx.storyState.tension + 6, 0, 100);
      },
    },
    {
      id: "lifeline_water",
      kind: "minor",
      condition: function (ctx) {
        return (
          (ctx.risk.water_shortage || ctx.risk.starvation) &&
          !ctx.storyState.eventFlags.lifelineUsed
        );
      },
      weight: function (ctx) {
        return ctx.risk.water_shortage ? 12 : 4;
      },
      run: function (ctx) {
        gameState.supplies.water = (gameState.supplies.water || 0) + 6;
        gameState.supplies.meal_simple = (gameState.supplies.meal_simple || 0) + 2;
        ctx.storyState.eventFlags.lifelineUsed = true;
        ctx.storyState.eventFlags.recent_lifeline = true;
        addLog(
          "A fellow traveler shares a keg of water and a little food after seeing your state.",
          {
            tone: "event",
            tag: "DAY " + ctx.dayTag,
            location: ctx.location,
          }
        );
        ctx.storyState.hoursSinceMinorEvent = 0;
        ctx.storyState.tension = clamp(ctx.storyState.tension - 6, 0, 100);
      },
    },
    {
      id: "minor_break",
      kind: "minor",
      condition: function (ctx) {
        return !!ctx.pendingBreakPerson;
      },
      weight: function () {
        return 10;
      },
      run: function (ctx) {
        const p = ctx.pendingBreakPerson;
        if (!p) return;
        ctx.storyState.eventFlags["pending_break_" + p.id] = false;
        addLog(
          p.name + " begs off chores, too worn in spirit to help for a while.",
          {
            tone: "morale",
            characters: [p.id],
            tag: "DAY " + ctx.dayTag,
            location: ctx.location,
          }
        );
        addThought(p, {
          id: "minor_break",
          label: "Shaken nerves",
          value: -5,
          hoursLeft: 10,
          source: "morale",
        });
        ctx.storyState.tension = clamp(ctx.storyState.tension + 4, 0, 100);
        ctx.storyState.hoursSinceMinorEvent = 0;
      },
    },
    // River drama events
    {
      id: "river_debate_and_delay",
      kind: "minor",
      minTension: 16,
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        const w = ctx.weather || {};
        return (
          (loc.indexOf("river") >= 0 || loc.indexOf("ford") >= 0) &&
          (w.precip === "rain" || w.storm || ctx.storyState.risk.soaked)
        );
      },
      weight: function (ctx) {
        return 6 + (ctx.storyState.tension > 30 ? 3 : 0);
      },
      run: function (ctx) {
        addLog(
          "Hours go to scouting and arguing over the crossing. By dusk you have little to show but wet boots and frayed nerves.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        gameState.lastHourMiles = Math.max(0, (gameState.lastHourMiles || 0) - 1);
        ctx.people.forEach(function (p) {
          addThought(p, {
            id: "river_argue",
            label: "Argued at the ford",
            value: -3,
            hoursLeft: 8,
            source: "river",
          });
        });
        ctx.storyState.tension = clamp(ctx.storyState.tension + 2, 0, 100);
      },
    },
    {
      id: "river_wagon_swept",
      kind: "major",
      minTension: 24,
      condition: function (ctx) {
        const w = ctx.weather || {};
        return ctx.gameState.highRiverRisk || w.storm || ctx.storyState.risk.soaked;
      },
      weight: function (ctx) {
        return 6 + (ctx.storyState.risk.overloaded_wagon ? 4 : 0);
      },
      run: function (ctx) {
        const people = ctx.people.slice();
        if (!people.length) return;
        const victim = choice(people);
        const rescuer = choice(people.filter(function (p) { return p.id !== victim.id; })) || victim;
        addLog(
          victim.name +
            " slips as the wagon lurches. For a moment the current seizes them before " +
            rescuer.name +
            " drags them to a snagging branch.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [victim.id, rescuer.id] }
        );
        adjustOpinion(victim, rescuer, 12, "rescued");
        addThought(victim, {
          id: "river_rescued",
          label: "Pulled from the river",
          value: 8,
          hoursLeft: 24,
          source: "river",
        });
        addThought(rescuer, {
          id: "river_rescuer",
          label: "Risked myself in the river",
          value: -2,
          hoursLeft: 12,
          source: "river",
        });
        gameState.wagonCondition = clamp(gameState.wagonCondition - 10, 0, 100);
        ctx.storyState.risk.overloaded_wagon = true;
      },
    },
    {
      id: "river_good_signs",
      kind: "breather",
      minTension: 10,
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        return loc.indexOf("river") >= 0 && !ctx.storyState.risk.soaked;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        addLog(
          "The river runs lower than expected. You wade across with steady footing and spirits lift.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.people.forEach(function (p) {
          addThought(p, {
            id: "river_relief",
            label: "River went well",
            value: 4,
            hoursLeft: 10,
            source: "river",
          });
        });
      },
    },
    // Illness cascade events
    {
      id: "illness_simmering_fever",
      kind: "minor",
      condition: function (ctx) {
        return ctx.storyState.risk.cold_exposure && ctx.people.some(function (p) { return hasAffliction(p, "dysentery") || hasAffliction(p, "camp_fever"); });
      },
      weight: function () {
        return 8;
      },
      run: function (ctx) {
        addLog(
          "Feverish faces around the fire make the camp whisper about what a cold, soaked night might bring.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.people.forEach(function (p) {
          addThought(p, {
            id: "fever_worry",
            label: "Worried about fevers",
            value: -4,
            hoursLeft: 12,
            source: "illness",
          });
        });
      },
    },
    {
      id: "illness_crisis_night",
      kind: "major",
      minTension: 26,
      condition: function (ctx) {
        const night = isNight(ctx.gameState.date);
        const severe = ctx.people.some(function (p) {
          return p.afflictions && p.afflictions.some(function (a) { return a && a.stage === "acute"; });
        });
        return night && severe && (ctx.storyState.risk.behind_schedule || ctx.storyState.risk.cold_exposure);
      },
      weight: function () {
        return 7;
      },
      run: function (ctx) {
        const sick = ctx.people.filter(function (p) {
          return p.afflictions && p.afflictions.some(function (a) { return a && a.stage === "acute"; });
        });
        if (!sick.length) return;
        const patient = choice(sick);
        addLog(
          "Night stretches on as " +
            patient.name +
            " fights fevered shivers. No miles made—just damp cloths, whispered prayers, and a late start to come.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [patient.id] }
        );
        addThought(patient, {
          id: "fever_crisis",
          label: "Burning fever",
          value: -8,
          hoursLeft: 16,
          source: "illness",
        });
        ctx.storyState.risk.behind_schedule = true;
      },
    },
    {
      id: "illness_turning_point",
      kind: "breather",
      maxTension: 55,
      condition: function (ctx) {
        return ctx.storyState.risk.behind_schedule && !ctx.storyState.risk.extended_starvation;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        addLog(
          "After days of tending, the worst of the fever breaks. The camp breathes easier and tidies the scattered gear.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.storyState.risk.behind_schedule = false;
        ctx.people.forEach(function (p) {
          addThought(p, {
            id: "fever_broke",
            label: "Fever finally broke",
            value: 6,
            hoursLeft: 14,
            source: "illness",
          });
        });
      },
    },
    // Mental break events
    {
      id: "minor_break_snapped_at_camp",
      kind: "minor",
      minTension: 12,
      condition: function (ctx) {
        return ctx.pendingBreakPerson && ctx.storyState.risk.low_morale;
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        const p = ctx.pendingBreakPerson;
        if (!p) return;
        ctx.storyState.eventFlags["pending_break_" + p.id] = false;
        p.lastBreakHour = (p.lastBreakHour || 0) + 6;
        addLog(
          p.name + " slams tools down and stalks off for a while, chores left half-done and tempers raw.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [p.id] }
        );
        addThought(p, {
          id: "snap_camp",
          label: "Snapped at camp",
          value: -6,
          hoursLeft: 10,
          source: "morale",
        });
        ctx.storyState.tension = clamp(ctx.storyState.tension + 3, 0, 100);
      },
    },
    {
      id: "major_break_refuse_travel",
      kind: "major",
      minTension: 24,
      condition: function (ctx) {
        return ctx.pendingBreakPerson && ctx.pendingBreakPerson.moodState === "Broken";
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        const p = ctx.pendingBreakPerson;
        if (!p) return;
        ctx.storyState.eventFlags["pending_break_" + p.id] = false;
        ctx.storyState.eventFlags.forcedCampHours = Math.max(
          ctx.storyState.eventFlags.forcedCampHours || 0,
          8
        );
        p.lowMoraleHours = 0;
        addLog(
          p.name +
            " refuses to take another step today. The wagon circle holds for hours while they sit apart from the fire.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [p.id] }
        );
        addThought(p, {
          id: "after_break",
          label: "Emptied out but calmer",
          value: 5,
          hoursLeft: 18,
          source: "morale",
        });
      },
    },
    {
      id: "major_break_storming_off_to_hunt",
      kind: "major",
      minTension: 18,
      condition: function (ctx) {
        return ctx.pendingBreakPerson && ctx.storyState.risk.starvation;
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        const p = ctx.pendingBreakPerson;
        if (!p) return;
        ctx.storyState.eventFlags["pending_break_" + p.id] = false;
        const success = Math.random() < 0.45;
        if (success) {
          gameState.supplies.meat = (gameState.supplies.meat || 0) + 12;
          addLog(
            p.name +
              " storms off with a rifle and returns at dusk blood-spattered but triumphant with fresh meat.",
            { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [p.id] }
          );
          addThought(p, { id: "risked_for_food", label: "Hunted alone", value: 4, hoursLeft: 16, source: "morale" });
        } else {
          p.condition = clamp(p.condition - 8, 0, 100);
          addLog(
            p.name +
              " vanishes to hunt and limps back empty-handed, scraped and chilled after hours in the brush.",
            { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [p.id] }
          );
          addThought(p, { id: "hunt_failure", label: "Lonely, cold hunt", value: -6, hoursLeft: 12, source: "morale" });
        }
      },
    },
    {
      id: "major_break_leadership_dispute",
      kind: "major",
      minTension: 28,
      condition: function (ctx) {
        return ctx.rivalPair && (ctx.storyState.risk.behind_schedule || ctx.storyState.risk.low_morale);
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        const pair = ctx.rivalPair;
        const a = pair[0];
        const b = pair[1];
        const winner = (a.morale || 0) >= (b.morale || 0) ? a : b;
        const loser = winner === a ? b : a;
        addLog(
          winner.name +
            " and " +
            loser.name +
            " clash over the route. Voices carry until one backs down.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [a.id, b.id] }
        );
        adjustOpinion(loser, winner, -8, "dispute");
        adjustOpinion(winner, loser, -2, "dispute");
        addThought(winner, { id: "vindicated", label: "Stood my ground", value: 5, hoursLeft: 16, source: "social" });
        addThought(loser, { id: "humiliated", label: "Questioned leadership", value: -7, hoursLeft: 20, source: "social" });
      },
    },
    // Relationship arcs
    {
      id: "romance_under_stars",
      kind: "breather",
      maxTension: 55,
      condition: function (ctx) {
        return ctx.strongBondPair && ctx.gameState.mode === "camp" && !ctx.storyState.risk.no_guard;
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        const pair = ctx.strongBondPair;
        if (!pair) return;
        addLog(
          pair[0].name +
            " and " +
            pair[1].name +
            " share quiet stories by the coals. The camp moves softly around them.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [pair[0].id, pair[1].id] }
        );
        pair.forEach(function (p) {
          addThought(p, { id: "quiet_moment", label: "Quiet moment under stars", value: 6, hoursLeft: 12, source: "social" });
        });
      },
    },
    {
      id: "rival_showdown",
      kind: "major",
      minTension: 30,
      condition: function (ctx) {
        return ctx.rivalPair && ctx.storyState.risk.low_morale;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        const pair = ctx.rivalPair;
        if (!pair) return;
        const winner = Math.random() < 0.5 ? pair[0] : pair[1];
        const loser = winner === pair[0] ? pair[1] : pair[0];
        addLog(
          "Arguments boil over until " + winner.name + " wins the camp to their side—at least for now.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [winner.id, loser.id] }
        );
        adjustOpinion(loser, winner, -10, "showdown");
        addThought(winner, { id: "vindicated2", label: "Vindicated", value: 6, hoursLeft: 18, source: "social" });
        addThought(loser, { id: "humiliated2", label: "Humiliated", value: -8, hoursLeft: 18, source: "social" });
        ctx.storyState.risk.low_morale = false;
      },
    },
    {
      id: "lifeline_gratitude_chain",
      kind: "lifeline",
      maxTension: 70,
      condition: function (ctx) {
        return ctx.storyState.eventFlags.recent_lifeline;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        addLog(
          "Around the fire, the party quietly thanks whoever saved their hide this week. Determination firms.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.people.forEach(function (p) {
          p.optimism = clamp((p.optimism || 50) + 2, 0, 100);
          addThought(p, { id: "gratitude", label: "Grateful to still be here", value: 4, hoursLeft: 14, source: "social" });
        });
        ctx.storyState.eventFlags.recent_lifeline = false;
      },
    },
    // Risk cascade events
    {
      id: "cascade_wagon_chain_failure",
      kind: "major",
      minTension: 22,
      condition: function (ctx) {
        return ctx.storyState.risk.overloaded_wagon && (ctx.storyState.riskDurations.overloaded_wagon || 0) > 10;
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        ctx.storyState.cascadeLog = ctx.storyState.cascadeLog || [];
        ctx.storyState.cascadeLog.push({ type: "wagon_failure", location: ctx.location, day: ctx.dayTag });
        gameState.wagonCondition = clamp(gameState.wagonCondition - 12, 0, 100);
        addLog(
          "Another axle creaks and gives. You spend half a day patching spokes and tossing gear to lighten the load.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.storyState.risk.behind_schedule = true;
      },
    },
    {
      id: "cascade_snowbound",
      kind: "major",
      minTension: 26,
      condition: function (ctx) {
        return ctx.storyState.risk.extended_cold_exposure && ctx.storyState.risk.behind_schedule;
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        ctx.storyState.cascadeLog = ctx.storyState.cascadeLog || [];
        ctx.storyState.cascadeLog.push({ type: "snowbound", location: ctx.location, day: ctx.dayTag });
        addLog(
          "Snow piles against the wagon wheels. You huddle in place for a day, burning fuel and nerves.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.people.forEach(function (p) {
          p.warmth = clamp(p.warmth - 8, 0, 100);
          addThought(p, { id: "snowbound", label: "Snowbound", value: -6, hoursLeft: 12, source: "weather" });
        });
      },
    },
    {
      id: "cascade_starvation_spiral",
      kind: "major",
      minTension: 28,
      condition: function (ctx) {
        return ctx.storyState.risk.extended_starvation;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        ctx.storyState.cascadeLog = ctx.storyState.cascadeLog || [];
        ctx.storyState.cascadeLog.push({ type: "starvation", location: ctx.location, day: ctx.dayTag });
        addLog(
          "Hollow eyes and shaking hands tell the story: the party is wasting. No miles today, only fitful rest.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.storyState.risk.low_morale = true;
        ctx.people.forEach(function (p) {
          p.energy = clamp(p.energy - 6, 0, 100);
          p.morale = clamp(p.morale - 6, 0, 100);
        });
      },
    },
  ];

  function weightedPick(items) {
    const total = items.reduce(function (sum, item) {
      return sum + (item.weight || 1);
    }, 0);
    let roll = Math.random() * total;
    for (let i = 0; i < items.length; i++) {
      roll -= items[i].weight;
      if (roll <= 0) return items[i];
    }
    return items[items.length - 1];
  }

  function buildStoryContext() {
    const ss = ensureStoryState();
    const weather = gameState.weatherState || {};
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    const rivalPair = (function () {
      for (let i = 0; i < people.length; i++) {
        for (let j = i + 1; j < people.length; j++) {
          const a = people[i];
          const b = people[j];
          const rel = a.relationships && a.relationships[b.id];
          if (rel && rel.opinion <= -30) return [a, b];
        }
      }
      return null;
    })();
    const strongBondPair = (function () {
      for (let i = 0; i < people.length; i++) {
        for (let j = i + 1; j < people.length; j++) {
          const a = people[i];
          const b = people[j];
          const rel = a.relationships && a.relationships[b.id];
          if (rel && rel.opinion >= 70) return [a, b];
        }
      }
      return null;
    })();
    const pendingKey = Object.keys(ss.eventFlags).find(function (k) {
      return k.indexOf("pending_break_") === 0 && ss.eventFlags[k];
    });
    const pendingBreakPerson = pendingKey
      ? people.find(function (p) {
          return p && "pending_break_" + p.id === pendingKey;
        })
      : null;
    const dayTag =
      gameState.startDayOfYear != null
        ? Math.max(1, getDayOfYear(gameState.date) - gameState.startDayOfYear + 1)
        : getDayOfYear(gameState.date);

    const riskKeys = Object.keys(ss.risk || {}).filter(function (k) {
      return ss.risk[k];
    });

    return {
      gameState: gameState,
      storyState: ss,
      risk: ss.risk || {},
      riskCount: riskKeys.length,
      weather: weather,
      people: people,
      location: gameState.locationName || "On the trail",
      avgMorale: gameState.lastAvgMorale || 60,
      rivalPair: rivalPair,
      strongBondPair: strongBondPair,
      pendingBreakPerson: pendingBreakPerson,
      dayTag: dayTag,
    };
  }

  function eventDirectorTick() {
    const ss = ensureStoryState();
    ss.hoursSinceMajorEvent += 1;
    ss.hoursSinceMinorEvent += 1;
    updateRiskFlags();

    const ctx = buildStoryContext();
    updateStoryTension(ss, ctx);

    const preset =
      STORYTELLER_PRESETS[ss.presetId || gameState.storytellerPresetId] ||
      STORYTELLER_PRESETS.classic;

    const eligible = EVENT_DEFS.map(function (def) {
      const okMin = def.minTension == null || ss.tension >= def.minTension;
      const okMax = def.maxTension == null || ss.tension <= def.maxTension;
      const cond = def.condition ? def.condition(ctx) : true;
      if (def.kind === "major" && ss.hoursSinceMajorEvent < preset.minHoursBetweenMajor)
        return null;
      if (def.kind !== "major" && ss.hoursSinceMinorEvent < preset.minHoursBetweenMinor)
        return null;
      return okMin && okMax && cond
        ? {
            def: def,
            weight: (function () {
              let w = def.weight ? def.weight(ctx) : 1;
              if (def.kind === "breather") w *= preset.breatherBias || 1;
              if (def.kind === "lifeline") w *= preset.lifelineBias || 1;
              if (def.kind === "major" && preset.id === "harsh") w *= 1.2;
              return w;
            })(),
          }
        : null;
    })
      .filter(Boolean)
      .filter(function (obj) {
        return obj.weight > 0;
      });

    if (eligible.length) {
      const pick = weightedPick(eligible);
      if (pick && pick.def && pick.def.run) {
        pick.def.run(ctx);
        if (pick.def.kind === "major") {
          ss.hoursSinceMajorEvent = 0;
          ss.tension = clamp(
            ss.tension - preset.tensionAfterMajorDrop,
            0,
            100
          );
        } else {
          ss.hoursSinceMinorEvent = 0;
          ss.tension = clamp(
            ss.tension - preset.tensionAfterMinorDrop,
            0,
            100
          );
        }
        return;
      }
    }

    maybeRandomEvent();
  }

  /* ========= RENDERING ===================================================== */

  function renderBars(container, person) {
    function row(label, value, type) {
      const wrap = document.createElement("div");
      wrap.className = "ot-bar-row";

      const lab = document.createElement("div");
      lab.className = "ot-bar-label";
      lab.textContent = label;
      wrap.appendChild(lab);

      const bar = document.createElement("div");
      bar.className = "ot-bar";
      const fill = document.createElement("div");
      fill.className = "ot-bar-fill";
      if (type === "warmth" && value < 40) fill.classList.add("cold");
      if (type === "condition" && value < 40) fill.classList.add("bad");
      fill.style.width = clamp(value, 0, 100) + "%";
      bar.appendChild(fill);
      wrap.appendChild(bar);
      container.appendChild(wrap);
    }

    row("Condition", person.condition, "condition");
    row("Hunger", person.hunger);
    row("Thirst", person.thirst);
    row("Warmth", person.warmth, "warmth");
    row("Energy", person.energy);
    row("Morale", person.morale);
  }

  function renderLeaderStatus() {
    dom.leaderStatus.innerHTML = "";
    if (!gameState.leader) return;
    renderBars(dom.leaderStatus, gameState.leader);
    const acute = [];
    getAllPeople().forEach(function (p) {
      activeAfflictions(p).forEach(function (a) {
        if (a.stage === "acute") acute.push(a.label + " (" + p.name + ")");
      });
    });
    if (acute.length) {
      const div = document.createElement("div");
      div.className = "ot-panel-body-sm ot-text-warning";
      div.style.marginTop = "4px";
      div.textContent = "Illness in camp: " + acute.slice(0, 3).join(", ");
      dom.leaderStatus.appendChild(div);
    }
  }

  function renderPartyManifest() {
    dom.partyManifest.innerHTML = "";
    const people = [gameState.leader].concat(gameState.companions);
    people.forEach(function (p, idx) {
      if (!p) return;
      const row = document.createElement("div");
      row.className = "ot-manifest-row";
      if (idx === gameState.selectedIndex) {
        row.classList.add("ot-manifest-selected");
      }
      row.addEventListener("click", function () {
        gameState.selectedIndex = idx;
        renderPartyManifest();
        renderCompanionDetail();
      });

      const left = document.createElement("div");
      const name = document.createElement("div");
      name.className = "ot-manifest-name";
      name.textContent = p.name;
      left.appendChild(name);
      const role = document.createElement("div");
      role.className = "ot-manifest-role";
      role.textContent = idx === 0 ? "Leader" : "Companion";
      const affs = activeAfflictions(p);
      if (affs.length) {
        name.textContent = p.name + " ✶";
        name.classList.add("ot-text-warning");
        role.textContent += " · sick";
      }
      left.appendChild(role);

      row.appendChild(left);

      const bar = document.createElement("div");
      bar.className = "ot-bar";
      const fill = document.createElement("div");
      fill.className = "ot-bar-fill";
      if (p.condition < 40) fill.classList.add("bad");
      fill.style.width = clamp(p.condition, 0, 100) + "%";
      bar.appendChild(fill);
      row.appendChild(bar);

      dom.partyManifest.appendChild(row);
    });
  }

  function renderHourTasks() {
    dom.hourTasks.innerHTML = "";
    const table = document.createElement("table");
    table.className = "ot-tasks-table";
    const tbody = document.createElement("tbody");

    function rowFor(person) {
      const tr = document.createElement("tr");
      const tdName = document.createElement("td");
      tdName.textContent = person.name;
      tr.appendChild(tdName);

      const tdSelect = document.createElement("td");
      const select = document.createElement("select");
      select.className = "ot-task-select";
      TASKS.forEach(function (t) {
        const opt = document.createElement("option");
        opt.value = t.id;
        opt.textContent = t.label;
        select.appendChild(opt);
      });
      select.value = person.task || "travel";
      select.addEventListener("change", function () {
        person.task = select.value;
      });
      tdSelect.appendChild(select);
      tr.appendChild(tdSelect);
      tbody.appendChild(tr);
    }

    if (gameState.leader) rowFor(gameState.leader);
    gameState.companions.forEach(rowFor);

    table.appendChild(tbody);
    dom.hourTasks.appendChild(table);
  }

  function pickSceneImage() {
    const miles = gameState.milesTraveled;
    const w = gameState.weatherState || {};
    let band = SCENE_BANDS[0];
    SCENE_BANDS.forEach(function (b) {
      if (miles >= b.from && miles <= b.to) band = b;
    });

    let key = "clear";
    if (w.precip === "rain") key = "storm";
    else if (w.precip === "snow") key = "cold";
    else if (w.tempC >= 26) key = "heat";

    const arr =
      (band[key] && band[key].length ? band[key] : band.clear) || [
        IMAGE_URLS.leaving_independence,
      ];
    return { url: choice(arr), label: band.label };
  }

  function renderScene() {
    const s = pickSceneImage();
    dom.scene.style.backgroundImage =
      "linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0.05)), url('" +
      s.url +
      "')";
    const w = gameState.weatherState || {};
    const regionKey = regionToWeatherRegion(gameState.region || "plains");
    const flavor = describeWeatherFlavor(regionKey, w) || s.label;
    const seasonRisk = describeSeasonRisk(
      regionKey,
      gameState.date,
      gameState.startProfile
    );
    const captionLines = [
      formatDateTime(gameState.date) + " · " + gameState.locationName,
      "Weather: " + formatWeatherSummary(w),
      seasonRisk,
      flavor,
      s.label !== flavor ? s.label : "",
    ].filter(Boolean);
    dom.sceneCaption.innerHTML = captionLines
      .map(function (line) {
        return "<div>" + line + "</div>";
      })
      .join("");
  }

  function renderTrailHeader() {
    const mouths = mouthsCount();
    const w = gameState.weatherState || {};
    const regionKey = regionToWeatherRegion(gameState.region || "plains");
    const fallbackProfile =
      START_PROFILES[gameState.startProfileId || "late_april"] ||
      START_PROFILES.late_april;
    const profileLabel = gameState.startProfile
      ? gameState.startProfile.label
      : fallbackProfile.label;
    const seasonal = describeSeasonRisk(regionKey, gameState.date, gameState.startProfile);
    const mainLine =
      formatDateTime(gameState.date) +
      " · " +
      gameState.locationName +
      " · Region: " +
      regionKey;
    const subLine =
      formatWeatherSummary(w) +
      " · Departure: " +
      profileLabel +
      " · " +
      mouths +
      " people";
    dom.trailHeader.innerHTML =
      "<div>" +
      mainLine +
      "</div><div class=\"ot-text-muted\">" +
      subLine +
      "</div>" +
      (seasonal
        ? "<div class=\"ot-text-warning\">" + seasonal + "</div>"
        : "");
  }

  function updateMapListVisibility() {
    if (!dom.trailMap) return;
    dom.trailMap.style.display = gameState.mapListVisible ? "block" : "none";
    if (dom.btnToggleMapList) {
      dom.btnToggleMapList.textContent = gameState.mapListVisible
        ? "Hide waypoints"
        : "Show waypoints";
    }
  }

  function renderTrailMap() {
    if (dom.mapViewport) {
      // background set via CSS; JS hook left in case we later want region-aware tinting
    }

    dom.trailMap.innerHTML = "";
    const miles = gameState.milesTraveled;
    const seenMile = (gameState.traillines && gameState.traillines.fogMaxMile) || 0;

    ROUTE_MILESTONES.forEach(function (m) {
      const row = document.createElement("div");
      row.className = "ot-trail-dot-row";
      const dot = document.createElement("div");
      dot.className = "ot-trail-dot";
      if (miles >= m.mile && miles < m.mile + 80) {
        dot.classList.add("ot-trail-dot-current");
      }
      if (seenMile >= m.mile) {
        dot.classList.add("ot-trail-dot-seen");
      }
      row.appendChild(dot);
      const label = document.createElement("div");
      label.textContent = m.name;
      row.appendChild(label);
      dom.trailMap.appendChild(row);
    });

    updateMapListVisibility();
  }

  /* ========= TRAILLINES EXPLORER MODE (PHASE 1) =============================== */

  const TRAILLINES_CONFIG = {
    pixelsPerMile: 2.0,
    laneBaseY: 150,
    laneAmplitude: 6,
    wagonY: -8,
  };

  const traillinesRuntime = {
    rafId: null,
    canvas: null,
    ctx: null,
  };

  function resizeTrailCanvas() {
    if (!traillinesRuntime.canvas) return;
    const dpr = window.devicePixelRatio || 1;
    const rect = traillinesRuntime.canvas.getBoundingClientRect();
    traillinesRuntime.canvas.width = rect.width * dpr;
    traillinesRuntime.canvas.height = rect.height * dpr;
    if (traillinesRuntime.ctx) {
      traillinesRuntime.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  }

  function initTraillinesExplorerIfNeeded() {
    if (!dom.trailCanvas) return;
    ensureTraillinesState();

    if (!traillinesRuntime.canvas) {
      traillinesRuntime.canvas = dom.trailCanvas;
      traillinesRuntime.ctx = dom.trailCanvas.getContext("2d");
      window.addEventListener("resize", resizeTrailCanvas);
      resizeTrailCanvas();
      gameState.traillines.visualMiles = gameState.milesTraveled || 0;
      gameState.traillines.fogMaxMile = gameState.milesTraveled || 0;
    }

    if (!traillinesRuntime.rafId) {
      traillinesRuntime.rafId = requestAnimationFrame(traillinesFrame);
    }
  }

  function traillinesFrame(timestamp) {
    traillinesRuntime.rafId = requestAnimationFrame(traillinesFrame);
    const tState = gameState.traillines;
    if (!traillinesRuntime.ctx || !tState) return;

    if (!tState.lastFrameTime) tState.lastFrameTime = timestamp;
    const dt = (timestamp - tState.lastFrameTime) / 1000;
    tState.lastFrameTime = timestamp;

    const targetMiles = gameState.milesTraveled || 0;
    const currentMiles = tState.visualMiles || 0;
    const diff = targetMiles - currentMiles;

    const maxStep = 80 * dt;
    const step = Math.max(-maxStep, Math.min(maxStep, diff * 0.12));
    tState.visualMiles = currentMiles + step;

    if (tState.visualMiles > tState.fogMaxMile) {
      tState.fogMaxMile = tState.visualMiles;
    }

    tState.laneOffset = (tState.laneOffset || 0) * 0.96;

    drawTraillinesScene();
  }

  function drawTraillinesScene() {
    if (!traillinesRuntime.canvas || !traillinesRuntime.ctx) return;

    const canvas = traillinesRuntime.canvas;
    const ctx = traillinesRuntime.ctx;
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const width = rect.width;
    const height = rect.height;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, width, height);

    const exploring =
      gameState.phase === "travel" && gameState.travelView === "explorer";
    if (!exploring) return;

    const region = gameState.region || "plains";
    const w = gameState.weatherState || {};
    const palette = {
      plains: { sky: "#324f7d", ground: "#5d4732", trail: "#c29f71" },
      central_plains: { sky: "#3c5c87", ground: "#6a5038", trail: "#cbb27f" },
      high_plains: { sky: "#2f4e75", ground: "#5a4b3b", trail: "#c7a16c" },
      mountains: { sky: "#2d3f63", ground: "#4b3f3a", trail: "#b39976" },
      snake: { sky: "#34506d", ground: "#514234", trail: "#c2a175" },
      blue_mountains: { sky: "#243553", ground: "#4d4036", trail: "#b29472" },
      columbia: { sky: "#2c3f5c", ground: "#3f3a33", trail: "#a88a65" },
      willamette: { sky: "#2a4f53", ground: "#324136", trail: "#9d8f6e" },
    };

    const regionPalette = palette[region] || palette.plains;
    const skyTop = regionPalette.sky;
    const skyBottom = w.tempC && w.tempC > 28 ? "#5b3d2a" : regionPalette.sky;

    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, skyTop);
    gradient.addColorStop(1, skyBottom);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    const haze = Math.min(Math.max((w.clouds || 0) / 100, 0), 1);
    if (haze > 0) {
      ctx.fillStyle = `rgba(120, 140, 170, ${0.18 * haze})`;
      ctx.fillRect(0, 0, width, height);
    }

    // Far terrain silhouette
    ctx.fillStyle = "rgba(20, 24, 38, 0.6)";
    ctx.beginPath();
    ctx.moveTo(0, height * 0.62);
    ctx.lineTo(width * 0.18, height * 0.54);
    ctx.lineTo(width * 0.38, height * 0.58);
    ctx.lineTo(width * 0.58, height * 0.5);
    ctx.lineTo(width * 0.74, height * 0.55);
    ctx.lineTo(width * 0.95, height * 0.52);
    ctx.lineTo(width, height * 0.56);
    ctx.lineTo(width, height);
    ctx.lineTo(0, height);
    ctx.closePath();
    ctx.fill();

    // Ground and trail band
    ctx.fillStyle = regionPalette.ground;
    ctx.fillRect(0, height * 0.58, width, height * 0.42);

    const laneBaseY = Math.min(
      height - 20,
      TRAILLINES_CONFIG.laneBaseY +
        Math.sin((gameState.traillines.visualMiles || 0) * 0.05) *
          TRAILLINES_CONFIG.laneAmplitude
    );

    const laneWidth = 70;
    ctx.fillStyle = regionPalette.trail;
    ctx.beginPath();
    ctx.moveTo(0, laneBaseY - 10);
    ctx.lineTo(width, laneBaseY + 10);
    ctx.lineTo(width, laneBaseY + laneWidth * 0.2 + 18);
    ctx.lineTo(0, laneBaseY + laneWidth * 0.2);
    ctx.closePath();
    ctx.fill();

    const midMiles = gameState.traillines.visualMiles || 0;
    const baseX = width * 0.42 + (gameState.traillines.laneOffset || 0) * 18;
    const pixelsPerMile = TRAILLINES_CONFIG.pixelsPerMile;

    // Landmarks
    (ROUTE_MILESTONES || []).forEach(function (m) {
      if (!m || typeof m.mile !== "number") return;
      const x = baseX + (m.mile - midMiles) * pixelsPerMile;
      if (x < -80 || x > width + 140) return;
      const seen = (gameState.traillines.fogMaxMile || 0) >= m.mile;
      ctx.strokeStyle = seen ? "#f6d48a" : "rgba(255, 255, 255, 0.25)";
      ctx.fillStyle = seen ? "#f6d48a" : "rgba(255, 255, 255, 0.25)";
      ctx.beginPath();
      ctx.moveTo(x, laneBaseY - 8);
      ctx.lineTo(x, laneBaseY + 22);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x, laneBaseY - 10, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.font = "10px 'Segoe UI', sans-serif";
      ctx.textAlign = "center";
      ctx.fillStyle = seen ? "#f5e9d4" : "rgba(245, 233, 212, 0.6)";
      ctx.fillText(m.name, x, laneBaseY - 20);
    });

    // Fog of war ahead
    const fogStart = width * 0.62;
    const fogGradient = ctx.createLinearGradient(fogStart, 0, width, 0);
    fogGradient.addColorStop(0, "rgba(4, 5, 8, 0)");
    fogGradient.addColorStop(1, "rgba(4, 5, 8, 0.52)");
    ctx.fillStyle = fogGradient;
    ctx.fillRect(fogStart, 0, width - fogStart, height);

    // Wagon placeholder
    const wagonX = baseX;
    const wagonY = laneBaseY + TRAILLINES_CONFIG.wagonY;
    ctx.fillStyle = "#cdb89a";
    ctx.strokeStyle = "#4a321a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    if (ctx.roundRect) {
      ctx.roundRect(wagonX - 24, wagonY - 18, 48, 26, 8);
    } else {
      ctx.rect(wagonX - 24, wagonY - 18, 48, 26);
    }
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = "#7a5a3c";
    ctx.fillRect(wagonX - 28, wagonY + 4, 56, 10);
    ctx.strokeRect(wagonX - 28, wagonY + 4, 56, 10);
    ctx.fillStyle = "#f7e7cb";
    ctx.beginPath();
    ctx.ellipse(wagonX - 14, wagonY + 16, 8, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(wagonX + 14, wagonY + 16, 8, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // Weather overlays
    if (w.precip === "rain") {
      ctx.strokeStyle = "rgba(160, 200, 255, 0.65)";
      ctx.lineWidth = 1.2;
      for (let i = 0; i < width / 6; i++) {
        const x = (i * 11 + (Date.now() / 20) % 11) % width;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x + 4, 14);
        ctx.stroke();
      }
    } else if (w.precip === "snow") {
      ctx.fillStyle = "rgba(240, 240, 255, 0.8)";
      for (let i = 0; i < width / 10; i++) {
        const x = (i * 13 + (Date.now() / 40) % 13) % width;
        const y = (i * 17 + (Date.now() / 30) % 17) % height;
        ctx.beginPath();
        ctx.arc(x, y, 1.2, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if ((w.tempC || 0) > 28) {
      ctx.fillStyle = "rgba(210, 160, 80, 0.15)";
      ctx.fillRect(0, 0, width, height);
    }

    if (gameState.pace === "grueling" && gameState.mode === "travel") {
      ctx.fillStyle = "rgba(180, 130, 70, 0.12)";
      ctx.fillRect(0, laneBaseY, width, 40);
    }
  }

  function renderCompanionDetail() {
    dom.companionDetail.innerHTML = "";
    const people = [gameState.leader].concat(gameState.companions);
    const person = people[gameState.selectedIndex] || people[0];
    if (!person) return;

    const name = document.createElement("div");
    name.style.fontSize = "13px";
    name.style.marginBottom = "2px";
    name.textContent = person.name;
    dom.companionDetail.appendChild(name);

    const role = document.createElement("div");
    role.className = "ot-panel-body-sm ot-text-muted";
    role.style.marginBottom = "6px";
    role.textContent = person.isLeader ? "Leader" : "Companion";
    dom.companionDetail.appendChild(role);

    renderBars(dom.companionDetail, person);

    const skills = person.skills || {};
    const skillsLine = document.createElement("div");
    skillsLine.className = "ot-panel-body-sm ot-text-muted";
    skillsLine.style.marginTop = "6px";
    skillsLine.textContent =
      "Travel: " +
      (skills.travel || 0) +
      " · Hunting: " +
      (skills.hunting || 0) +
      " · Cooking: " +
      (skills.cooking || 0) +
      " · Woodcutting: " +
      (skills.woodcutting || 0) +
      " · Doctoring: " +
      (skills.doctoring || 0);
    dom.companionDetail.appendChild(skillsLine);

    const affs = activeAfflictions(person);
    if (affs.length) {
      const affDiv = document.createElement("div");
      affDiv.className = "ot-panel-body-sm ot-text-warning";
      affDiv.style.marginTop = "4px";
      affDiv.textContent = affs
        .map(function (a) {
          const sev = afflictionSeverityLabel(a.severity || 1);
          return a.label + " (" + a.stage + ", " + sev + ")";
        })
        .join(" · ");
      dom.companionDetail.appendChild(affDiv);
    }
  }

  function renderTrailLog() {
    if (!window.ksOldTrailLog || !ksOldTrailLog.clear) return;
    ksOldTrailLog.clear();
    (gameState.log || []).slice(-6).forEach(function (entry) {
      if (!entry) return;
      ksOldTrailLog.add(entry.text, {
        tag:
          entry.tag ||
          ("DAY " +
            (gameState.startDayOfYear != null
              ? Math.max(
                  1,
                  getDayOfYear(entry.date) - gameState.startDayOfYear + 1
                )
              : getDayOfYear(entry.date))),
        location: entry.location || gameState.locationName || "On the trail",
        tone: entry.tone,
        characters: entry.characters,
      });
    });
  }

  function renderSuppliesOverview() {
    const s = gameState.supplies;
    const rawFoodLbs =
      (s.flour || 0) +
      (s.bacon || 0) +
      (s.beans_rice || 0) +
      (s.hardtack || 0) +
      (s.dried_fruit || 0) +
      (s.fresh_meat || 0);
    const cookedMeals =
      (s.meal_simple || 0) +
      (s.meal_hearty || 0) +
      (s.meal_feast || 0) +
      (s.cooked_meals || 0);
    const ammo     = s.ammo || 0;
    const fireFuel = (s.firewood || 0) + (s.buffalo_chips || 0);
    const waterGal = s.water || 0;
    const med      = s.med_kits || 0;

    const simple = Math.round(s.meal_simple || 0);
    const hearty = Math.round(s.meal_hearty || 0);
    const feast  = Math.round(s.meal_feast  || 0);

    let html = '<div class="ot-supplies-grid">';

    html +=
      '<div class="ot-supplies-label">Food (raw staples)</div><div class="ot-supplies-value">' +
      Math.round(rawFoodLbs) +
      " lb</div>";

    html +=
      '<div class="ot-supplies-label">Cooked meals available</div><div class="ot-supplies-value">' +
      Math.round(cookedMeals) +
      " servings</div>";

    html +=
      '<div class="ot-supplies-label"></div><div class="ot-supplies-value">' +
      (simple || hearty || feast
        ? simple +
          " simple, " +
          hearty +
          " hearty, " +
          feast +
          " feast"
        : "") +
      "</div>";

    html +=
      '<div class="ot-supplies-label">Water on hand</div><div class="ot-supplies-value">' +
      waterGal.toFixed(1) +
      " gal</div>";

    html +=
      '<div class="ot-supplies-label">Animals</div><div class="ot-supplies-value">' +
      (s.oxen || 0) +
      " oxen, " +
      (s.milk_cows || 0) +
      " milk cows</div>";

    html +=
      '<div class="ot-supplies-label">Ammunition</div><div class="ot-supplies-value">' +
      ammo +
      " boxes</div>";

    html +=
      '<div class="ot-supplies-label">Fuel for camp</div><div class="ot-supplies-value">' +
      fireFuel.toFixed(1) +
      " bundles / sacks</div>";

    html +=
      '<div class="ot-supplies-label">Medical supplies</div><div class="ot-supplies-value">' +
      med +
      " kits</div>";

    const ns = gameState.nutritionStatus;
    if (ns) {
      const dietBits = [];

      if (ns.avgFruit < 0.3) {
        dietBits.push("very little fresh food");
      } else if (ns.avgFruit < 0.6) {
        dietBits.push("some fresh food");
      } else {
        dietBits.push("plenty of greens & fruit");
      }

      if (ns.avgMeat < 0.35) {
        dietBits.push("low meat/fat");
      } else {
        dietBits.push("good meat & fat");
      }

      if (ns.avgCoffee < 0.25) {
        dietBits.push("little coffee/tea");
      } else {
        dietBits.push("regular coffee/tea");
      }

      html +=
        '<div class="ot-supplies-label">Diet (last 2 weeks)</div><div class="ot-supplies-value">' +
        dietBits.join(" · ") +
        "</div>";
    }

    html += "</div>";
    dom.suppliesOverview.innerHTML = html;
  }


  function renderFooter() {
    const miles = gameState.milesTraveled;
    const total = gameState.targetMiles;
    const flour = gameState.supplies.flour || 0;
    const morale =
      (gameState.leader ? gameState.leader.morale : 0) +
      gameState.companions.reduce(function (sum, p) {
        return sum + p.morale;
      }, 0);
    const partyCount = mouthsCount();
    const avgMorale = partyCount > 0 ? Math.round(morale / partyCount) : 0;

    dom.footerStatus.textContent =
      formatDateTime(gameState.date) +
      " · " +
      gameState.locationName +
      " · Weather: " +
      gameState.weather +
      " · Miles: " +
      Math.round(miles) +
      " / " +
      total +
      " · Flour: " +
      Math.round(flour) +
      " lb · Morale: " +
      avgMorale +
      "%";
  }

  function renderInventoryModal() {
    const people = [gameState.leader].concat(gameState.companions);
    const person = people[gameState.selectedIndex] || people[0];
    if (!person) return;
    dom.inventorySub.textContent =
      "Feeding: " +
      person.name +
      ". Click to have them eat or drink from wagon stores.";

    const foods = [
      "meal_feast",
      "meal_hearty",
      "meal_simple",
      "cooked_meals",
      "fresh_meat",
      "bacon",
      "flour",
      "beans_rice",
      "hardtack",
      "dried_fruit",
    ];

    dom.inventoryBody.innerHTML = "";

    foods.forEach(function (id) {
      const cfg = FOOD_VALUES[id];
      const item = SUPPLY_ITEMS.find(function (s) {
        return s.id === id;
      });
      if (!item || !cfg) return;
      const tr = document.createElement("tr");
      const tdName = document.createElement("td");
      tdName.textContent = item.name;
      tr.appendChild(tdName);

      const tdQty = document.createElement("td");
      const qty = gameState.supplies[id] || 0;
      if (item.category === "FOOD_PREPARED") {
        tdQty.textContent = Math.round(qty) + " meals";
      } else {
        tdQty.textContent = Math.round(qty) + " " + item.unit;
      }
      tr.appendChild(tdQty);

      const tdUse = document.createElement("td");
      const btn = document.createElement("button");
      btn.className = "ot-inv-btn";
      btn.textContent =
        id === "meal_feast"
          ? "Eat feast"
          : id === "meal_hearty"
          ? "Eat hearty meal"
          : id === "meal_simple" || id === "cooked_meals"
          ? "Eat a meal"
          : "Eat some";
      btn.addEventListener("click", function () {
        const ok = useFood(id, person);
        if (ok) {
          addLog(person.name + " eats from " + item.name.toLowerCase() + ".");
          renderAll();
        } else {
          alert("Not enough " + item.name.toLowerCase() + " left.");
        }
      });
      tdUse.appendChild(btn);
      tr.appendChild(tdUse);

      dom.inventoryBody.appendChild(tr);
    });

    const trW = document.createElement("tr");
    const tdWName = document.createElement("td");
    tdWName.textContent = "Water";
    trW.appendChild(tdWName);
    const tdWQty = document.createElement("td");
    tdWQty.textContent = (gameState.supplies.water || 0).toFixed(1) + " gal";
    trW.appendChild(tdWQty);
    const tdWUse = document.createElement("td");
    const wBtn = document.createElement("button");
    wBtn.className = "ot-inv-btn";
    wBtn.textContent = "Drink";
    wBtn.addEventListener("click", function () {
      if (gameState.supplies.water <= 0) {
        alert("No drinkable water left.");
        return;
      }
      drinkUntil(person, 90);
      addLog(person.name + " drinks deeply from the water keg.");
      renderAll();
    });
    tdWUse.appendChild(wBtn);
    trW.appendChild(tdWUse);
    dom.inventoryBody.appendChild(trW);
  }

  function renderOnTrailHeader() {
    const paceCfg = PACE_CONFIG[gameState.pace] || PACE_CONFIG.steady;
    const rationCfg = RATION_CONFIG[gameState.rations] || RATION_CONFIG.filling;
    dom.ontrailPace.textContent = paceCfg.label;
    dom.ontrailRations.textContent = rationCfg.label;
    dom.ontrailMode.textContent =
      gameState.mode === "travel" ? "On the move" : "In camp";

    if (dom.ontrailBlock) {
      const block = getScheduleBlock(gameState.date);
      let label = "Night";
      if (block === "morning") label = "Morning (pre-dawn–noon)";
      else if (block === "noon") label = "Nooning (midday halt)";
      else if (block === "evening") label = "Evening (camp chores)";
      dom.ontrailBlock.textContent = label;
    }

    const w = gameState.weatherState || {};
    if (dom.weatherSummary) {
      dom.weatherSummary.textContent =
        (gameState.weather ? gameState.weather + " · " : "") +
        formatWeatherSummary(w);
    }
    if (dom.weatherNote) {
      const regionKey = regionToWeatherRegion(gameState.region || "plains");
      const seasonal = describeSeasonRisk(regionKey, gameState.date, gameState.startProfile);
      const flavor = describeWeatherFlavor(regionKey, w);
      dom.weatherNote.textContent = seasonal || flavor;
    }
  }


  function updatePriorityCellAppearance(btn, prio) {
    btn.classList.remove("prio-off", "prio-1", "prio-2", "prio-3", "prio-4");
    if (prio <= 0) {
      btn.classList.add("prio-off");
    } else {
      btn.classList.add("prio-" + prio);
    }
  }

  function renderPriorityWarnings() {
    const coverage = {};
    JOB_DEFS.forEach(function (job) {
      coverage[job.id] = false;
    });
    const people = getAllPeople();
    people.forEach(function (p) {
      if (!p) return;
      ensurePersonDelegationFields(p);
      const priorities = p.priorities || {};
      JOB_DEFS.forEach(function (job) {
        const v = typeof priorities[job.id] === "number" ? priorities[job.id] : 0;
        if (v > 0) coverage[job.id] = true;
      });
    });
    const vitalIds = ["cook", "hunt", "guard", "repair", "doctor", "fetch_water"];
    const warnings = [];
    vitalIds.forEach(function (jobId) {
      if (!coverage[jobId]) {
        const job = JOB_DEFS.find(function (j) {
          return j.id === jobId;
        });
        const label = job ? job.label : jobId;
        warnings.push("No one is assigned as " + label.toLowerCase() + ".");
      }
    });
    if (!warnings.length) {
      warnings.push("All vital roles have at least one person assigned.");
    }
    dom.prioritiesWarnings.textContent = warnings.join(" ");
  }

  function renderPrioritiesModal() {
    const people = getAllPeople();
    dom.prioritiesHeadRow.innerHTML = "";
    dom.prioritiesBody.innerHTML = "";

    const thName = document.createElement("th");
    thName.textContent = "Companion";
    dom.prioritiesHeadRow.appendChild(thName);

    JOB_DEFS.forEach(function (job) {
      const th = document.createElement("th");
      th.textContent = job.label;
      dom.prioritiesHeadRow.appendChild(th);
    });

    people.forEach(function (person) {
      if (!person) return;
      ensurePersonDelegationFields(person);
      const tr = document.createElement("tr");
      const tdName = document.createElement("td");
      tdName.textContent = person.name;
      tr.appendChild(tdName);

      JOB_DEFS.forEach(function (job) {
        const td = document.createElement("td");
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "ot-priority-cell";
        const priorities = person.priorities || {};
        let prio = typeof priorities[job.id] === "number" ? priorities[job.id] : 0;
        btn.textContent = prio > 0 ? prio : "—";
        updatePriorityCellAppearance(btn, prio);
        btn.addEventListener("click", function () {
          let current =
            typeof person.priorities[job.id] === "number"
              ? person.priorities[job.id]
              : 0;
          current = (current + 1) % 5;
          person.priorities[job.id] = current;
          btn.textContent = current > 0 ? current : "—";
          updatePriorityCellAppearance(btn, current);
          renderPriorityWarnings();
          saveGame();
        });
        td.appendChild(btn);
        tr.appendChild(td);
      });

      dom.prioritiesBody.appendChild(tr);
    });

    renderPriorityWarnings();
  }

  function renderAll() {
    if (gameState.phase === "start") {
      const bgId = dom.backgroundSelect.value;
      const bg = BACKGROUNDS[bgId] || BACKGROUNDS.farmer;
      dom.backgroundDesc.textContent = bg.desc;
      renderDepartureSeasonDesc();
      updateStartArt();
      return;
    }

    if (gameState.phase === "outfit") {
      updateOutfitSummary();
      return;
    }

    if (gameState.phase === "travel") {
      if (gameState.travelView === "explorer") {
        initTraillinesExplorerIfNeeded();
      }
      renderStorytellerDescription(gameState.storytellerPresetId || "classic");
      renderOnTrailHeader();
      renderLeaderStatus();
      renderPartyManifest();
      renderHourTasks();
      renderScene();
      renderTrailHeader();
      renderTrailMap();
      renderCompanionDetail();
      renderTrailLog();
      renderSuppliesOverview();
      renderFooter();
    }
  }

  /* ========= SAVE / LOAD =================================================== */

  function normalizeLegacyMeals() {
    if (
      gameState.supplies &&
      gameState.supplies.cooked_meals &&
      !gameState.supplies.meal_simple &&
      !gameState.supplies.meal_hearty &&
      !gameState.supplies.meal_feast
    ) {
      const old = gameState.supplies.cooked_meals || 0;
      gameState.supplies.meal_simple = Math.round(old * 0.4);
      gameState.supplies.meal_hearty = Math.round(old * 0.4);
      gameState.supplies.meal_feast = old - gameState.supplies.meal_simple - gameState.supplies.meal_hearty;
    }
  }

  function saveGame() {
    try {
      const payload = {
        gameState: gameState,
      };
      localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
    } catch (e) {
      console.warn("Unable to save game:", e);
    }
  }

  function loadGame() {
    try {
      const txt = localStorage.getItem(SAVE_KEY);
      if (!txt) return false;
      const payload = JSON.parse(txt);
      if (!payload || !payload.gameState) return false;

      Object.assign(gameState, payload.gameState);
      gameState.date = new Date(gameState.date);

      if (!gameState.supplies) resetSupplies();
      if (!gameState.companions) gameState.companions = [];
      if (!Array.isArray(gameState.log)) gameState.log = [];
      if (!Array.isArray(gameState.nutritionHistory)) {
        gameState.nutritionHistory = [];
      }
      if (
        !gameState.currentNutrition ||
        !gameState.currentNutrition.dayKey
      ) {
        gameState.currentNutrition = {
          dayKey: getDayKey(gameState.date),
          staples: 0,
          meatFat: 0,
          fruitVeg: 0,
          coffeeTea: 0,
        };
      }
      if (!gameState.nutritionStatus) {
        gameState.nutritionStatus = null;
      }

      if (!gameState.startProfileId) {
        gameState.startProfileId = gameState.seasonStart || "late_april";
      }
      if (!gameState.startProfile) {
        gameState.startProfile =
          START_PROFILES[gameState.startProfileId] || START_PROFILES.late_april;
      }
      if (gameState.startDayOfYear == null && gameState.date) {
        gameState.startDayOfYear = getDayOfYear(gameState.date);
      }
      if (!gameState.partyId) {
        gameState.partyId =
          (gameState.leader && gameState.leader.name
            ? gameState.leader.name
            : "party") +
          "-" +
          gameState.startProfileId;
      }
      if (!gameState.weatherSeed) {
        gameState.weatherSeed = hashToInt(
          `${gameState.partyId}-${gameState.date.getFullYear()}`
        );
      }
      initWeatherSystem(gameState.date.getFullYear(), gameState.partyId);
      if (!Array.isArray(gameState.weatherHistory)) {
        gameState.weatherHistory = [];
      }

      ensureTraillinesState();
      ensureStoryState();

      getAllPeople().forEach(function (p) {
        ensurePersonStoryFields(p);
      });


      // Rehydrate log entry dates
      gameState.log = gameState.log
        .map(function (entry) {
          if (!entry) return null;
          const d =
            entry.date instanceof Date ? entry.date : new Date(entry.date);
          return {
            date: d,
            text: entry.text || "",
            tone: entry.tone,
            tag: entry.tag,
            location: entry.location,
            characters: entry.characters || [],
          };
        })
        .filter(Boolean);

      if (typeof gameState.mapListVisible !== "boolean") {
        gameState.mapListVisible = false;
      }

      // New: safety for daily rhythm fields on old saves
      if (typeof gameState.lastDayRhythmBonus !== "number") {
        gameState.lastDayRhythmBonus = 0;
      }

      if (!gameState.dayRhythm || !gameState.dayRhythm.dayKey) {
        // Older save with no rhythm object yet – create a fresh one for today
        ensureDayRhythmForDate(gameState.date);
      } else {
        // Back-fill any missing properties in case of version drift
        var dr = gameState.dayRhythm;
        var key = dr.dayKey || getDayKey(gameState.date);
        gameState.dayRhythm = {
          dayKey: key,
          morningTravelHours: dr.morningTravelHours || 0,
          noonCampHours: dr.noonCampHours || 0,
          noonEventTriggered: !!dr.noonEventTriggered,
          eveningCampChoice: dr.eveningCampChoice || null,
          nightTravelHours: dr.nightTravelHours || 0,
          nightGuardHours: dr.nightGuardHours || 0,
          morningSuggestionShown: !!dr.morningSuggestionShown,
          noonSuggestionShown: !!dr.noonSuggestionShown,
          eveningSuggestionShown: !!dr.eveningSuggestionShown,
        };
      }

      getAllPeople().forEach(function (p) {
        ensureAfflictions(p);
      });

      normalizeLegacyMeals();
      ensureDelegationState();
      updateRegionAndLocation();
      refreshWeather();
      return true;
    } catch (e) {
      console.warn("Unable to load save:", e);
      return false;
    }
  }


  function resetGame() {
    localStorage.removeItem(SAVE_KEY);
    location.reload();
  }

  function setTravelView(view) {
    if (view !== "journal" && view !== "explorer") view = "journal";
    gameState.travelView = view;

    if (dom.btnViewJournal && dom.btnViewExplorer) {
      dom.btnViewJournal.classList.toggle(
        "ot-view-toggle-btn-active",
        view === "journal"
      );
      dom.btnViewExplorer.classList.toggle(
        "ot-view-toggle-btn-active",
        view === "explorer"
      );
    }

    const travelScreen = dom.screens && dom.screens.travel;
    if (travelScreen) {
      travelScreen.classList.toggle("ot-view-mode-journal", view === "journal");
      travelScreen.classList.toggle(
        "ot-view-mode-explorer",
        view === "explorer"
      );
    }

    if (view === "explorer") {
      initTraillinesExplorerIfNeeded();
    }

    saveGame();
    renderAll();
  }

  /* ========= EVENT WIRING ================================================== */

  function resetTasksForCurrentMode() {
    const people = getAllPeople();
    people.forEach(function (p, idx) {
      if (!p) return;
      if (idx === 0) {
        p.task = gameState.mode === "travel" ? "travel" : "auto";
      } else {
        p.task = "auto";
      }
    });
  }

  // Evening camp macros: “Proper camp (2h)” and “Rushed camp (1h)”
  function runCampMacro(hours, campQuality) {
    if (gameState.mode !== "camp") {
      addLog(
        "You can only run camp routines while you are in camp. Toggle travel / camp first."
      );
      return;
    }

    const block = getScheduleBlock(gameState.date);

    // Track this on the daily rhythm object (used for next-day bonus/penalty)
    const dr = ensureDayRhythmForDate(gameState.date);
    dr.eveningCampChoice = campQuality;

    // Let the delegation system pick good chores for camp mode
    resetTasksForCurrentMode();

    if (campQuality === "proper") {
      addLog(
        "You spend extra time making a careful camp: stock watered and grazed, wood and water gathered, and a proper supper cooked."
      );
    } else {
      addLog(
        "You throw together a rough camp with minimal chores before night, saving time but leaving things less well prepared."
      );
    }

    // Advance time with a context flag so camp-quality effects apply
    advanceHours(hours, { campQuality: campQuality });
  }

  function wireEvents() {

    dom.backgroundSelect.addEventListener("change", function () {
      const bgId = dom.backgroundSelect.value;
      const bg = BACKGROUNDS[bgId] || BACKGROUNDS.farmer;
      dom.backgroundDesc.textContent = bg.desc;
    });

    if (dom.departureSeason) {
      dom.departureSeason.addEventListener("change", function () {
        renderDepartureSeasonDesc();
      });
    }

    dom.departureSelect.addEventListener("change", updateStartArt);
    dom.btnBeginOutfit.addEventListener("click", startNewGameFromForm);
    dom.btnAddRecommended.addEventListener("click", addRecommendedLoad);
    dom.btnBeginJourney.addEventListener("click", beginJourney);
    renderStorytellerOptions(
      dom.storytellerPreset,
      gameState.storytellerPresetId || "classic"
    );
    renderStorytellerDescription(gameState.storytellerPresetId || "classic");
    if (dom.storytellerPreset) {
      dom.storytellerPreset.addEventListener("change", function () {
        const presetId = dom.storytellerPreset.value || "classic";
        gameState.storytellerPresetId = presetId;
        renderStorytellerDescription(presetId);
        saveGame();
      });
    }

    renderStorytellerOptions(
      dom.storytellerMidrun,
      gameState.storytellerPresetId || "classic"
    );
    if (dom.btnToggleNarrator) {
      dom.btnToggleNarrator.addEventListener("click", function () {
        if (!dom.narratorPicker) return;
        const visible = dom.narratorPicker.style.display !== "none";
        dom.narratorPicker.style.display = visible ? "none" : "block";
      });
    }
    if (dom.storytellerMidrun) {
      dom.storytellerMidrun.addEventListener("change", function () {
        const presetId = dom.storytellerMidrun.value || "classic";
        const oldPreset = gameState.storytellerPresetId || "classic";
        if (presetId === oldPreset) return;
        gameState.storytellerPresetId = presetId;
        ensureStoryState().presetId = presetId;
        renderStorytellerDescription(presetId);
        const tone = presetId === "harsh"
          ? "You brace for a harsher chapter of the journey. The trail's narrator grows less forgiving."
          : "You ask for mercy from the trail. Hardships should ease a little.";
        addLog(tone, { tone: "meta" });
        saveGame();
        renderStorytellerOptions(dom.storytellerPreset, presetId);
      });
    }
    dom.btnAdvance1.addEventListener("click", function () {
      advanceHours(1);
    });
    dom.btnAdvance4.addEventListener("click", function () {
      advanceHours(4);
    });
    if (dom.btnViewJournal) {
      dom.btnViewJournal.addEventListener("click", function () {
        setTravelView("journal");
      });
    }
    if (dom.btnViewExplorer) {
      dom.btnViewExplorer.addEventListener("click", function () {
        setTravelView("explorer");
      });
    }
    dom.btnToggleMode.addEventListener("click", function () {
      gameState.mode = gameState.mode === "travel" ? "camp" : "travel";
      resetTasksForCurrentMode();
      addLog(
        gameState.mode === "travel"
          ? "You break camp and move out."
          : "You halt the wagons and make camp."
      );
      saveGame();
      renderAll();
    });
    dom.btnChangePace.addEventListener("click", function () {
      const options = ["steady", "slow", "grueling"];
      const idx = options.indexOf(gameState.pace);
      const next = options[(idx + 1) % options.length];
      gameState.pace = next;
      addLog(
        "You change the pace to " +
          PACE_CONFIG[next].label.toLowerCase() +
          "."
      );
      saveGame();
      renderAll();
    });
    dom.btnChangeRations.addEventListener("click", function () {
      const options = ["filling", "normal", "meager", "barebones"];
      const idx = options.indexOf(gameState.rations);
      const next = options[(idx + 1) % options.length];
      gameState.rations = next;
      addLog(
        "You shift the party to " +
          RATION_CONFIG[next].label.toLowerCase() +
          "."
      );
      saveGame();
      renderAll();
    });

    dom.btnOpenInventory.addEventListener("click", function () {
      renderInventoryModal();
      dom.inventoryModal.classList.add("active");
    });
    dom.btnCloseInventory.addEventListener("click", function () {
      dom.inventoryModal.classList.remove("active");
    });
    if (dom.inventoryModal) {
      dom.inventoryModal.addEventListener("click", function (e) {
        if (e.target === dom.inventoryModal || e.target === dom.modalBackdrop) {
          dom.inventoryModal.classList.remove("active");
        }
      });
    }

    if (dom.btnOpenPriorities) {
      dom.btnOpenPriorities.addEventListener("click", function () {
        renderPrioritiesModal();
        dom.prioritiesModal.classList.add("active");
      });
    }
    if (dom.btnClosePriorities) {
      dom.btnClosePriorities.addEventListener("click", function () {
        dom.prioritiesModal.classList.remove("active");
      });
    }
    if (dom.prioritiesModal) {
      dom.prioritiesModal.addEventListener("click", function (e) {
        if (
          e.target === dom.prioritiesModal ||
          e.target === dom.prioritiesBackdrop
        ) {
          dom.prioritiesModal.classList.remove("active");
        }
      });
    }

    if (dom.btnToggleMapList) {
      dom.btnToggleMapList.addEventListener("click", function () {
        gameState.mapListVisible = !gameState.mapListVisible;
        updateMapListVisibility();
        saveGame();
      });
    }

    // Evening camp macros
    if (dom.btnEveningProperCamp) {
      dom.btnEveningProperCamp.addEventListener("click", function () {
        runCampMacro(2, "proper"); // Proper camp (2 hours)
      });
    }
    if (dom.btnEveningRushedCamp) {
      dom.btnEveningRushedCamp.addEventListener("click", function () {
        runCampMacro(1, "rough"); // Rushed camp (1 hour)
      });
    }

    if (dom.btnOpenCamp && dom.campOverlay) {
      dom.btnOpenCamp.addEventListener("click", function () {
        openCampOverlay();
      });
    }
    if (dom.btnCloseCamp && dom.campOverlay) {
      dom.btnCloseCamp.addEventListener("click", closeCampOverlay);
      dom.campOverlay.addEventListener("click", function (e) {
        if (e.target === dom.campOverlay) closeCampOverlay();
      });
    }
    if (dom.btnCampConfirm) {
      dom.btnCampConfirm.addEventListener("click", confirmCampTasks);
    }
    if (dom.btnCampAuto) {
      dom.btnCampAuto.addEventListener("click", autoPlanCampTasks);
    }

    document.addEventListener("keydown", function (evt) {
      if (evt.key === "Escape") {
        hideModal(dom.inventoryModal);
        hideModal(dom.prioritiesModal);
        hideModal(dom.campOverlay);
      }

      const isExplorer =
        gameState.phase === "travel" && gameState.travelView === "explorer";
      if (!isExplorer) return;

      if (evt.key === "ArrowLeft" || evt.key === "a" || evt.key === "A") {
        gameState.traillines.laneOffset = clamp(
          (gameState.traillines.laneOffset || 0) - 0.2,
          -1,
          1
        );
        evt.preventDefault();
      } else if (
        evt.key === "ArrowRight" ||
        evt.key === "d" ||
        evt.key === "D"
      ) {
        gameState.traillines.laneOffset = clamp(
          (gameState.traillines.laneOffset || 0) + 0.2,
          -1,
          1
        );
        evt.preventDefault();
      } else if (evt.key === "v" || evt.key === "V") {
        setTravelView(
          gameState.travelView === "explorer" ? "journal" : "explorer"
        );
      }
    });

    dom.btnReset.addEventListener("click", resetGame);
  }


  /* ========= CAMP TASKS, LOG, THOUGHTS =================================== */

  function ensureCampFlags() {
    if (!gameState.flags) gameState.flags = {};
  }

  function buildCampMenuWidget() {
    const root = document.getElementById("oldtrail-camp-menu-widget");
    if (!root || root.dataset.built) return;
    root.dataset.built = "1";
    root.innerHTML =
      '<div class="cm-shell"><div class="cm-inner">' +
      '<div class="cm-header"><div class="cm-title">Camp Tasks</div><div class="cm-loc" contenteditable="true">Camp at dusk</div></div>' +
      '<div class="cm-note">Mark what your party will tend to before sleep</div>' +
      '<div class="cm-body"><div class="cm-head"><div>Task</div><div>Time</div><div>Effects</div><div>Choose</div></div><div data-role="cm-rows"></div></div>' +
      '<div class="cm-footer"><div class="cm-summary"><div class="cm-line">Hours at camp: <span data-role="cm-hours">6</span></div><div class="cm-line">Used: <span data-role="cm-hours-used">0.0</span> · Remaining: <span data-role="cm-hours-remaining" class="cm-hours-remaining">6.0</span></div><div class="cm-line">Tonight\'s focus: <span data-role="cm-focus">None yet</span></div></div><div class="cm-reset" data-role="cm-reset">Clear choices</div></div>' +
      "</div></div>";

    (function () {
      const rowsContainer = root.querySelector('[data-role="cm-rows"]');
      const hoursEl = root.querySelector('[data-role="cm-hours"]');
      const hoursUsedEl = root.querySelector('[data-role="cm-hours-used"]');
      const hoursRemainingEl = root.querySelector('[data-role="cm-hours-remaining"]');
      const focusEl = root.querySelector('[data-role="cm-focus"]');
      const resetEl = root.querySelector('[data-role="cm-reset"]');
      let hoursAvailable = 6;
      let tasks = CAMP_TASKS.map(function (t) {
        return Object.assign({}, t, { selected: false });
      });

      function describeEffects(eff) {
        const parts = [];
        if (eff.hunger) parts.push("Food");
        if (eff.thirst) parts.push("Water");
        if (eff.warmth) parts.push("Warmth");
        if (eff.energy) parts.push("Energy");
        if (eff.morale) parts.push("Morale");
        if (eff.condition) parts.push("Condition");
        if (eff.wagon) parts.push("Wagon");
        if (eff.guard) parts.push("Guard");
        return parts.length ? parts.join(", ") : "—";
      }

      function formatHours(h) {
        return (Math.round(h * 10) / 10).toFixed(1);
      }

      function renderRows() {
        rowsContainer.innerHTML = "";
        tasks.forEach(function (task) {
          const row = document.createElement("div");
          row.className = "cm-row";
          row.setAttribute("data-id", task.id);
          const nameEl = document.createElement("div");
          nameEl.className = "cm-action-name";
          nameEl.textContent = task.label;
          const timeEl = document.createElement("div");
          timeEl.className = "cm-time";
          timeEl.textContent = formatHours(task.hours) + "h";
          const effectsEl = document.createElement("div");
          effectsEl.className = "cm-effects";
          effectsEl.textContent = describeEffects(task.effects || {});
          const toggle = document.createElement("div");
          toggle.className = "cm-toggle";
          const check = document.createElement("div");
          check.className = "cm-check";
          if (task.selected) check.classList.add("cm-check-on");
          check.textContent = task.selected ? "✓" : "";
          const label = document.createElement("div");
          label.className = "cm-check-label";
          label.textContent = task.selected ? "Planned" : "Skip";
          toggle.appendChild(check);
          toggle.appendChild(label);
          toggle.addEventListener("click", function (evt) {
            evt.stopPropagation();
            task.selected = !task.selected;
            updateSummary();
            renderRows();
          });
          row.title = task.desc || "";
          row.appendChild(nameEl);
          row.appendChild(timeEl);
          row.appendChild(effectsEl);
          row.appendChild(toggle);
          rowsContainer.appendChild(row);
        });
      }

      function updateSummary() {
        let used = 0;
        const totals = { food: 0, warmth: 0, morale: 0, rest: 0 };
        tasks.forEach(function (task) {
          if (!task.selected) return;
          used += task.hours;
          const e = task.effects || {};
          if (e.hunger) totals.food += e.hunger;
          if (e.thirst) totals.food += e.thirst;
          if (e.warmth) totals.warmth += e.warmth;
          if (e.morale) totals.morale += e.morale;
          if (e.energy || e.condition) totals.rest += (e.energy || 0) + (e.condition || 0);
        });
        hoursUsedEl.textContent = formatHours(used);
        const remaining = hoursAvailable - used;
        hoursRemainingEl.textContent = formatHours(remaining);
        hoursRemainingEl.classList.toggle("cm-warning", remaining < -0.01);
        const maxVal = Math.max(totals.food, totals.warmth, totals.morale, totals.rest);
        if (maxVal <= 0) {
          focusEl.textContent = "None yet";
        } else {
          const focusParts = [];
          if (totals.food === maxVal) focusParts.push("Food/Water");
          if (totals.warmth === maxVal) focusParts.push("Warmth");
          if (totals.morale === maxVal) focusParts.push("Morale");
          if (totals.rest === maxVal) focusParts.push("Rest");
          focusEl.textContent = focusParts.join(", ");
        }
      }

      resetEl.addEventListener("click", function (evt) {
        evt.stopPropagation();
        tasks.forEach(function (t) {
          t.selected = false;
        });
        updateSummary();
        renderRows();
      });

      function setTasks(list) {
        if (!Array.isArray(list)) return;
        tasks = list.map(function (t) {
          return Object.assign({}, t);
        });
        renderRows();
        updateSummary();
      }

      window.oldTrailCampMenu = {
        setHours: function (h) {
          hoursAvailable = Math.max(0, Number(h) || 0);
          hoursEl.textContent = formatHours(hoursAvailable);
          updateSummary();
        },
        setTasks: setTasks,
        getPlan: function () {
          const selected = tasks.filter(function (t) {
            return t.selected;
          });
          let used = 0;
          selected.forEach(function (t) {
            used += t.hours;
          });
          return {
            hoursAvailable: hoursAvailable,
            hoursUsed: used,
            hoursRemaining: hoursAvailable - used,
            tasks: selected,
          };
        },
      };

      hoursEl.textContent = formatHours(hoursAvailable);
      renderRows();
      updateSummary();
    })();
  }

  function buildCraftingWidget() {
    const root = document.getElementById("oldtrail-crafting-widget");
    if (!root || root.dataset.built) return;
    root.dataset.built = "1";
    root.innerHTML =
      '<div class="ot-craft-header"><span>Crafting</span><select id="ot-craft-select" class="ot-select" style="flex:1"></select></div>' +
      '<div class="ot-craft-grid" id="ot-craft-grid"></div>' +
      '<div class="ot-craft-output" id="ot-craft-output">—</div>' +
      '<div class="ot-craft-status" id="ot-craft-status">Choose a recipe</div>' +
      '<div style="margin-top:6px; display:flex; gap:6px; align-items:center">' +
      '<button class="ot-btn-gold" id="ot-btn-craft-do">Craft</button>' +
      '<div id="ot-craft-req" class="ot-text-muted" style="font-size:11px"></div>' +
      "</div>";

    const grid = root.querySelector("#ot-craft-grid");
    const select = root.querySelector("#ot-craft-select");
    const statusEl = root.querySelector("#ot-craft-status");
    const outputEl = root.querySelector("#ot-craft-output");
    const reqEl = root.querySelector("#ot-craft-req");
    const craftBtn = root.querySelector("#ot-btn-craft-do");

    const cells = [];
    for (let i = 0; i < 9; i++) {
      const cell = document.createElement("div");
      cell.className = "ot-craft-cell";
      grid.appendChild(cell);
      cells.push(cell);
    }
    const arrow = document.createElement("div");
    arrow.textContent = "➜";
    arrow.style.textAlign = "center";
    arrow.style.color = "#f7cf7f";
    grid.appendChild(arrow);
    const spacer = document.createElement("div");
    spacer.style.display = "none";
    grid.appendChild(spacer);

    function renderSelect() {
      select.innerHTML = "";
      CRAFTING_RECIPES.forEach(function (rec) {
        const opt = document.createElement("option");
        opt.value = rec.id;
        opt.textContent = rec.name;
        select.appendChild(opt);
      });
    }

    function setPattern(pattern) {
      const p = pattern || "";
      for (let i = 0; i < cells.length; i++) {
        const on = p.charAt(i) === "1";
        cells[i].style.background = on
          ? "linear-gradient(135deg, rgba(247,207,127,0.25), rgba(240,183,91,0.15))"
          : "rgba(255,255,255,0.06)";
        cells[i].style.borderColor = on
          ? "rgba(247,207,127,0.45)"
          : "rgba(255,255,255,0.08)";
      }
    }

    function setOutput(label, iconText) {
      outputEl.textContent = iconText || label || "—";
    }

    function setStatus(text) {
      statusEl.textContent = text || "";
    }

    function renderRecipeRequirements(rec) {
      if (!rec) {
        reqEl.textContent = "";
        return;
      }
      const need = rec.inputs
        .map(function (i) {
          const have = gameState.supplies[i.key] || 0;
          return i.amount + " " + i.key + " (" + have + " on hand)";
        })
        .join(", ");
      reqEl.textContent = "Requires: " + need;
    }

    function currentRecipe() {
      const recId = select.value;
      return CRAFTING_RECIPES.find(function (r) {
        return r.id === recId;
      });
    }

    function craftRecipe() {
      const rec = currentRecipe();
      if (!rec) return;
      for (let i = 0; i < rec.inputs.length; i++) {
        const need = rec.inputs[i];
        const have = gameState.supplies[need.key] || 0;
        if (have < need.amount) {
          setStatus("Not enough " + need.key + " to craft.");
          return;
        }
      }
      rec.inputs.forEach(function (inp) {
        gameState.supplies[inp.key] = (gameState.supplies[inp.key] || 0) - inp.amount;
      });
      gameState.supplies[rec.output.key] =
        (gameState.supplies[rec.output.key] || 0) + rec.output.amount;
      setStatus("Crafted " + rec.output.amount + " " + rec.name + ".");
      addLog("Crafted " + rec.name + " at camp.", { tone: "event" });
      renderSupplies();
      renderRecipeRequirements(rec);
    }

    select.addEventListener("change", function () {
      const rec = currentRecipe();
      if (!rec) return;
      setPattern(rec.pattern);
      setOutput(rec.icon || rec.name, rec.icon || rec.name);
      setStatus(rec.desc);
      renderRecipeRequirements(rec);
    });
    craftBtn.addEventListener("click", craftRecipe);

    window.oldTrailCrafting = {
      setPattern: setPattern,
      setOutput: setOutput,
      setStatus: setStatus,
      clearGrid: function () {
        setPattern("000000000");
        setOutput("—");
      },
    };

    renderSelect();
    if (CRAFTING_RECIPES.length) {
      select.value = CRAFTING_RECIPES[0].id;
      select.dispatchEvent(new Event("change"));
    }
  }

  function openCampOverlay() {
    buildCampMenuWidget();
    buildCraftingWidget();
    if (window.oldTrailCampMenu) {
      oldTrailCampMenu.setHours(6);
      oldTrailCampMenu.setTasks(
        CAMP_TASKS.map(function (t) {
          return Object.assign({}, t, { selected: false });
        })
      );
    }
    if (dom.campOverlay) dom.campOverlay.classList.add("ot-show");
    dom.campOverlay.classList.add("ot-show");
  }

  function closeCampOverlay() {
    if (dom.campOverlay) dom.campOverlay.classList.remove("ot-show");
  }

  function applyCampTasks(plan) {
    if (!plan || !plan.tasks || !plan.tasks.length) return;
    ensureCampFlags();
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    plan.tasks.forEach(function (task) {
      const eff = task.effects || {};
      people.forEach(function (p) {
        if (eff.hunger) adjustPersonStat(p, "hunger", eff.hunger);
        if (eff.thirst) adjustPersonStat(p, "thirst", eff.thirst);
        if (eff.warmth) adjustPersonStat(p, "warmth", eff.warmth);
        if (eff.morale) adjustPersonStat(p, "morale", eff.morale);
        if (eff.energy) adjustPersonStat(p, "energy", eff.energy);
        if (eff.condition) adjustPersonStat(p, "condition", eff.condition);
      });
      if (eff.wagon) {
        gameState.wagonCondition = clamp(
          (gameState.wagonCondition || 0) + eff.wagon,
          0,
          120
        );
      }
      if (eff.guard) {
        gameState.guardLevel += eff.guard;
        gameState.flags.stoodGuard = true;
      }
      if (eff.supplies) {
        Object.keys(eff.supplies).forEach(function (k) {
          gameState.supplies[k] = (gameState.supplies[k] || 0) + eff.supplies[k];
        });
      }
    });
    const hours = Math.max(1, Math.round(plan.hoursUsed));
    advanceHours(hours, { campQuality: plan.hoursUsed >= 2 ? "proper" : "rough" });
    addLog(
      "Camp chores complete: " +
        plan.tasks
          .map(function (t) {
            return t.label;
          })
          .join(", ") +
        ".",
      { tone: "event" }
    );
  }

  function autoSelectCampTasks(gameState) {
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    const avgHunger =
      people.reduce(function (sum, p) {
        return sum + p.hunger;
      }, 0) / (people.length || 1);
    const avgThirst =
      people.reduce(function (sum, p) {
        return sum + p.thirst;
      }, 0) / (people.length || 1);
    const avgEnergy =
      people.reduce(function (sum, p) {
        return sum + p.energy;
      }, 0) / (people.length || 1);

    let hours = 6;
    const picks = [];
    function tryAdd(id) {
      const t = CAMP_TASKS.find(function (x) {
        return x.id === id;
      });
      if (t && hours - t.hours >= -1) {
        hours -= t.hours;
        picks.push(Object.assign({}, t, { selected: true }));
      }
    }

    if (avgThirst < 70) tryAdd("fetch_and_boil_water");
    if (avgHunger < 70) tryAdd("cook_hot_meal");
    if (gameState.wagonCondition < 70) tryAdd("repair_wagon_and_tackle");
    if (avgEnergy < 60) tryAdd("extra_sleep");
    tryAdd("gather_fuel");
    if (picks.length === 0) tryAdd("read_book");

    return CAMP_TASKS.map(function (t) {
      const found = picks.find(function (p) {
        return p.id === t.id;
      });
      return Object.assign({}, t, { selected: !!found });
    });
  }

  function autoPlanCampTasks() {
    if (!window.oldTrailCampMenu) return;
    const tasks = autoSelectCampTasks(gameState);
    oldTrailCampMenu.setTasks(tasks);
    dom.campSummaryNote.textContent = "Auto-selected chores based on needs.";
  }

  function confirmCampTasks() {
    if (!window.oldTrailCampMenu) return;
    const plan = oldTrailCampMenu.getPlan();
    if (!plan.tasks.length) {
      dom.campSummaryNote.textContent = "No chores selected.";
      return;
    }
    applyCampTasks(plan);
    closeCampOverlay();
    renderAll();
  }

  function initTrailLogWidget() {
    const root = document.getElementById("old-trail-log-widget");
    if (!root || window.ksOldTrailLog) return;
    const listEl = root.querySelector(".ot-log-list");
    const maxEntries = 6;
    let queue = [];
    let typing = false;

    function createEntry(message) {
      const entry = document.createElement("div");
      entry.className = "ot-log-entry";
      if (message.tone === "event") entry.classList.add("ot-entry-event");
      if (message.tone === "warning") entry.classList.add("ot-entry-warning");
      if (message.tone === "morale") entry.classList.add("ot-entry-morale");
      const metaRow = document.createElement("div");
      metaRow.className = "ot-log-meta";
      const tag = document.createElement("span");
      tag.className = "ot-log-tag";
      tag.textContent = message.tag || "DAY " + (message.day || "0");
      const loc = document.createElement("span");
      loc.className = "ot-log-location";
      loc.textContent = message.location || "On the trail";
      metaRow.appendChild(tag);
      metaRow.appendChild(loc);
      const text = document.createElement("div");
      text.className = "ot-log-text";
      entry.appendChild(metaRow);
      entry.appendChild(text);
      const previousActive = listEl.querySelector(".ot-entry-active");
      if (previousActive) previousActive.classList.remove("ot-entry-active");
      entry.classList.add("ot-entry-active");
      listEl.appendChild(entry);
      while (listEl.children.length > maxEntries) {
        listEl.removeChild(listEl.firstChild);
      }
      requestAnimationFrame(function () {
        entry.classList.add("ot-entry-in");
      });
      return entry;
    }

    function typeText(entry, text, done) {
      const textEl = entry.querySelector(".ot-log-text");
      if (!textEl) return;
      textEl.textContent = "";
      const cursor = document.createElement("span");
      cursor.className = "ot-cursor";
      cursor.textContent = "▌";
      textEl.appendChild(cursor);
      let index = 0;
      function step() {
        if (index >= text.length) {
          cursor.classList.add("ot-cursor-done");
          setTimeout(function () {
            if (cursor.parentNode) cursor.parentNode.removeChild(cursor);
          }, 200);
          if (done) done();
          return;
        }
        const ch = text.charAt(index);
        const node = document.createTextNode(ch);
        textEl.insertBefore(node, cursor);
        index += 1;
        let delay = 18;
        if (",.;!?".indexOf(ch) >= 0) delay = 120;
        setTimeout(step, delay);
      }
      step();
    }

    function processQueue() {
      if (!queue.length) {
        typing = false;
        return;
      }
      typing = true;
      const message = queue.shift();
      const entry = createEntry(message);
      typeText(entry, message.text, function () {
        typing = false;
        processQueue();
      });
    }

    function addMessage(text, meta) {
      queue.push({
        text: text,
        tag: meta && meta.tag,
        location: meta && meta.location,
        tone: meta && meta.tone,
        day: meta && meta.day,
      });
      if (!typing) processQueue();
    }

    function clearAll() {
      queue = [];
      typing = false;
      while (listEl.firstChild) listEl.removeChild(listEl.firstChild);
    }

    window.ksOldTrailLog = { add: addMessage, clear: clearAll };
  }

  let thoughtIndex = 0;
  function initThoughtBubble() {
    if (window.oldTrailThoughts) return;
    const root = document.getElementById("oldtrail-thoughts-bubble");
    if (!root) {
      window.oldTrailThoughts = { show: function () {} };
      return;
    }
    const nameEl = root.querySelector(".tb-name");
    const textEl = root.querySelector(".tb-text");
    const fillEl = root.querySelector(".tb-mood-fill");
    const labelEl = root.querySelector(".tb-mood-label");
    const closeEl = root.querySelector(".tb-close");
    function moodColor(m) {
      if (m < 0.35) return "linear-gradient(90deg,#b81d13,#f4876c)";
      if (m < 0.7) return "linear-gradient(90deg,#f2a71b,#ffd966)";
      return "linear-gradient(90deg,#0b9444,#41d95b)";
    }
    function show(companion, mood0to1, text) {
      if (!companion) return;
      root.style.display = "block";
      nameEl.textContent = companion.name;
      textEl.textContent = '"' + text + '"';
      fillEl.style.width = Math.round(Math.max(0, Math.min(1, mood0to1)) * 100) + "%";
      fillEl.style.backgroundImage = moodColor(mood0to1);
      labelEl.textContent = companion.moodState || (mood0to1 > 0.66
        ? "Upbeat"
        : mood0to1 > 0.35
        ? "Uneasy"
        : "Worn");
    }
    function hide() {
      root.style.display = "none";
    }
    root.addEventListener("click", hide);
    if (closeEl) closeEl.addEventListener("click", hide);
    window.oldTrailThoughts = { show: show };
  }

  function companionThoughtLine(person) {
    if (!person) return "";
    const risk = (gameState.storyState && gameState.storyState.risk) || {};
    if (person.moodState === "Broken")
      return "I don't know how much longer I can keep this up.";
    if (risk.water_shortage) return "We need good water soon or trouble will find us.";
    if (risk.starvation) return "Meals are thin; a hearty supper would lift spirits.";
    if (risk.cold_exposure) return "My fingers still feel numb from the cold.";
    if (person.hunger < 40) return "I could use a warm meal.";
    if (person.thirst < 40) return "Water skins feel light; hope the next creek runs clear.";
    if (person.energy < 35) return "My legs ache; a long rest would do me good.";
    if (person.moodState === "Upbeat")
      return "The sky tonight almost makes me forget the miles.";
    if (gameState.highRiverRisk)
      return "The rivers run high—we must take care at crossings.";
    return "Quietly watching the firelight dance on the wagon hoops.";
  }

  function showCompanionThoughtForHour() {
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    if (!people.length || !window.oldTrailThoughts) return;
    const p = people[thoughtIndex % people.length];
    thoughtIndex += 1;
    const mood = clamp((p.morale || 50) / 100, 0, 1);
    const line = companionThoughtLine(p);
    window.oldTrailThoughts.show(p, mood, line);
  }

  /* ========= BOOTSTRAP ===================================================== */

  function init() {
    initDom();
    initTrailLogWidget();
    initThoughtBubble();
    wireEvents();

    const loaded = loadGame();
    if (!loaded || !gameState.leader) {
      const bgId = dom.backgroundSelect.value;
      const bg = BACKGROUNDS[bgId] || BACKGROUNDS.farmer;
      dom.backgroundDesc.textContent = bg.desc;
      renderDepartureSeasonDesc();
      updateStartArt();
      showScreen("start");
    } else {
      if (gameState.phase === "outfit") {
        buildOutfitTable();
        updateOutfitIntro();
        updateOutfitArt();
        showScreen("outfit");
      } else {
        showScreen("travel");
      }
    }

    if (gameState.phase === "outfit") {
      buildOutfitTable();
    }
    renderAll();
  }

  init();
})();
</script>
