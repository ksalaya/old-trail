<style>
/* ==== OLD TRAIL – UI SHELL ================================================= */

.ot-root {
  font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", system-ui,
    -sans-serif;
  background: radial-gradient(circle at top, #202737 0, #050509 55%, #020104 100%);
  color: #f6f3ea;
  padding: 24px 24px 32px;
  box-sizing: border-box;
  max-width: 1200px;
  margin: 0 auto;
  border-radius: 18px;
  box-shadow: 0 24px 80px rgba(0, 0, 0, 0.85);
  position: relative;
}

.ot-root * {
  box-sizing: border-box;
}

.ot-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.ot-title-block {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.ot-title {
  letter-spacing: 0.3em;
  text-transform: uppercase;
  font-size: 13px;
  color: #f5d28b;
}

.ot-subtitle {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.18em;
  color: #b6b3ac;
}

.ot-header-right {
  display: flex;
  gap: 8px;
  align-items: center;
}

.ot-pill {
  border-radius: 999px;
  padding: 6px 14px;
  font-size: 11px;
  border: 1px solid rgba(245, 210, 139, 0.35);
  background: radial-gradient(circle at top, #604321, #2b1a0f);
  color: #f6f3ea;
  text-transform: uppercase;
  letter-spacing: 0.13em;
  white-space: nowrap;
}

.ot-pill-danger {
  background: radial-gradient(circle at top, #5b1818, #2b0c0c);
  border-color: rgba(255, 121, 121, 0.6);
}

/* ==== PANELS & LAYOUT ====================================================== */

.ot-screen {
  display: none;
}

.ot-screen-active {
  display: block;
}

.ot-screen-grid {
  display: grid;
  grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
  gap: 18px;
}

.ot-screen-travel {
  grid-template-columns: minmax(0, 1.25fr) minmax(0, 0.95fr);
}

.ot-panel {
  background: radial-gradient(circle at top left, #252838, #090910);
  border-radius: 14px;
  padding: 12px 14px 12px;
  border: 1px solid rgba(255, 255, 255, 0.04);
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.55);
  margin-bottom: 10px;
}

.ot-panel-header {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.16em;
  color: #b9b6ae;
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.ot-panel-body {
  font-size: 12px;
  color: #f4f1ea;
}

.ot-panel-body-sm {
  font-size: 11px;
}

/* ==== FORM ELEMENTS ======================================================== */

.ot-field {
  margin-bottom: 10px;
}

.ot-label {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: #b6b3ac;
  margin-bottom: 4px;
}

.ot-input,
.ot-select {
  width: 100%;
  padding: 8px 10px;
  font-size: 13px;
  border-radius: 9px;
  border: 1px solid rgba(255, 255, 255, 0.12);
  background: rgba(3, 3, 6, 0.9);
  color: #f6f3ea;
}

.ot-input::placeholder {
  color: #77746b;
}

.ot-input:focus,
.ot-select:focus {
  outline: none;
  border-color: rgba(245, 210, 139, 0.8);
  box-shadow: 0 0 0 1px rgba(245, 210, 139, 0.4);
}

.ot-draft-row {
  margin-bottom: 8px;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.06);
  padding: 8px;
  border-radius: 10px;
}

.ot-draft-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 6px;
  font-size: 11px;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  color: #cfc8b6;
}

.ot-draft-controls {
  display: flex;
  gap: 6px;
  align-items: center;
}

.ot-mini-btn {
  font-size: 11px;
  border: 1px solid rgba(245, 210, 139, 0.5);
  background: rgba(247, 207, 127, 0.12);
  color: #f6f3ea;
  padding: 4px 8px;
  border-radius: 8px;
  cursor: pointer;
}

.ot-mini-btn:disabled {
  opacity: 0.45;
  cursor: default;
}

.ot-draft-lock {
  color: #f5d28b;
}

.ot-draft-info {
  font-size: 11px;
  color: #dcd6c7;
  line-height: 1.5;
}

.ot-draft-skills {
  font-size: 11px;
  color: #b8b2a7;
  margin-top: 4px;
}

.ot-draft-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-top: 4px;
}

.ot-draft-tag {
  background: rgba(255, 255, 255, 0.07);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 999px;
  padding: 2px 8px;
  font-size: 10px;
  color: #f6f3ea;
}

.ot-social-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 10px;
}

.ot-social-card {
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 10px;
  padding: 8px;
  background: rgba(0, 0, 0, 0.35);
  font-size: 11px;
}

.ot-social-label {
  font-weight: bold;
  margin-bottom: 4px;
  color: #f5d28b;
}

.ot-social-row {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  color: #dcd6c7;
}

.ot-narrator-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}

.ot-narrator-picker select {
  width: 100%;
}

.ot-preset-cards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 10px;
}

.ot-preset-card {
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 12px;
  background: rgba(10, 10, 16, 0.8);
  cursor: pointer;
  transition: border-color 0.12s ease, transform 0.12s ease, box-shadow 0.12s ease;
  display: grid;
  grid-template-columns: 48px 1fr;
  gap: 8px;
  min-height: 86px;
  position: relative;
}

.ot-preset-card:hover,
.ot-preset-card:focus {
  border-color: rgba(245, 210, 139, 0.65);
  transform: translateY(-1px);
  outline: none;
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
}

.ot-preset-card.ot-selected {
  border-color: rgba(245, 210, 139, 0.95);
  box-shadow: 0 0 0 1px rgba(245, 210, 139, 0.3), 0 8px 22px rgba(0, 0, 0, 0.45);
}

.ot-preset-icon {
  font-size: 18px;
  color: #f4d68e;
  width: 46px;
  height: 46px;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(247, 207, 127, 0.12);
  border: 1px solid rgba(247, 207, 127, 0.3);
}

.ot-preset-icon.ot-preset-icon--quill::after {
  content: "✒";
}

.ot-preset-icon.ot-preset-icon--balanced::after {
  content: "⚖";
}

.ot-preset-icon.ot-preset-icon--skull::after {
  content: "☠";
}

.ot-preset-icon.ot-preset-icon--storm::after {
  content: "✶";
}

.ot-preset-icon.ot-preset-icon--trail::after {
  content: "⇢";
}

.ot-preset-tagline {
  color: #b6b3ac;
  font-size: 11px;
  margin-top: 4px;
}

.ot-preset-example {
  margin-top: 8px;
  padding: 8px;
  border-radius: 8px;
  background: rgba(255, 255, 255, 0.04);
  font-size: 11px;
  color: #dcd8ce;
  min-height: 32px;
}

.ot-preset-card .ot-preset-meta {
  font-size: 11px;
  color: #cfc7b5;
  margin-top: 4px;
}

.ot-preset-detail {
  display: none;
  background: rgba(0, 0, 0, 0.35);
  border: 1px solid rgba(255, 255, 255, 0.06);
  padding: 8px;
  border-radius: 8px;
  font-size: 11px;
  line-height: 1.5;
  margin-top: 6px;
}

.ot-preset-card:hover .ot-preset-detail,
.ot-preset-card:focus .ot-preset-detail,
.ot-preset-card.ot-show-detail .ot-preset-detail {
  display: block;
}

.ot-preset-detail .ot-preset-detail-title {
  font-weight: 600;
  margin-bottom: 4px;
}

.ot-preset-detail ul {
  margin: 4px 0 0 16px;
  padding: 0;
}

.ot-preset-detail li {
  margin-bottom: 4px;
}

.ot-preset-pacing {
  font-size: 11px;
  color: #d6d3cc;
  margin-top: 4px;
  line-height: 1.35;
}

@media (max-width: 760px) {
  .ot-preset-cards {
    grid-template-columns: 1fr;
  }
  .ot-preset-card {
    grid-template-columns: 56px 1fr;
  }
  .ot-preset-card .ot-preset-detail {
    display: none;
  }
}

@media (min-width: 980px) {
  .ot-preset-cards {
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  }
}

/* ==== BUTTONS ============================================================== */

.ot-btn,
.ot-btn-outline,
.ot-btn-gold,
.ot-link-button {
  border-radius: 999px;
  padding: 8px 14px;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.16em;
  border: none;
  cursor: pointer;
  transition: all 0.12s ease-out;
  white-space: nowrap;
}

.ot-btn-gold {
  background: linear-gradient(90deg, #f7cf7f, #f0b75b);
  color: #2d1b09;
  box-shadow: 0 5px 16px rgba(0, 0, 0, 0.55);
}

.ot-btn-gold:hover {
  filter: brightness(1.06);
  transform: translateY(-1px);
}

.ot-btn-outline {
  background: transparent;
  border: 1px solid rgba(246, 238, 203, 0.45);
  color: #f4e9d4;
}

.ot-btn-outline:hover {
  background: rgba(246, 238, 203, 0.08);
}

.ot-btn[disabled],
.ot-btn-gold[disabled],
.ot-btn-outline[disabled] {
  opacity: 0.4;
  cursor: default;
  transform: none;
  box-shadow: none;
}

.ot-link-button {
  background: transparent;
  border: none;
  color: #f3cf84;
  padding: 4px 8px;
  font-size: 10px;
}

.ot-link-button:hover {
  text-decoration: underline;
}

/* ==== START SCREEN ========================================================= */

.ot-start-grid {
  grid-template-columns: minmax(0, 1.05fr) minmax(0, 1.1fr);
}

.ot-start-art {
  border-radius: 14px;
  min-height: 220px;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  margin-top: 10px;
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.7);
  border: 1px solid rgba(255, 255, 255, 0.06);
}

/* ==== OUTFITTING =========================================================== */

.ot-outfit-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}

.ot-outfit-table th,
.ot-outfit-table td {
  padding: 4px 4px;
  text-align: left;
  border-bottom: 1px solid rgba(255, 255, 255, 0.03);
}

.ot-outfit-table th {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.14em;
  color: #b6b3ac;
}

.ot-outfit-qty {
  width: 64px;
  padding: 5px 6px;
  border-radius: 7px;
  border: 1px solid rgba(255, 255, 255, 0.16);
  background: rgba(4, 4, 8, 0.93);
  color: #f6f3ea;
  font-size: 12px;
}

.ot-outfit-summary-row {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  margin-bottom: 3px;
}

.ot-text-muted {
  color: #a49f97;
}

.ot-text-warning {
  color: #ffce7d;
}

/* ==== TRAVEL SCREEN ======================================================== */

.ot-travel-scene-wrapper {
  position: relative;
  border-radius: 16px;
  overflow: hidden;
  margin-bottom: 12px;
  border: 1px solid rgba(255, 255, 255, 0.06);
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.75);
  min-height: 240px;
}

.ot-travel-main,
.ot-travel-side {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.ot-panel-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  margin-left: auto;
}

.ot-travel-view-toggle {
  display: inline-flex;
  gap: 4px;
  font-size: 10px;
}

.ot-view-toggle-btn {
  border-radius: 999px;
  border: 1px solid rgba(255, 255, 255, 0.25);
  padding: 3px 8px;
  background: rgba(10, 10, 16, 0.8);
  color: #f5ead2;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  font-size: 9px;
  opacity: 0.78;
  cursor: pointer;
}

.ot-view-toggle-btn-active {
  background: radial-gradient(circle at top, #f5cf8b, #f0b463);
  color: #291608;
  opacity: 1;
}

.ot-map-launch {
  padding: 6px 12px;
}

.ot-trail-canvas {
  display: block;
  width: 100%;
  height: 260px;
  image-rendering: crisp-edges;
  image-rendering: pixelated;
}

.ot-explorer-chip {
  position: absolute;
  top: 12px;
  left: 12px;
  z-index: 6;
  background: rgba(6, 8, 12, 0.78);
  border: 1px solid rgba(255, 255, 255, 0.18);
  border-radius: 10px;
  padding: 8px 10px;
  font-size: 11px;
  color: #f4efe3;
  box-shadow: 0 8px 18px rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(3px);
}

.ot-explorer-chip div + div {
  margin-top: 2px;
  color: #cfc7b8;
}

/* View mode visibility helpers */
.ot-view-mode-journal #ot-trail-canvas {
  display: none;
}

.ot-view-mode-explorer #ot-scene,
.ot-view-mode-explorer #ot-scene-caption {
  display: none;
}

.ot-screen-travel.ot-view-mode-explorer {
  grid-template-columns: 1fr;
}

.ot-screen-travel.ot-view-mode-explorer .ot-travel-side {
  display: none;
}

.ot-screen-travel.ot-view-mode-explorer #ot-trail-canvas {
  height: auto;
  aspect-ratio: 3 / 2;
  max-height: 700px;
}

/* Temporal viewport overlays (scene + map) */

.ot-viewport-window {
  position: relative;
  overflow: hidden;
}

.ot-viewport-window::before {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  mix-blend-mode: screen;
  background:
    radial-gradient(circle at 20% 0%, rgba(255, 255, 255, 0.24), transparent 55%),
    radial-gradient(circle at 80% 0%, rgba(255, 255, 255, 0.18), transparent 60%),
    linear-gradient(to bottom, rgba(7, 10, 18, 0.9), transparent 40%, transparent 60%, rgba(0, 0, 0, 0.95)),
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.16) 0px,
      rgba(255, 255, 255, 0.04) 1px,
      rgba(0, 0, 0, 0) 2px,
      rgba(0, 0, 0, 0) 4px
    );
  opacity: 0.9;
  filter: saturate(1.06) contrast(1.04);
  z-index: 1;
}

.ot-viewport-window::after {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  box-shadow:
    inset 0 10px 40px rgba(0, 0, 0, 0.86),
    inset 0 -24px 46px rgba(0, 0, 0, 0.92),
    inset 18px 0 36px rgba(0, 0, 0, 0.88),
    inset -18px 0 36px rgba(0, 0, 0, 0.88);
  background:
    radial-gradient(circle at 22% 50%, rgba(255, 40, 0, 0.12), transparent 60%),
    radial-gradient(circle at 78% 50%, rgba(0, 210, 255, 0.12), transparent 60%);
  mix-blend-mode: soft-light;
  opacity: 0.9;
  z-index: 2;
}

.ot-travel-scene {
  min-height: 170px;
  background-size: cover;
  background-position: center;
  position: relative;
  z-index: 0;
}

.ot-travel-scene-overlay {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 10px 12px;
  background: linear-gradient(to top, rgba(0, 0, 0, 0.75), transparent);
  font-size: 11px;
  z-index: 5;
}

.ot-affliction-alerts {
  position: absolute;
  top: 8px;
  right: 10px;
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  z-index: 6;
}

.ot-affliction-pill {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px;
  border-radius: 999px;
  background: rgba(160, 48, 48, 0.85);
  color: #fff;
  font-size: 11px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.35);
}

.ot-affliction-pill.severe {
  background: rgba(191, 39, 39, 0.9);
}

.ot-affliction-pill.moderate {
  background: rgba(194, 106, 47, 0.9);
}

.ot-bar-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 8px;
}

.ot-bar-label {
  font-size: 11px;
  color: #c4beb4;
  min-width: 86px;
}

.ot-bar-shell {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
}

.ot-bar {
  flex: 1;
  height: 10px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.06);
  overflow: hidden;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.ot-bar-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, #f6d48a, #f0b75b);
  width: 50%;
}

.ot-bar-fill.cold {
  background: linear-gradient(90deg, #9fd8ff, #6eb0ff);
}

.ot-bar-fill.bad {
  background: linear-gradient(90deg, #ff7c7c, #dd3a3a);
}

.ot-bar-value {
  font-size: 11px;
  min-width: 40px;
  text-align: right;
  color: #f6f3ea;
}

.ot-manifest-meter {
  display: flex;
  align-items: center;
  gap: 8px;
  min-width: 120px;
  margin-left: 8px;
}

.ot-manifest-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 3px 2px;
  border-radius: 6px;
  cursor: pointer;
}

.ot-manifest-row:hover {
  background: rgba(255, 255, 255, 0.04);
}

.ot-manifest-name {
  font-size: 12px;
}

.ot-manifest-suspect {
  display: inline-block;
  margin-left: 6px;
  padding: 1px 6px;
  border-radius: 8px;
  background: rgba(255, 210, 139, 0.08);
  color: #f5d28b;
  font-size: 10px;
  letter-spacing: 0.08em;
}

.ot-manifest-role {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.16em;
  color: #9b968d;
}

.ot-manifest-selected {
  background: linear-gradient(90deg, rgba(247, 209, 128, 0.12), transparent);
}

.ot-tasks-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}

.ot-tasks-table td {
  padding: 3px 2px;
}

.ot-task-select {
  width: 100%;
  padding: 4px 10px 4px 8px;
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.16);
  background: rgba(5, 5, 10, 0.92);
  color: #f4f1ea;
  font-size: 11px;
}

/* Trail map */

.ot-map-viewport {
  margin-bottom: 8px;
  border-radius: 14px;
  border: 1px solid rgba(255, 255, 255, 0.07);
  box-shadow: 0 16px 44px rgba(0, 0, 0, 0.72);
  min-height: 200px;
  background: radial-gradient(circle at top, #182029, #0a0f16);
  position: relative;
  overflow: hidden;
}

.ot-map-tooltip {
  position: absolute;
  pointer-events: none;
  background: rgba(14, 19, 26, 0.92);
  color: #f6f3ea;
  padding: 6px 8px;
  border-radius: 8px;
  border: 1px solid rgba(245, 210, 139, 0.3);
  font-size: 11px;
  box-shadow: 0 12px 28px rgba(0, 0, 0, 0.45);
  z-index: 5;
  transform: translate(-50%, -100%);
}

.ot-explorer-tooltip {
  pointer-events: auto;
  max-width: 240px;
  line-height: 1.4;
  box-shadow: 0 16px 36px rgba(0, 0, 0, 0.55);
  backdrop-filter: blur(3px);
}

.ot-explorer-tooltip header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 6px;
  font-weight: 600;
  margin-bottom: 4px;
}

.ot-explorer-tooltip button {
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: #f7f2e6;
  border-radius: 6px;
  padding: 2px 6px;
  font-size: 11px;
  cursor: pointer;
}

.ot-explorer-controls {
  display: flex;
  gap: 6px;
  margin-top: 6px;
  flex-wrap: wrap;
}

.ot-explorer-controls .ot-mini-btn {
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.24);
  background: rgba(8, 10, 14, 0.65);
  color: #f6f0e4;
  padding: 4px 8px;
  font-size: 10px;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  cursor: pointer;
}

.ot-explorer-controls .ot-mini-btn.ot-active {
  background: radial-gradient(circle at top, #f4c982, #e5a95c);
  color: #291608;
  border-color: rgba(255, 255, 255, 0.4);
}

.ot-map-controls {
  display: grid;
  grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
  gap: 10px;
  margin-top: 8px;
  padding: 10px 12px;
  border-radius: 12px;
  background: rgba(6, 8, 12, 0.85);
  border: 1px solid rgba(255, 255, 255, 0.05);
}

.ot-map-toggle-row {
  display: flex;
  gap: 10px;
  align-items: center;
  flex-wrap: wrap;
  font-size: 11px;
}

.ot-map-target-block {
  background: radial-gradient(circle at top, #1e2632, #0f141c);
  border: 1px solid rgba(245, 210, 139, 0.16);
  border-radius: 10px;
  padding: 10px 12px;
}

.ot-map-target-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 12px;
  margin-bottom: 6px;
}

.ot-map-target-meta {
  font-size: 11px;
  color: #c7c4bc;
  margin-bottom: 8px;
}

.ot-map-conditions {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 4px 8px;
  font-size: 10px;
  color: #c7c4bc;
  margin-bottom: 8px;
}

.ot-map-conditions .label {
  color: #9fb8c6;
}

.ot-map-target-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.ot-map-canvas,
.ot-overview-canvas {
  width: 100%;
  height: 100%;
  display: block;
}

.ot-map-hint {
  position: absolute;
  bottom: 8px;
  right: 8px;
  background: rgba(0, 0, 0, 0.35);
  color: #d8d3c5;
  padding: 6px 8px;
  border-radius: 8px;
  font-size: 10px;
  letter-spacing: 0.06em;
}

.ot-trail-map {
  font-size: 11px;
  line-height: 1.4;
}

.ot-trail-dot-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 3px;
}

.ot-trail-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  border: 1px solid rgba(244, 220, 170, 0.7);
  background: transparent;
}

.ot-trail-dot-current {
  background: #f5d28b;
}

.ot-trail-dot-seen {
  background: rgba(245, 210, 139, 0.5);
  box-shadow: 0 0 0 1px rgba(245, 210, 139, 0.12);
}

.ot-map-modal-grid {
  display: grid;
  grid-template-columns: minmax(0, 1.15fr) minmax(0, 0.9fr);
  gap: 12px;
  align-items: start;
}

.ot-map-modal-content {
  max-width: 880px;
}

@media (max-width: 760px) {
  .ot-map-modal-grid {
    grid-template-columns: 1fr;
  }
}

/* Trail log */

.ot-log {
  height: 160px;
  max-height: 160px;
  overflow-y: auto;
}

.ot-log-entry {
  font-size: 11px;
  margin-bottom: 4px;
  color: #f4efe3;
}

/* Supplies overview */

.ot-supplies-grid {
  display: grid;
  gap: 2px 16px;
  grid-template-columns: 1.3fr 1fr;
  font-size: 11px;
}

.ot-supplies-label {
  color: #b6b1a7;
}

.ot-supplies-value {
  text-align: right;
}

/* Footer */

.ot-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 14px;
  padding-top: 10px;
  border-top: 1px solid rgba(255, 255, 255, 0.08);
  font-size: 11px;
  color: #c5c0b5;
}

.ot-footer-left {
  max-width: 60%;
}

.ot-footer-right {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.ot-rep-chip {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px;
  border-radius: 999px;
  background: rgba(243, 222, 186, 0.08);
  color: #f3ddc4;
  font-size: 11px;
  border: 1px solid rgba(243, 222, 186, 0.18);
  line-height: 1.2;
  transition: background 0.18s ease, border-color 0.18s ease, color 0.18s ease;
}

.ot-rep-chip-virtuous {
  background: linear-gradient(135deg, rgba(114, 200, 164, 0.12), rgba(114, 200, 164, 0.04));
  border-color: rgba(114, 200, 164, 0.35);
  color: #c6efd9;
}

.ot-rep-chip-neutral {
  background: rgba(220, 207, 189, 0.08);
  border-color: rgba(220, 207, 189, 0.25);
  color: #f3ddc4;
}

.ot-rep-chip-notorious {
  background: linear-gradient(135deg, rgba(204, 119, 96, 0.14), rgba(204, 119, 96, 0.05));
  border-color: rgba(204, 119, 96, 0.4);
  color: #f4c7b9;
}

/* Inventory modal */

.ot-modal {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

.ot-modal.active {
  display: flex;
}

.ot-modal-backdrop {
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at top, rgba(0, 0, 0, 0.84), rgba(0, 0, 0, 0.96));
}

.ot-modal-content {
  position: relative;
  background: radial-gradient(circle at top left, #262739, #07060a);
  border-radius: 16px;
  padding: 16px 18px 14px;
  border: 1px solid rgba(252, 238, 197, 0.25);
  box-shadow: 0 24px 80px rgba(0, 0, 0, 0.95);
  width: min(520px, 100% - 32px);
  max-height: 80vh;
  overflow: auto;
}

.ot-encounter-content {
  width: min(720px, 100% - 32px);
  display: grid;
  gap: 10px;
}

.ot-encounter-header {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  gap: 12px;
}

.ot-encounter-subtitle {
  font-size: 11px;
  color: #b6b1a7;
  text-align: right;
}

.ot-encounter-body {
  font-size: 12px;
  color: #e4ded0;
  display: grid;
  gap: 6px;
  line-height: 1.5;
}

.ot-encounter-body p {
  margin: 0;
}

.ot-encounter-image {
  width: 100%;
  aspect-ratio: 16 / 7;
  border-radius: 12px;
  background-size: cover;
  background-position: center;
  border: 1px solid rgba(252, 238, 197, 0.18);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
}

.ot-encounter-companions {
  border-left: 2px solid rgba(255, 255, 255, 0.08);
  padding-left: 10px;
  color: #c5beb1;
  font-style: italic;
  display: grid;
  gap: 4px;
}

.ot-encounter-options {
  display: grid;
  gap: 8px;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
}

.ot-encounter-btn {
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid rgba(244, 219, 160, 0.4);
  background: rgba(60, 58, 72, 0.75);
  color: #f3ddc4;
  font-size: 12px;
  text-align: left;
  cursor: pointer;
  line-height: 1.3;
  transition: background 0.16s ease, transform 0.12s ease, border-color 0.16s ease;
}

.ot-encounter-btn:hover,
.ot-encounter-btn:focus {
  background: rgba(90, 83, 70, 0.9);
  border-color: rgba(244, 219, 160, 0.7);
  outline: none;
  transform: translateY(-1px);
}

.ot-encounter-btn[disabled] {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

.ot-encounter-tone-warm {
  border-color: rgba(114, 200, 164, 0.5);
  background: linear-gradient(135deg, rgba(114, 200, 164, 0.14), rgba(114, 200, 164, 0.06));
}

.ot-encounter-tone-danger {
  border-color: rgba(204, 119, 96, 0.6);
  background: linear-gradient(135deg, rgba(204, 119, 96, 0.14), rgba(204, 119, 96, 0.08));
}

.ot-encounter-tone-neutral {
  border-color: rgba(244, 219, 160, 0.35);
  background: rgba(60, 58, 72, 0.72);
}

.ot-encounter-hint {
  display: block;
  margin-top: 4px;
  color: #b6b1a7;
  font-size: 11px;
}

.ot-modal-title {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.16em;
  color: #f4e4c2;
  margin-bottom: 6px;
}

.ot-modal-sub {
  font-size: 11px;
  color: #b6b1a7;
  margin-bottom: 8px;
}

.ot-inventory-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
  margin-bottom: 10px;
}

.ot-inventory-table th,
.ot-inventory-table td {
  padding: 4px 4px;
  text-align: left;
  border-bottom: 1px solid rgba(255, 255, 255, 0.04);
}

.ot-inventory-table th {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.16em;
  color: #b6b1a7;
}

.ot-inv-btn {
  padding: 4px 9px;
  border-radius: 999px;
  border: 1px solid rgba(244, 219, 160, 0.7);
  background: transparent;
  color: #f4e4c2;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.14em;
  cursor: pointer;
}

.ot-trade-content {
  background: linear-gradient(135deg, rgba(59, 50, 38, 0.45), rgba(17, 14, 12, 0.85)),
    radial-gradient(circle at top left, #2a2b3b, #0a090e);
  border: 1px solid rgba(230, 204, 160, 0.28);
  width: min(960px, 100% - 28px);
}

.ot-trade-summary {
  font-size: 11px;
  color: #d6cfc0;
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(245, 210, 139, 0.18);
  border-radius: 10px;
  padding: 8px 10px;
  margin-bottom: 8px;
}

.ot-trade-tabs {
  display: inline-flex;
  gap: 8px;
  margin-bottom: 8px;
}

.ot-trade-tabs .ot-btn-outline.ot-trade-tab-active {
  background: rgba(245, 210, 139, 0.14);
  border-color: rgba(245, 210, 139, 0.8);
  color: #f7e7c6;
}

.ot-trade-grid {
  display: grid;
  grid-template-columns: minmax(0, 1.7fr) minmax(260px, 1fr);
  gap: 12px;
  align-items: start;
}

.ot-trade-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}

.ot-trade-table th,
.ot-trade-table td {
  padding: 6px 6px;
  text-align: left;
  border-bottom: 1px solid rgba(255, 255, 255, 0.06);
}

.ot-trade-table th {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.14em;
  color: #cbbba0;
}

.ot-trade-table td:last-child {
  white-space: nowrap;
}

.ot-trade-ledger-notes {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(245, 210, 139, 0.08);
  border-radius: 8px;
  padding: 8px;
  margin-bottom: 10px;
}

.ot-barter-panel {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(245, 210, 139, 0.18);
  border-radius: 10px;
  padding: 10px;
  margin-top: 8px;
  display: none;
}

.ot-barter-panel h4 {
  margin: 0 0 6px 0;
  font-size: 12px;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: #e9e3d5;
}

.ot-barter-columns {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-bottom: 8px;
}

.ot-barter-list {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(245, 210, 139, 0.12);
  border-radius: 8px;
  padding: 6px;
  min-height: 48px;
}

.ot-barter-line {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
  font-size: 12px;
}

.ot-barter-line button {
  margin-left: 8px;
}

.ot-barter-totals {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  align-items: center;
  margin-bottom: 6px;
}

.ot-barter-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}

.ot-trade-ledger-notes-title {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: #d7c7a8;
  margin-bottom: 4px;
}

.ot-trade-ledger-note {
  font-size: 11px;
  color: #e9e3d5;
  margin-bottom: 2px;
}

.ot-trade-ledger {
  background: rgba(0, 0, 0, 0.18);
  border: 1px solid rgba(245, 210, 139, 0.12);
  border-radius: 12px;
  padding: 10px;
  min-height: 240px;
}

.ot-trade-ledger-title {
  font-size: 11px;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: #e9d7b3;
  margin-bottom: 6px;
}

.ot-trade-ledger-entry {
  font-size: 11px;
  color: #e9e3d5;
  border-bottom: 1px dashed rgba(255, 255, 255, 0.06);
  padding: 6px 0;
}

.ot-trade-ledger-entry small {
  display: block;
  color: #b6b1a7;
  margin-top: 2px;
}

@media (max-width: 780px) {
  .ot-trade-grid {
    grid-template-columns: 1fr;
  }

  .ot-trade-ledger {
    min-height: auto;
  }
}

.ot-inv-btn:hover {
  background: rgba(245, 210, 139, 0.12);
}

/* Work priorities modal */

.ot-priorities-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 11px;
  margin-bottom: 6px;
}

.ot-priorities-table th,
.ot-priorities-table td {
  padding: 3px 4px;
  text-align: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.04);
}

.ot-priorities-table th:first-child,
.ot-priorities-table td:first-child {
  text-align: left;
}

.ot-priority-cell {
  min-width: 30px;
  padding: 3px 0;
  border-radius: 999px;
  border: 1px solid rgba(244, 219, 160, 0.6);
  background: transparent;
  color: #f4e4c2;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  cursor: pointer;
}

.ot-priority-cell.prio-off {
  opacity: 0.45;
  border-style: dashed;
}

.ot-priority-cell.prio-1 {
  background: radial-gradient(circle at top, #f7cf7f, #f0b75b);
  color: #2d1b09;
}

.ot-priority-cell.prio-2 {
  background: radial-gradient(circle at top, rgba(247, 207, 127, 0.5), rgba(240, 183, 91, 0.5));
}

.ot-priority-cell.prio-3 {
  background: rgba(246, 238, 203, 0.09);
}

.ot-priority-cell.prio-4 {
  background: transparent;
  opacity: 0.7;
}

.ot-priorities-legend {
  font-size: 10px;
  color: #b6b1a7;
  margin-bottom: 4px;
}

.ot-priorities-warnings {
  font-size: 10px;
  color: #ffce7d;
  margin-top: 2px;
}

.ot-chore-strip {
  display: grid;
  grid-template-columns: 120px 120px 1fr;
  align-items: center;
  padding: 4px 6px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  gap: 8px;
}

.ot-chore-strip .ot-chore-name {
  font-weight: 600;
  letter-spacing: 0.04em;
}

.ot-chore-strip .ot-chore-role {
  font-size: 11px;
  color: #c8c1b3;
}

.ot-chore-strip .ot-chore-summary {
  font-size: 11px;
  color: #d7cfbf;
}

.ot-chore-timeline {
  display: grid;
  grid-template-columns: repeat(8, minmax(10px, 1fr));
  gap: 2px;
}

.ot-chore-timeline span {
  height: 8px;
  border-radius: 2px;
  display: block;
  background: rgba(255, 255, 255, 0.05);
}

.ot-ct-cook { background: linear-gradient(135deg, rgba(247,207,127,0.4), rgba(240,183,91,0.25)); }
.ot-ct-water { background: linear-gradient(135deg, rgba(107,170,247,0.5), rgba(62,115,182,0.35)); }
.ot-ct-guard { background: linear-gradient(135deg, rgba(255,255,255,0.5), rgba(120,120,140,0.45)); }
.ot-ct-repair { background: linear-gradient(135deg, rgba(200,255,200,0.4), rgba(120,180,120,0.4)); }
.ot-ct-doctor { background: linear-gradient(135deg, rgba(255,120,120,0.4), rgba(200,80,80,0.35)); }
.ot-ct-craft { background: linear-gradient(135deg, rgba(200,180,255,0.4), rgba(140,120,200,0.35)); }
.ot-ct-forage { background: linear-gradient(135deg, rgba(150,200,130,0.4), rgba(110,160,100,0.35)); }
.ot-ct-rest { background: rgba(255,255,255,0.08); }
.ot-ct-empty { background: rgba(255,255,255,0.05); border: 1px dashed rgba(255,255,255,0.08); }

/* Camp tasks overlay */
#ot-camp-overlay {
  position: fixed;
  inset: 0;
  background: rgba(2, 2, 4, 0.8);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 20;
  padding: 10px;
}

#ot-camp-overlay.ot-show {
  display: flex;
}

#ot-camp-overlay .ot-overlay-inner {
  position: relative;
  max-width: 920px;
  width: 100%;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}

#ot-camp-overlay .ot-overlay-close {
  position: absolute;
  top: 6px;
  right: 6px;
  z-index: 2;
}

/* Compact overlay chrome for camp planner */
#ot-camp-overlay .ot-overlay-panel {
  background: radial-gradient(circle at top, #171920, #0b0c11);
  border-radius: 14px;
  border: 1px solid rgba(255, 255, 255, 0.08);
  padding: 8px;
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.7);
}

/* Camp menu shell tweaks */
#oldtrail-camp-menu-widget .cm-shell {
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.7);
}

/* Crafting widget styling */
#oldtrail-crafting-widget,
#oldtrail-crafting-widget * {
  box-sizing: border-box;
}

#oldtrail-crafting-widget {
  font-family: "Georgia", "Times New Roman", serif;
  background: radial-gradient(circle at top, #1c222f, #0c0f16);
  color: #f5e9cf;
  padding: 8px;
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.05);
}

#oldtrail-crafting-widget .ot-craft-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 11px;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  margin-bottom: 6px;
}

#oldtrail-crafting-widget .ot-craft-grid {
  display: grid;
  grid-template-columns: repeat(3, 36px) 24px 80px;
  gap: 4px;
  align-items: center;
  margin-bottom: 6px;
}

#oldtrail-crafting-widget .ot-craft-cell {
  width: 36px;
  height: 36px;
  border-radius: 6px;
  background: rgba(255, 255, 255, 0.06);
  border: 1px solid rgba(255, 255, 255, 0.08);
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.5);
}

#oldtrail-crafting-widget .ot-craft-output {
  width: 80px;
  height: 48px;
  border-radius: 8px;
  background: linear-gradient(145deg, rgba(247, 207, 127, 0.2), rgba(240, 183, 91, 0.12));
  border: 1px solid rgba(247, 207, 127, 0.4);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  color: #f7cf7f;
}

#oldtrail-crafting-widget .ot-craft-status {
  font-size: 11px;
  color: #d7cfbf;
}

/* Trail log widget wrapper inside panel */
#old-trail-log-widget {
  width: 100%;
}

/* Thoughts bubble placement */
#oldtrail-thoughts-bubble {
  position: fixed;
  bottom: 16px;
  right: 16px;
  z-index: 15;
  cursor: pointer;
}

#oldtrail-thoughts-bubble .tb-window {
  width: 280px;
  background: radial-gradient(circle at top, #1d1f27, #0b0c11);
  border: 1px solid rgba(247, 207, 127, 0.35);
  border-radius: 12px;
  box-shadow: 0 12px 30px rgba(0, 0, 0, 0.65);
  overflow: hidden;
}

#oldtrail-thoughts-bubble .tb-header {
  background: linear-gradient(90deg, #4a2b1b, #23130d);
  color: #f6e7c6;
  padding: 6px 8px;
  font-size: 11px;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

#oldtrail-thoughts-bubble .tb-body {
  display: flex;
  padding: 8px;
  gap: 8px;
}

#oldtrail-thoughts-bubble .tb-avatar {
  width: 42px;
  height: 42px;
  border-radius: 9px;
  background: linear-gradient(135deg, #c2a070, #74512f);
  border: 1px solid rgba(247, 207, 127, 0.35);
}

#oldtrail-thoughts-bubble .tb-text {
  font-size: 12px;
  line-height: 1.35;
  color: #f4e8d4;
}

#oldtrail-thoughts-bubble .tb-mood-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-top: 6px;
}

#oldtrail-thoughts-bubble .tb-mood-bar {
  flex: 1;
  height: 8px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.08);
  overflow: hidden;
  border: 1px solid rgba(247, 207, 127, 0.25);
}

#oldtrail-thoughts-bubble .tb-mood-fill {
  height: 100%;
  width: 50%;
  background: linear-gradient(90deg, #a33a2b, #f0b75b);
  transition: width 160ms ease-out;
}

#oldtrail-thoughts-bubble .tb-footer {
  padding: 6px 8px 8px;
  font-size: 10px;
  letter-spacing: 0.12em;
  color: #b39b7c;
  text-transform: uppercase;
}

/* STORYTELLER PHASE 2+ : Cascade timeline */
.ot-cascade-wrapper {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.ot-cascade-timeline {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 6px;
  padding: 6px 0;
}

.ot-cascade-node {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: #3a3d4f;
  border: 1px solid rgba(255, 255, 255, 0.15);
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  color: #f6f3ea;
}

.ot-cascade-connector {
  flex: 1 1 30px;
  height: 2px;
  background: linear-gradient(90deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.06));
  min-width: 28px;
}

.ot-cascade-label {
  font-size: 11px;
  color: #dcd8ce;
  min-width: 72px;
}

.ot-cascade-node.social {
  background: linear-gradient(135deg, #5c3c6d, #2c1e33);
}

.ot-cascade-node.hunger {
  background: linear-gradient(135deg, #6d3f2c, #2c1b12);
}

.ot-cascade-node.water,
.ot-cascade-node.illness {
  background: linear-gradient(135deg, #355c7a, #1a2838);
}

.ot-cascade-node.romance {
  background: linear-gradient(135deg, #804460, #301c2a);
}

.ot-cascade-node.feud,
.ot-cascade-node.leadership {
  background: linear-gradient(135deg, #7a3f3f, #2f1818);
}

.ot-cascade-node.lifeline {
  background: linear-gradient(135deg, #3f7a56, #1a2f22);
}

.ot-cascade-node.loss {
  background: linear-gradient(135deg, #5e646c, #1f242b);
}

.ot-cascade-person {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 0;
  font-size: 12px;
}

.ot-cascade-person-name {
  width: 120px;
  color: #f7cf7f;
  font-weight: 600;
}

.ot-cascade-person-track {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
}

.ot-cascade-chip {
  padding: 2px 6px;
  border-radius: 6px;
  background: rgba(255, 255, 255, 0.06);
  border: 1px solid rgba(255, 255, 255, 0.12);
}

/* Small responsive tweak */

@media (max-width: 900px) {
  .ot-screen-grid,
  .ot-screen-travel {
    grid-template-columns: minmax(0, 1fr);
  }
  .ot-footer-left {
    max-width: 100%;
    margin-bottom: 10px;
  }
  .ot-footer {
    flex-direction: column;
    align-items: flex-start;
  }
}
</style>

<div id="oldtrail-root" class="ot-root">
  <div class="ot-header">
    <div class="ot-title-block">
      <div class="ot-title">OLD TRAIL</div>
      <div class="ot-subtitle">
        SURVIVAL JOURNAL · OREGON TRAIL, 1840s–1860s
      </div>
    </div>
    <div class="ot-header-right">
      <div id="ot-leader-pill" class="ot-pill">Leader — not yet chosen</div>
      <button id="ot-btn-reset" class="ot-pill ot-pill-danger">
        Reset journey
      </button>
    </div>
  </div>

  <!-- START SCREEN -->
  <div id="ot-screen-start" class="ot-screen ot-screen-active">
    <div class="ot-screen-grid ot-start-grid">
      <div>
        <div class="ot-panel">
          <div class="ot-panel-header">Assemble your party</div>
          <div class="ot-panel-body">
            <div class="ot-field">
              <div class="ot-label">Leader name</div>
              <div class="ot-draft-row" data-slot="leader">
                <div class="ot-draft-header">
                  <span>Leader</span>
                  <div class="ot-draft-controls">
                    <button class="ot-mini-btn" data-action="lock">Lock</button>
                    <button class="ot-mini-btn" data-action="reroll">Reroll</button>
                  </div>
                </div>
                <input
                  id="ot-leader-name"
                  class="ot-input"
                  placeholder="e.g., Amelia Knight"
                />
                <div class="ot-draft-info" id="ot-draft-info-leader"></div>
              </div>
            </div>

            <div class="ot-field">
              <div class="ot-label">Leader calling</div>
              <div id="ot-leader-calling" class="ot-panel-body-sm"></div>
              <div
                id="ot-leader-starting-funds"
                class="ot-panel-body-sm ot-text-muted"
                style="margin-top: 4px;"
              ></div>
            </div>

            <div class="ot-field">
              <div class="ot-label">Departure town</div>
              <select id="ot-departure" class="ot-select">
                <option value="independence">Independence, Missouri</option>
                <option value="st_joseph">St. Joseph, Missouri</option>
                <option value="council_bluffs">Council Bluffs</option>
              </select>
            </div>

            <div class="ot-field">
              <div class="ot-label">Departure date</div>
              <select id="ot-departure-season" class="ot-select">
                <option value="early_april">Early April – swollen rivers, cold nights, sparse grass</option>
                <option value="late_april">Late April – historically ideal window (rivers falling, grass growing)</option>
                <option value="mid_may">Mid May – good grass, some storms, still safe for passes</option>
                <option value="early_june">Early June – hotter plains, stronger storms, still OK if you move well</option>
                <option value="mid_july">Mid July – high heat & dust, late for mountain passes</option>
              </select>
              <div
                id="ot-departure-season-desc"
                class="ot-panel-body-sm ot-text-muted"
                style="margin-top: 4px;"
              ></div>
            </div>

            <div class="ot-field">
              <div class="ot-label">Trail narrator</div>
              <select id="ot-storyteller-preset" class="ot-select"></select>
              <div
                id="ot-storyteller-desc"
                class="ot-panel-body-sm ot-text-muted"
                style="margin-top: 4px;"
              >
                Shapes how quickly tension rises, how often dramatic events strike, and how generous breathers feel.
              </div>
            </div>

            <div class="ot-field">
              <div class="ot-label">Mythic encounters</div>
              <select id="ot-mythic-toggle" class="ot-select">
                <option value="on">On – rare tall tales may cross your path</option>
                <option value="off">Off – keep to grounded happenings</option>
              </select>
              <div class="ot-panel-body-sm ot-text-muted" style="margin-top: 4px;">
                Tall-tale encounters are rare, branchy, and can be toggled off for a strictly grounded trek.
              </div>
            </div>

            <div class="ot-field">
              <div class="ot-label">Companions (up to 4)</div>
              <div id="ot-draft-rows"></div>
              <div class="ot-draft-controls" style="margin-top: 6px;">
                <button id="ot-btn-generate-party" class="ot-btn-gold" style="flex:1;">Generate party</button>
                <div class="ot-panel-body-sm ot-text-muted" style="flex:1;">
                  Reroll individuals, lock favorites, or type over names. Traits and backstories carry into play.
                </div>
              </div>
            </div>

            <button id="ot-btn-begin-outfit" class="ot-btn-gold">
              Begin outfitting
            </button>
          </div>
        </div>
      </div>

      <div>
        <div class="ot-panel">
          <div class="ot-panel-header">Trail brief</div>
          <div class="ot-panel-body ot-panel-body-sm">
            Your wagon party will travel roughly two thousand miles from the
            Missouri frontier to the Willamette Valley. Most days you'll walk
            beside the wagon for 8–10 hours, stopping at noon to rest the stock
            and again at night to cook, make camp, and stand watch.
            <br /><br />
            Time advances in hours. Each hour you can have your leader and
            companions travel, scout ahead, hunt, cook, gather wood or water,
            repair the wagon, or simply rest. Tasks use their skills and carry
            different risks. Weather and season matter: swollen rivers in early
            spring, searing heat and dust in midsummer.
            <br /><br />
            Keep everyone fed, watered, warm, and rested. A party in poor
            condition will slow to a crawl or fall apart long before Oregon.
          </div>
        </div>
        <div class="ot-panel">
          <div class="ot-panel-header">Narrator &amp; difficulty</div>
          <div class="ot-panel-body ot-panel-body-sm">
            <div id="ot-storyteller-cards" class="ot-preset-cards"></div>
            <div
              id="ot-storyteller-example"
              class="ot-preset-example"
              aria-live="polite"
            ></div>
            <div class="ot-panel-body-sm ot-text-muted" style="margin-top: 6px;">
              Tap or click a card to select a narrator. The dropdown on the left
              will follow along for accessibility and saved games.
            </div>
          </div>
        </div>
        <div id="ot-start-art" class="ot-start-art"></div>
      </div>
    </div>
  </div>

  <!-- OUTFITTING -->
  <div id="ot-screen-outfit" class="ot-screen">
    <div class="ot-screen-grid">
      <div>
        <div class="ot-panel">
          <div class="ot-panel-header">Outfit your wagon</div>
          <div class="ot-panel-body">
            <div
              id="ot-outfit-intro"
              class="ot-panel-body-sm ot-text-muted"
              style="margin-bottom: 6px;"
            ></div>
            <table class="ot-outfit-table" id="ot-outfit-table">
              <thead>
                <tr>
                  <th>Item</th>
                  <th>Qty</th>
                  <th>Unit</th>
                  <th>Cost</th>
                  <th>Subtotal</th>
                </tr>
              </thead>
              <tbody id="ot-outfit-body"></tbody>
            </table>
            <div
              style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap;"
            >
              <button id="ot-btn-add-recommended" class="ot-btn-outline">
                Add recommended load
              </button>
              <button id="ot-btn-begin-journey" class="ot-btn-gold">
                Begin the journey
              </button>
            </div>
          </div>
        </div>
      </div>
      <div>
        <div class="ot-panel">
          <div class="ot-panel-header">Wagon summary</div>
          <div class="ot-panel-body ot-panel-body-sm">
            <div class="ot-outfit-summary-row">
              <div class="ot-supplies-label">Starting funds</div>
              <div id="ot-sum-starting" class="ot-supplies-value">$0.00</div>
            </div>
            <div class="ot-outfit-summary-row">
              <div class="ot-supplies-label">Money remaining</div>
              <div id="ot-sum-money" class="ot-supplies-value">$0.00</div>
            </div>
            <div class="ot-outfit-summary-row">
              <div class="ot-supplies-label">Total load</div>
              <div id="ot-sum-load" class="ot-supplies-value">0 lb</div>
            </div>
            <div class="ot-outfit-summary-row">
              <div class="ot-supplies-label">Draft power</div>
              <div id="ot-sum-draft" class="ot-supplies-value">
                0 lb pull
              </div>
            </div>
            <div class="ot-outfit-summary-row">
              <div class="ot-supplies-label">Load ratio</div>
              <div id="ot-sum-ratio" class="ot-supplies-value">0%</div>
            </div>
            <div
              class="ot-panel-body-sm ot-text-muted"
              style="margin-top: 6px;"
            >
              A heavily overloaded wagon will crawl along the trail and break
              down more often, but leaving too much behind risks starvation
              later.
            </div>
          </div>
        </div>
        <div id="ot-outfit-art" class="ot-start-art"></div>
      </div>
    </div>
  </div>

  <!-- TRAVEL SCREEN -->
  <div id="ot-screen-travel" class="ot-screen">
    <div class="ot-screen-grid ot-screen-travel">
      <div class="ot-travel-main">
        <div class="ot-panel">
          <div class="ot-panel-header">
            Explorer viewport
            <div class="ot-panel-actions">
              <div class="ot-travel-view-toggle">
                <button
                  id="ot-btn-view-journal"
                  class="ot-view-toggle-btn ot-view-toggle-btn-active"
                  type="button"
                >
                  Journal view
                </button>
                <button id="ot-btn-view-explorer" class="ot-view-toggle-btn" type="button">
                  Explorer view
                </button>
              </div>
              <button id="ot-btn-open-map" class="ot-btn-outline ot-map-launch" type="button">
                Trail map
              </button>
            </div>
          </div>

          <div class="ot-travel-scene-wrapper ot-viewport-window">
            <div id="ot-explorer-chip" class="ot-explorer-chip"></div>
            <div
              id="ot-explorer-tooltip"
              class="ot-map-tooltip ot-explorer-tooltip"
              style="display: none"
            ></div>
            <canvas
              id="ot-trail-canvas"
              class="ot-trail-canvas"
              aria-hidden="true"
            ></canvas>
            <div id="ot-scene" class="ot-travel-scene"></div>
            <div class="ot-travel-scene-overlay" id="ot-scene-caption"></div>
            <div id="ot-affliction-alerts" class="ot-affliction-alerts"></div>
          </div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">Trail info</div>
          <div
            class="ot-panel-body ot-panel-body-sm"
            id="ot-trail-header"
          ></div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">Trail log</div>
          <div class="ot-panel-body" id="ot-trail-log-panel">
            <div id="old-trail-log-widget">
              <div class="ot-log-shell">
                <div class="ot-log-header">
                  <div class="ot-log-title">Trail Log</div>
                  <div class="ot-log-sub">Journal of the Journey</div>
                </div>
                <div class="ot-log-body">
                  <div class="ot-log-list"></div>
                </div>
                <div class="ot-log-footer">
                  <div>Recent entries</div>
                  <div class="ot-footer-pill">Handwritten mode</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="ot-panel" id="ot-cascade-panel" style="display: none;">
          <div class="ot-panel-header">Trail story highlights</div>
          <div class="ot-panel-body ot-cascade-wrapper">
            <div id="ot-cascade-summary"></div>
            <div id="ot-cascade-highlights"></div>
            <div id="ot-cascade-timeline" aria-label="Cascade timeline"></div>
            <div id="ot-cascade-people" aria-label="Companion timelines"></div>
          </div>
        </div>
      </div>

      <div class="ot-travel-side">
        <div class="ot-panel">
          <div class="ot-panel-header">On the trail</div>
          <div class="ot-panel-body ot-panel-body-sm">
            <div>Pace: <span id="ot-ontrail-pace">Steady</span></div>
            <div>Rations: <span id="ot-ontrail-rations">Full rations</span></div>
            <div>Mode: <span id="ot-ontrail-mode">In camp</span></div>
            <div>Daily block: <span id="ot-ontrail-block">Morning</span></div>
            <div>Weather: <span id="ot-weather-summary">—</span></div>
            <div class="ot-text-muted" id="ot-weather-note"></div>
            <div>
              Reputation:
              <span
                id="ot-reputation-chip"
                class="ot-rep-chip ot-rep-chip-neutral"
                title="Standing among travelers"
                role="status"
              >
                Neutral
              </span>
            </div>
            <div>
              Factions:
              <span id="ot-faction-forts" class="ot-rep-chip ot-rep-chip-neutral">Forts</span>
              <span id="ot-faction-caravans" class="ot-rep-chip ot-rep-chip-neutral">Caravans</span>
              <span id="ot-faction-open-eye" class="ot-rep-chip ot-rep-chip-neutral">Open Eye</span>
              <span id="ot-faction-men-in-gray" class="ot-rep-chip ot-rep-chip-neutral">Men in Gray</span>
            </div>
          </div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">Narrator</div>
            <div class="ot-panel-body ot-panel-body-sm">
              <div class="ot-narrator-row">
                <div id="ot-narrator-label" class="ot-text-muted"></div>
                <button id="ot-btn-toggle-narrator" class="ot-link-button" type="button">
                  Change narrator
                </button>
              </div>
              <div id="ot-narrator-picker" class="ot-narrator-picker" style="display: none; margin-top: 6px;">
                <select id="ot-storyteller-midrun" class="ot-select"></select>
                <div id="ot-narrator-hint" class="ot-panel-body-sm ot-text-muted" style="margin-top: 4px;"></div>
              </div>
              <div id="ot-narrator-rules" class="ot-panel-body-sm ot-text-muted" style="margin-top: 4px;"></div>
              <div class="ot-panel-body-sm ot-text-muted" style="margin-top: 6px;">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" id="ot-tension-debug" />
                  <span>Show tension debug</span>
                </label>
              <div id="ot-tension-readout" class="ot-panel-body-sm ot-text-muted"></div>
            </div>
          </div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">Leader status</div>
          <div class="ot-panel-body" id="ot-leader-status"></div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">
            Party manifest
            <button id="ot-btn-open-social" class="ot-link-button" type="button">Social web</button>
          </div>
          <div class="ot-panel-body" id="ot-party-manifest"></div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">
            Hour tasks
            <button
              id="ot-btn-open-priorities"
              class="ot-link-button"
              type="button"
            >
              Work priorities
            </button>
          </div>
          <div class="ot-panel-body" id="ot-hour-tasks"></div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">Companion detail</div>
          <div class="ot-panel-body" id="ot-companion-detail"></div>
        </div>

        <div class="ot-panel">
          <div class="ot-panel-header">
            Supplies overview
            <button
              id="ot-btn-open-inventory"
              class="ot-link-button"
              type="button"
            >
              Inventory
            </button>
            <button
              id="ot-btn-open-trade"
              class="ot-link-button"
              type="button"
              style="display:none;"
            >
              Trading Post
            </button>
          </div>
          <div class="ot-panel-body" id="ot-supplies-overview"></div>
        </div>
      </div>
    </div>

    <div class="ot-footer">
      <div class="ot-footer-left" id="ot-footer-status"></div>
      <div class="ot-footer-right">
        <button id="ot-btn-advance-1" class="ot-btn-gold">
          Advance 1 hour
        </button>
        <button id="ot-btn-advance-4" class="ot-btn-gold">
          Advance 4 hours
        </button>
        <button id="ot-btn-toggle-mode" class="ot-btn-outline">
          Toggle travel / camp
        </button>
        <button id="ot-btn-change-pace" class="ot-btn-outline">
          Change pace
        </button>
        <button id="ot-btn-change-rations" class="ot-btn-outline">
          Change rations
        </button>
        <button id="ot-btn-evening-proper-camp" class="ot-btn-outline">
          Proper camp (2h)
        </button>
        <button id="ot-btn-evening-rushed-camp" class="ot-btn-outline">
          Rushed camp (1h)
        </button>
        <button id="ot-btn-campfire-moment" class="ot-btn-outline">
          Campfire moment (1h)
        </button>
        <button id="ot-btn-open-camp-tasks" class="ot-btn-outline">
          Camp tasks
        </button>
      </div>
    </div>
  </div>

  <!-- Camp tasks & crafting overlay -->
  <div id="ot-camp-overlay">
    <div class="ot-overlay-inner">
      <div class="ot-overlay-panel">
        <div class="ot-panel-header" style="margin-bottom: 6px">
          Camp tasks planner
        </div>
        <div id="oldtrail-camp-menu-widget"></div>
        <div class="ot-panel-body-sm" id="ot-camp-chore-wrapper" style="margin-top:6px;">
          <div style="display:flex; align-items:center; gap:6px; margin-bottom:4px;">
            <div class="ot-text-muted" style="flex:1">Night chores are based on current work roles. Edit priorities to adjust who does what.</div>
            <button id="ot-btn-edit-roles" class="ot-btn-outline" style="padding:4px 6px; font-size:11px;">Edit roles</button>
          </div>
          <div id="ot-camp-chore-strips" class="ot-panel-body-sm" style="background: rgba(255,255,255,0.03); border-radius:8px;"></div>
        </div>
        <div
          id="ot-camp-roles-summary"
          class="ot-panel-body-sm ot-text-muted"
          style="margin-top: 6px"
        ></div>
        <div style="display: flex; gap: 8px; margin-top: 8px; align-items: center">
          <button id="ot-btn-camp-confirm" class="ot-btn-gold">Confirm chores</button>
          <button id="ot-btn-camp-auto" class="ot-btn-outline">Auto plan</button>
          <div class="ot-text-muted" id="ot-camp-summary-note"></div>
        </div>
      </div>
      <div class="ot-overlay-panel">
        <div class="ot-panel-header" style="margin-bottom: 6px">
          Crafting & repairs
        </div>
        <div id="oldtrail-crafting-widget"></div>
      </div>
      <button id="ot-btn-close-camp" class="ot-btn-outline ot-overlay-close">Close</button>
    </div>
  </div>

  <!-- Trail map modal -->
  <div id="ot-map-modal" class="ot-modal">
    <div class="ot-modal-backdrop"></div>
    <div class="ot-modal-content ot-map-modal-content">
      <div class="ot-modal-title">Trail map</div>
      <div class="ot-modal-sub" id="ot-map-sub">
        View your progress and nearby waypoints along the route.
      </div>
      <div class="ot-map-modal-grid">
        <div class="ot-map-viewport ot-viewport-window" id="ot-map-viewport">
          <div id="ot-map-tooltip" class="ot-map-tooltip" style="display: none"></div>
        </div>
        <div class="ot-trail-map" id="ot-trail-map"></div>
      </div>
      <div class="ot-map-controls">
        <div class="ot-map-toggle-row">
          <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
            <input id="ot-toggle-fog" type="checkbox" /> Fog of war
          </label>
          <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
            <input id="ot-toggle-silhouettes" type="checkbox" /> Silhouettes on unseen
          </label>
        </div>
        <div class="ot-map-target-block">
          <div class="ot-map-target-header">
            <div style="font-weight: 600;">Travel target</div>
            <button id="ot-btn-clear-target" class="ot-btn-outline" type="button">Clear Target</button>
          </div>
          <div class="ot-map-target-meta" id="ot-target-meta">No destination selected</div>
          <div class="ot-map-conditions" id="ot-local-conditions"></div>
          <div class="ot-map-target-actions">
            <button id="ot-btn-travel-1h" class="ot-btn-gold" type="button">Travel 1h</button>
            <button id="ot-btn-travel-4h" class="ot-btn-outline" type="button">Travel 4h</button>
            <button id="ot-btn-auto-travel" class="ot-btn-outline" type="button">Auto Travel (max 12h)</button>
          </div>
        </div>
      </div>
      <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px; gap: 8px;">
        <button
          id="ot-btn-toggle-maplist"
          class="ot-link-button"
          type="button"
        >
          Show waypoints
        </button>
        <button id="ot-btn-close-map" class="ot-btn-outline" type="button">Close</button>
      </div>
    </div>
  </div>

  <div id="ot-encounter-modal" class="ot-modal" aria-hidden="true">
    <div class="ot-modal-backdrop"></div>
    <div
      class="ot-modal-content ot-encounter-content"
      role="dialog"
      aria-modal="true"
      aria-labelledby="ot-encounter-title"
      tabindex="-1"
    >
      <div class="ot-encounter-header">
        <div id="ot-encounter-title" class="ot-modal-title">Encounter</div>
        <div id="ot-encounter-subtitle" class="ot-encounter-subtitle"></div>
      </div>
      <div
        id="ot-encounter-image"
        class="ot-encounter-image"
        style="display: none;"
        aria-hidden="true"
      ></div>
      <div id="ot-encounter-body" class="ot-encounter-body"></div>
      <div
        id="ot-encounter-companions"
        class="ot-encounter-companions"
        style="display: none;"
      ></div>
      <div id="ot-encounter-options" class="ot-encounter-options"></div>
    </div>
  </div>

  <div id="oldtrail-thoughts-bubble" style="display: none">
    <div class="tb-window">
      <div class="tb-header">
        <span class="tb-name">Companion</span>
        <span class="tb-close">×</span>
      </div>
      <div class="tb-body">
        <div class="tb-avatar"></div>
        <div style="flex: 1">
          <div class="tb-text">Quiet thoughts by the fire.</div>
          <div class="tb-mood-row">
            <div class="tb-mood-bar">
              <div class="tb-mood-fill"></div>
            </div>
            <div class="tb-mood-label">Mood</div>
          </div>
        </div>
      </div>
      <div class="tb-footer">Tap to cycle thoughts</div>
    </div>
  </div>

  <!-- INVENTORY MODAL -->
  <div id="ot-inventory-modal" class="ot-modal">
    <div class="ot-modal-backdrop"></div>
    <div class="ot-modal-content">
      <div class="ot-modal-title">Wagon inventory</div>
      <div id="ot-inventory-sub" class="ot-modal-sub"></div>
      <table class="ot-inventory-table">
        <thead>
          <tr>
            <th>Item</th>
            <th>Qty</th>
            <th>Use</th>
          </tr>
        </thead>
        <tbody id="ot-inventory-body"></tbody>
      </table>
      <div style="display: flex; justify-content: flex-end; margin-top: 6px;">
        <button id="ot-btn-close-inventory" class="ot-btn-outline">
          Close
        </button>
      </div>
    </div>
  </div>

  <div id="ot-trade-modal" class="ot-modal" aria-hidden="true">
    <div class="ot-modal-backdrop"></div>
    <div class="ot-modal-content ot-trade-content">
      <div class="ot-modal-title" id="ot-trade-title">Trading Post</div>
      <div id="ot-trade-sub" class="ot-modal-sub"></div>

      <div class="ot-trade-summary" id="ot-trade-summary"></div>

      <div class="ot-trade-tabs">
        <button id="ot-trade-tab-buy" class="ot-btn-outline">Buy</button>
        <button id="ot-trade-tab-sell" class="ot-btn-outline">Sell</button>
        <button id="ot-trade-tab-barter" class="ot-btn-outline">Barter</button>
      </div>

      <div class="ot-trade-grid">
        <div>
          <table class="ot-trade-table">
            <thead>
              <tr>
                <th>Goods</th>
                <th>Owned</th>
                <th>Stock</th>
                <th>Buy</th>
                <th>Sell</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="ot-trade-body"></tbody>
          </table>
          <div id="ot-trade-msg" class="ot-modal-sub" style="min-height:16px; margin-top:6px;"></div>
          <div id="ot-barter-panel" class="ot-barter-panel" style="display:none;"></div>
        </div>

        <div class="ot-trade-ledger">
          <div class="ot-trade-ledger-notes">
            <div class="ot-trade-ledger-notes-title">Ledger Notes</div>
            <div id="ot-trade-ledger-notes"></div>
          </div>
          <div class="ot-trade-ledger-title">Ledger</div>
          <div id="ot-trade-ledger-body"></div>
        </div>
      </div>

      <div style="display:flex; justify-content:flex-end; margin-top:6px;">
        <button id="ot-btn-close-trade" class="ot-btn-outline">Close</button>
      </div>
    </div>
  </div>

  <!-- WORK PRIORITIES MODAL -->
  <div id="ot-priorities-modal" class="ot-modal">
    <div class="ot-modal-backdrop"></div>
    <div class="ot-modal-content">
      <div class="ot-modal-title">Work priorities</div>
      <div id="ot-priorities-sub" class="ot-modal-sub ot-priorities-legend">
        Set what each person focuses on when set to “auto”. Lower numbers are
        higher priority; “—” means they rarely do that job unless you assign it
        directly. Toggling between travel and camp will reset hour-by-hour
        assignments so the auto system can re-balance jobs.
      </div>
      <table class="ot-priorities-table">
        <thead>
          <tr id="ot-priorities-head-row"></tr>
        </thead>
        <tbody id="ot-priorities-body"></tbody>
      </table>
      <div id="ot-priorities-warnings" class="ot-priorities-warnings"></div>
      <div style="display: flex; justify-content: flex-end; margin-top: 6px;">
        <button id="ot-btn-close-priorities" class="ot-btn-outline">
          Close
        </button>
      </div>
    </div>
  </div>

  <!-- SOCIAL WEB MODAL -->
  <div id="ot-social-modal" class="ot-modal">
    <div class="ot-modal-backdrop"></div>
    <div class="ot-modal-content">
      <div class="ot-modal-title">Social web</div>
      <div id="ot-social-body" class="ot-panel-body"></div>
    </div>
  </div>
</div>

<script>
(function () {
  "use strict";

  // STORYTELLER + MEDICAL + CAMP batch: romance/feud arcs, water quality, doctoring, camp mishaps (2024-05-07)
  // PLAN (2024-07-04): Added hidden trait intel + suspicion/reveal helpers, trait draft weighting, new trait/backstory packs,
  // early faction/curio scaffolding, and romance/rivalry hooks. Deferring full mythic chains, most new event arcs, and
  // broader faction price hooks to roadmap to avoid destabilizing the storyteller pacing this pass.

  /* ========= CONSTANTS & DATA ============================================= */

  const SAVE_KEY = "oldtrail_hourly_v2";
  const HOURS_PER_DAY = 24;

  const IMAGE_URLS = {
    start_screen:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/start-screen_orig.png",
    st_joseph_start:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/stjoseph-start2_orig.png",
    council_bluffs_start:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/councilbluff-start_orig.png",
    independence_start_edge:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/independence-start2_orig.png",
    leaving_independence:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/leaving-independnce_orig.png",
    kansas_bottomlands:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/kansasriver-bottomlands_orig.png",
    little_blue_spring:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/littlebluevalley-spring_orig.png",
    little_blue_burned:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/littlebluevalley-burned-out_orig.png",
    platte_clear:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/centralplatte-clear_orig.png",
    platte_heat_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/centralplatte-heat-storm_orig.png",
    buffalo_plains_heat:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/buffaloplains-summerheat_orig.png",
    buffalo_plains_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/buffaloplains-storm_orig.png",
    chimney_clear:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/chimney-clear_orig.png",
    chimney_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/chimney-storm_orig.png",
    fort_kearny_camp:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-kearny_orig.png",
    fort_laramie_approach:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-laramie_orig.png",
    register_cliffs:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/register-cliffs_orig.png",
    independence_rock:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/independence-rock_orig.png",
    devils_gate:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/devilsgate_orig.png",
    south_pass_clear:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/southpass-clear_orig.png",
    south_pass_midsummer:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/southpass-midsummer_orig.png",
    soda_springs_morning:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/sodasprings-earlymorning_orig.png",
    soda_springs_warm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/sodasprings-warmday_orig.png",
    snake_bench_heat:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/snakeriver-bench-heat_orig.png",
    snake_bench_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/snakeriver-bench-storm_orig.png",
    salmon_falls_dusk:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/salmonfalls-dusk_orig.png",
    salmon_falls_summer:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/salmonfalls-summer_orig.png",
    alkali_flats_evening:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/alkaliflats-evening_orig.png",
    alkali_flats_day:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/alkaliflats-summer_orig.png",
    three_island_calm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/threeislandcrossing-calm_orig.png",
    three_island_danger:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/threeislandcrossing-danger_orig.png",
    grande_ronde_autumn:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/granderonde-valley-autumn_orig.png",
    grande_ronde_summer:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/granderonde-valley-summer_orig.png",
    blue_mountains_clear:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/bluemtnsroad-clear_orig.png",
    blue_mountains_rain:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/bluemtnsroad-rain_orig.png",
    mountain_creek_calm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/mountaincreek-calm_orig.png",
    mountain_creek_danger:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/mountaincreek-danger_orig.png",
    columbia_gorge_primary:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/columbiagorge-primary_orig.png",
    columbia_gorge_rain:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/columbiagorge-rain_orig.png",
    dalles_primary:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/dalles-primary_orig.png",
    dalles_evening:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/dalles-evening_orig.png",
    barlow_clear:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/barlow-mthood-clear_orig.png",
    barlow_snow:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/barlow-mthood-snow_orig.png",
    oregon_city_primary:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/oregoncity-primary_orig.png",
    oregon_city_rain:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/oregoncity-rain_orig.png",
    oregon_city_spring:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/oregoncity-springmorning_orig.png",
    willamette_valley:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/willamette-valley-arrival_orig.png",
    generalstore_missouri:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/generalstore-missouri_orig.png",
    generalstore_missouri_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/generalstore-missouri-storm_orig.png",
    fort_kearny_sutler:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-kearny-sutler-primary_orig.png",
    fort_laramie_yard:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-laramie-parade_orig.png",
    fort_laramie_evening:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-laramie-evening_orig.png",
    fort_bridger_evening:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-bridger-evening_orig.png",
    fort_bridger_cold:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-bridger-cold2_orig.png",
    fort_hall_summer:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-hall-summer_orig.png",
    fort_hall_rain:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-hall-rain_orig.png",
    fort_boise_primary:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-boise-primary_orig.png",
    fort_boise_flood:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-boise-flooded_orig.png",
    generalstore_independence_day:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/generalstore-independence-day_orig.png",
    generalstore_independence_night:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/generalstore-interior-independence_orig.png",
    trail_trading_tent:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/trail-trading-tent_orig.png",
    fort_blacksmith:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-blacksmith_orig.png",
    fort_blacksmith_morning:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-blacksmith-morning_orig.png",
    fort_doctor_morning:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-doctor-morning_orig.png",
    fort_doctor_night:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-doctor-night2_orig.png",
    native_trade_lodge:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/native-trade-lodge_orig.png",
    mission_dining:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/mission-whitman-dining_orig.png",
    camp_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/camp-storm_orig.png",
    camp_sunrise_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/camp-sunrise-storm_orig.png",
    prairie_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/prairire-storm_orig.png",
    bluemtns_flurries:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/bluemtns-flurries_orig.png",
    dust_storm:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/dust-storm_orig.png",
    prairie_fire:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/prairie-fire_orig.png",
    kansasriver_calm_day:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/kansasriver-calm_orig.png",
    kansasriver_calm_sunset:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/kansasriver-calm-sunset_orig.png",
    kansasriver_danger:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/kansasriver-danger_orig.png",
    kansasriver_ferry:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/kansasriver-ferry_orig.png",
    bigblueriver_crossing:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/bigblueriver-crossing_orig.png",
    snakeriver_threeisle_ford:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/snakeriver-threeisle-ford_orig.png",
    snakeriver_caulked:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/snakeriver-caulked_orig.png",
    columbiariver_rafting:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/columbiariver-rafting_orig.png",
    wagon_river_tipped:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-river-tipped_orig.png",
    wagon_brokenwheel:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-brokenwheel_orig.png",
    wagon_snappedaxle:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-snappedaxle_orig.png",
    wagon_snappedaxle_rain:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-snappedaxle-rain_orig.png",
    wagon_steep_descent:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-steep-descent_orig.png",
    wagon_stuck_mud:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-stuck-mud_orig.png",
    wagon_abandoned:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-abandoned_orig.png",
    camp_evening:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/camp-evening_orig.png",
    camp_hunting:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/camp-hunting_orig.png",
    foraging:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/foraging_orig.png",
    trade_salmon:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/trade-salmon_orig.png",
    feast_cayuse_nez:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/feast-cayuse-nez_orig.png",
    hunt_buffalo:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/hunt-buffalo_orig.png",
    hunt_buffalo_dead:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/hunt-buffalo-dead_orig.png",
    stalk_deer_primary:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/stalk-deer-primary_orig.png",
    stalk_deer_timberline:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/stalk-deer-timberline_orig.png",
    hunt_smallgame:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/hunt-smallgame_orig.png",
    illness_cholera:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/illness-cholera_orig.png",
    illness_dysentary:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/illness-dysentary_orig.png",
    illness_fever:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/illness-fever_orig.png",
    illness_snakebite:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/illness-snakebite_orig.png",
    illness_brokenleg:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/illness-brokenleg_orig.png",
    illness_frostbite:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/illness-frostbite_orig.png",
    death_burial:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/death_orig.png",
    travelers_in_need:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/travelers-in-need_orig.png",
    trade_native:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/trade-native_orig.png",
    hostile_tension:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/hostile-tension_orig.png",
    help_stranger:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/help-stranger_orig.png",
    wagon_lost:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/wagon-lost_orig.png",
    buffalo_stampede:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/buffalo-stampede_orig.png",
    alkali_water:
      "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/alkali-water_orig.png",
  };

  const PARTY_NAME_SETS = {
    first: [
      "Amelia",
      "Caleb",
      "Naomi",
      "Elias",
      "Clara",
      "Hiram",
      "Miles",
      "Lydia",
      "Rosalind",
      "Silas",
      "Josephine",
      "Gideon",
      "Abigail",
      "Jonah",
      "Sabine",
      "Owen",
    ],
    last: [
      "Knight",
      "Barton",
      "Rivers",
      "Hawkins",
      "Mercer",
      "Dunlap",
      "Trout",
      "McKeen",
      "Sutter",
      "Cole",
      "Blevins",
      "Harlan",
      "Whitman",
      "Pruitt",
      "Glass",
      "Addison",
    ],
  };

  const FEMALE_NAME_HINTS = new Set([
    "Amelia",
    "Naomi",
    "Clara",
    "Lydia",
    "Rosalind",
    "Josephine",
    "Abigail",
    "Sabine",
  ]);

  const BACKSTORY_DEFS = [
    { id: "prairie_farmer", label: "Prairie farmer", origin: "Illinois prairie homestead", summary: "Knows livestock and the rhythm of seasons.", skillBias: { cooking: 1, woodcutting: 1, travel: 1 } },
    { id: "millwright", label: "Millwright", origin: "Ohio riverside mill", summary: "Built wheels and rigged pulleys; careful with repairs.", skillBias: { repair: 2, craft: 1 } },
    { id: "river_trader", label: "River trader", origin: "Missouri riverboat decks", summary: "Bargains hard, sleeps light, scans for opportunity.", skillBias: { guard: 1, travel: 1, hunting: 1 } },
    { id: "schoolteacher", label: "Schoolteacher", origin: "New England schoolhouse", summary: "Patient, observant, keeps notes on miles and supplies.", skillBias: { doctoring: 1, cooking: 1 } },
    { id: "army_teamster", label: "Army teamster", origin: "Frontier post freighter", summary: "Handled oxen, mud, and bad weather on short rations.", skillBias: { travel: 2, guard: 1 } },
    { id: "apprentice_doc", label: "Apprentice doctor", origin: "Country infirmary", summary: "Knows poultices and when to boil water twice.", skillBias: { doctoring: 2 } },
    { id: "buffalo_hunter", label: "Buffalo hunter", origin: "High plains camp", summary: "Comfortable stalking game and dressing meat fast.", skillBias: { hunting: 2, woodcutting: 1 } },
    { id: "wheelwright", label: "Wheelwright", origin: "Shop beside a dusty road", summary: "Fixes spokes, felloes, and leather lashings.", skillBias: { repair: 2, craft: 1 } },
    { id: "itinerant_preacher", label: "Circuit preacher", origin: "Crossroads camp-meetings", summary: "Knows people, keeps tempers from boiling over.", skillBias: { cooking: 1, doctoring: 1 } },
    { id: "mountain_trapper", label: "Mountain trapper", origin: "Cabin near the Tetons", summary: "Reads weather, moves quiet, distrusts crowds.", skillBias: { hunting: 1, guard: 1, travel: 1 } },
    { id: "blacksmith", label: "Blacksmith", origin: "Forge beside the livery", summary: "Strong arms, steady hands, knows iron and yokes.", skillBias: { repair: 1, craft: 2 } },
    { id: "city_apprentice", label: "City apprentice", origin: "Boston workshop", summary: "Quick learner, soft hands, keen on maps and notes.", skillBias: { travel: 1, craft: 1 } },
    { id: "wagon_cook", label: "Wagon cook", origin: "Trail mess for freighters", summary: "Knows how to stretch beans and coffee, keeps fires tidy.", skillBias: { cooking: 2, woodcutting: 1 } },
    { id: "ranch_hand", label: "Ranch hand", origin: "Texas cattle range", summary: "Rides long days, can rope strays, gutsy around danger.", skillBias: { guard: 1, travel: 1, hunting: 1 } },
    { id: "riverboat_gambler", label: "Riverboat gambler", origin: "Missouri card tables", summary: "Knows odds, tells lies smooth, and keeps a knife close.", skillBias: { travel: 1, guard: 1, craft: 1 } },
    { id: "frontier_midwife", label: "Frontier midwife", origin: "Cabins and sickrooms", summary: "Calm in panic, steady with poultices and splints.", skillBias: { doctoring: 2, cooking: 1 }, allowedGenders: ["female"] },
    { id: "blacksmith_helper", label: "Blacksmith helper", origin: "Forge behind a feed store", summary: "Strong arms and an eye for metal fatigue.", skillBias: { repair: 2, woodcutting: 1 } },
    { id: "scribe_clerk", label: "Scribe clerk", origin: "County records office", summary: "Neat handwriting, sharp memory, and suspicious eyes.", skillBias: { craft: 2, travel: 1 } },
    { id: "stage_driver", label: "Stage driver", origin: "Dusty coach lines", summary: "Fast hands on reins, faster choices under pressure.", skillBias: { travel: 2, guard: 1 } },
    { id: "fur_buyer", label: "Fur buyer", origin: "Trading counters & camps", summary: "Can smell value and trouble from a mile off.", skillBias: { foraging: 1, hunting: 1, craft: 1 } },
    { id: "sawmill_hand", label: "Sawmill hand", origin: "River sawmill", summary: "Knows grain, knots, and how to split a beam true.", skillBias: { woodcutting: 2, repair: 1 } },
    { id: "wagon_scout", label: "Wagon scout", origin: "Cutoffs and creekbeds", summary: "Finds safe ground and better lines through bad country.", skillBias: { travel: 2, foraging: 1 } },
    { id: "camp_chaplain", label: "Camp chaplain", origin: "Camp meetings", summary: "Keeps spirits up, reads people better than maps.", skillBias: { doctoring: 1, cooking: 1, guard: 1 } },
    { id: "border_ranger", label: "Border ranger", origin: "Thin-law frontier", summary: "Knows warning signs and how to hold a perimeter.", skillBias: { guard: 2, travel: 1, hunting: 1 } },
    { id: "herb_gatherer", label: "Herb gatherer", origin: "Creeks and meadows", summary: "Finds useful plants and keeps notes on what works.", skillBias: { foraging: 2, doctoring: 1 } },
    { id: "kitchen_servant", label: "Kitchen servant", origin: "Big house kitchens", summary: "Knows timing, heat, and how to stretch a pantry.", skillBias: { cooking: 2, craft: 1 } },
    { id: "barrel_maker", label: "Barrel maker", origin: "Cooper’s shop", summary: "Hoops, staves, and the patience to keep water in wood.", skillBias: { craft: 2, repair: 1 } },
    { id: "bookish_student", label: "Bookish student", origin: "Half-finished schooling", summary: "Smart on paper, learning fast on the dirt road.", skillBias: { craft: 2, doctoring: 1 } },
    { id: "shore_fisher", label: "Shore fisher", origin: "River shallows", summary: "Knows water moods and where food hides.", skillBias: { foraging: 1, hunting: 1, travel: 1 } },
    { id: "comet_witness", label: "Comet witness", origin: "Night sky over the prairie", summary: "Swears a falling star changed something inside them.", skillBias: { travel: 1, guard: 1, craft: 1 } },
    { id: "lost_surveyor", label: "Lost surveyor", origin: "Lines that don’t match maps", summary: "Carries a strange instrument and refuses to explain it.", skillBias: { travel: 2, craft: 1 } },
    { id: "graveyard_caretaker", label: "Graveyard caretaker", origin: "Churchyard hillside", summary: "Too calm around death; talks to the dark like it answers.", skillBias: { doctoring: 1, guard: 1, craft: 1 } },
  ];

  const TRAIT_DEFS = [
    { id: "steady", label: "Steady", summary: "Calm under strain", skillMods: { guard: 1 }, moraleBias: 2 },
    { id: "cheerful", label: "Cheerful", summary: "Finds light in hardship", moraleBias: 3, socialBonus: 1 },
    { id: "argumentative", label: "Argumentative", summary: "Picks at others' ideas", opinionBias: -4 },
    { id: "merciful", label: "Merciful", summary: "Hesitates to punish", socialBonus: 1 },
    { id: "hard", label: "Hard-nosed", summary: "Pushes others to keep moving", moraleBias: -1, skillMods: { travel: 1 } },
    { id: "cowardly", label: "Timid", summary: "Avoids danger", guardPenalty: 1, opinionBias: -2 },
    { id: "pious", label: "Pious", summary: "Keeps faith close", moraleBias: 1, socialBonus: 1 },
    { id: "wry", label: "Wry", summary: "Dry humor cuts tension", socialBonus: 2 },
    { id: "reckless", label: "Reckless", summary: "Acts before thinking", skillMods: { travel: 1, hunting: 1 }, moraleBias: -1 },
    { id: "tireless", label: "Tireless", summary: "Keeps working after others rest", skillMods: { travel: 1, woodcutting: 1 } },
    { id: "fussy_cook", label: "Fussy cook", summary: "Hates bland meals", skillMods: { cooking: 1 }, moraleBias: -1 },
    { id: "trail_teller", label: "Trail storyteller", summary: "Spins yarns at the fire", socialBonus: 2 },
    { id: "skeptical", label: "Skeptical", summary: "Doubts tall tales", moraleBias: 0, mythicGuard: true },
    { id: "brave", label: "Brave", summary: "Faces down risk", guardBonus: 1, moraleBias: 1 },
    { id: "caretaker", label: "Caretaker", summary: "Checks on others", skillMods: { doctoring: 1, cooking: 1 }, socialBonus: 1 },
    { id: "lazy", label: "Lazy", summary: "Drags feet on chores", moraleBias: -2, taskPenalty: 1 },
    { id: "sharp_eyed", label: "Sharp-eyed", summary: "Spots trouble", skillMods: { guard: 1, hunting: 1 } },
    { id: "tall_tale", label: "Touched by tall tales", summary: "Claims to have seen strange lights", moraleBias: 1, rare: true },
    { id: "camp_medic", label: "Camp medic", summary: "Comfortable with splints", skillMods: { doctoring: 2 } },
    { id: "organizer", label: "Organizer", summary: "Loves tidy plans", socialBonus: 1, skillMods: { craft: 1 } },
    { id: "sour", label: "Sour", summary: "Quick to grumble", moraleBias: -2, opinionBias: -2 },
    { id: "wilderness_lore", label: "Wilderness lore", summary: "Reads wind and water", skillMods: { foraging: 1, travel: 1 } },
    { id: "mythic_mark", label: "Myth-marked", summary: "Carries a strange brand, whispers follow", rare: true, moraleBias: -1, socialBonus: -1 },
    { id: "industrious", label: "Industrious", summary: "Keeps moving even when tired", skillMods: { woodcutting: 1, repair: 1 }, moraleBias: 1 },
    { id: "meticulous", label: "Meticulous", summary: "Measures twice, cuts once", skillMods: { repair: 1, craft: 1 }, moraleBias: 0 },
    { id: "improviser", label: "Improviser", summary: "Makes do with scraps", skillMods: { repair: 1, cooking: 1 }, moraleBias: 0 },
    { id: "bungler", label: "Bungler", summary: "Good intentions, clumsy hands", moraleBias: -1, taskPenalty: 1, opinionBias: -1 },
    { id: "packrat", label: "Packrat", summary: "Hates throwing anything away", moraleBias: 0, socialBonus: -1 },
    { id: "minimalist", label: "Minimalist", summary: "Travels light and proud", moraleBias: 1, socialBonus: 0 },
    { id: "firekeeper", label: "Firekeeper", summary: "Always coaxes a flame", skillMods: { cooking: 1, woodcutting: 1 }, moraleBias: 0 },
    { id: "water_saver", label: "Water saver", summary: "Treats every drop as gold", skillMods: { travel: 1 }, moraleBias: 0 },
    { id: "gear_oiler", label: "Gear oiler", summary: "Quietly maintains moving parts", skillMods: { repair: 2 }, moraleBias: 0 },
    { id: "tidy_camp", label: "Tidy camp", summary: "Cleans as they go", moraleBias: 1, socialBonus: 1 },
    { id: "slovenly", label: "Slovenly", summary: "Leaves messes for later", moraleBias: -1, socialBonus: -1 },
    { id: "quartermaster", label: "Quartermaster", summary: "Counts, bundles, labels", skillMods: { craft: 1 }, socialBonus: 1 },
    { id: "wasteful", label: "Wasteful", summary: "Uses more than needed", moraleBias: -1, opinionBias: -1 },
    { id: "frugal", label: "Frugal", summary: "Pinches pennies and portions", moraleBias: 0, opinionBias: 1 },
    { id: "surefooted", label: "Surefooted", summary: "Keeps balance on bad ground", skillMods: { travel: 1 }, moraleBias: 0 },
    { id: "trailwise", label: "Trailwise", summary: "Reads ruts, weather, and men", skillMods: { travel: 2 }, moraleBias: 0 },
    { id: "navigator", label: "Navigator", summary: "Lives by landmarks and bearings", skillMods: { travel: 1, craft: 1 }, moraleBias: 0 },
    { id: "wanderer", label: "Wanderer", summary: "Feels alive on the move", moraleBias: 1, socialBonus: 0 },
    { id: "homesick", label: "Homesick", summary: "Longs for home comforts", moraleBias: -2, socialBonus: 0 },
    { id: "mud_larked", label: "Mud-larked", summary: "Shrugs off filth and rain", moraleBias: 1, skillMods: { travel: 1 } },
    { id: "vertigo", label: "Vertigo", summary: "Heights turn the stomach", moraleBias: -1, taskPenalty: 1 },
    { id: "riverhand", label: "Riverhand", summary: "Confident around crossings", skillMods: { travel: 1 }, moraleBias: 0 },
    { id: "river_shy", label: "River-shy", summary: "Cold water spooks them", moraleBias: -1, opinionBias: -1 },
    { id: "ox_whisperer", label: "Ox whisperer", summary: "Calms teams with a word", skillMods: { travel: 1 }, moraleBias: 0 },
    { id: "tracker", label: "Tracker", summary: "Sees sign others miss", skillMods: { hunting: 2 }, moraleBias: 0 },
    { id: "patient_shot", label: "Patient shot", summary: "Waits for the right moment", skillMods: { hunting: 1 }, moraleBias: 0 },
    { id: "butcher", label: "Butcher", summary: "Dresses meat clean and fast", skillMods: { cooking: 1, hunting: 1 }, moraleBias: 0 },
    { id: "forager", label: "Forager", summary: "Finds greens where none should grow", skillMods: { foraging: 2 }, moraleBias: 0 },
    { id: "berry_sense", label: "Berry sense", summary: "Knows what won’t kill you", skillMods: { foraging: 1 }, moraleBias: 0 },
    { id: "picky_forager", label: "Picky forager", summary: "Refuses bitter finds", moraleBias: -1, opinionBias: 0 },
    { id: "loud_step", label: "Loud step", summary: "Scares game without meaning to", moraleBias: -1, taskPenalty: 1 },
    { id: "bread_blesser", label: "Bread bless-er", summary: "Can make flour taste like hope", skillMods: { cooking: 2 }, moraleBias: 1 },
    { id: "coffee_devotee", label: "Coffee devotee", summary: "Needs a cup to function", moraleBias: -1, socialBonus: 0 },
    { id: "stew_master", label: "Stew master", summary: "Turns scraps into supper", skillMods: { cooking: 1 }, moraleBias: 0 },
    { id: "salt_fiend", label: "Salt fiend", summary: "Over-salts everything", moraleBias: -1, opinionBias: -1 },
    { id: "camp_host", label: "Camp host", summary: "Makes meals feel communal", skillMods: { cooking: 1 }, socialBonus: 2, moraleBias: 1 },
    { id: "herbalist", label: "Herbalist", summary: "Knows plants and poultices", skillMods: { doctoring: 1, foraging: 1 }, moraleBias: 0 },
    { id: "midwife", label: "Midwife", summary: "Steady hands, steady words", skillMods: { doctoring: 2 }, socialBonus: 1 },
    { id: "squeamish", label: "Squeamish", summary: "Blood turns the stomach", moraleBias: -1, opinionBias: 0 },
    { id: "iron_stomach", label: "Iron stomach", summary: "Eats what others won’t", moraleBias: 1 },
    { id: "delicate_stomach", label: "Delicate stomach", summary: "Bad food hits hard", moraleBias: -1 },
    { id: "hypochondriac", label: "Hypochondriac", summary: "Sure every ache is fatal", moraleBias: -2, socialBonus: -1 },
    { id: "stiff_joints", label: "Stiff joints", summary: "Morning pain slows them", moraleBias: -1, taskPenalty: 1 },
    { id: "quick_healer", label: "Quick healer", summary: "Bounces back faster than most", moraleBias: 1 },
    { id: "frail", label: "Frail", summary: "Gets hurt easy", moraleBias: -1 },
    { id: "germ_wary", label: "Germ-wary", summary: "Insists on boiling water", moraleBias: 0, opinionBias: 1 },
    { id: "stoic", label: "Stoic", summary: "Doesn’t show fear", moraleBias: 2, socialBonus: 0 },
    { id: "melancholy", label: "Melancholy", summary: "Carries a quiet sadness", moraleBias: -2, socialBonus: 0 },
    { id: "anxious", label: "Anxious", summary: "Sees danger in every shadow", moraleBias: -1, guardBonus: 1 },
    { id: "hotheaded", label: "Hotheaded", summary: "Temper runs fast", moraleBias: -1, opinionBias: -2 },
    { id: "patient", label: "Patient", summary: "Waits without complaint", moraleBias: 1, socialBonus: 1 },
    { id: "stubborn", label: "Stubborn", summary: "Hates being told what to do", moraleBias: 0, opinionBias: -1 },
    { id: "easygoing", label: "Easygoing", summary: "Rolls with setbacks", moraleBias: 2, socialBonus: 1 },
    { id: "grim", label: "Grim", summary: "Sees only the hard truth", moraleBias: -1, socialBonus: -1 },
    { id: "prankster", label: "Prankster", summary: "Finds mischief in boredom", socialBonus: 1, opinionBias: -1 },
    { id: "peacemaker", label: "Peacemaker", summary: "Talks people down", socialBonus: 2, moraleBias: 0 },
    { id: "gossip", label: "Gossip", summary: "Words travel faster than wagons", socialBonus: 1, opinionBias: -2 },
    { id: "loner", label: "Loner", summary: "Needs space from the group", socialBonus: -2, moraleBias: 0 },
    { id: "charismatic", label: "Charismatic", summary: "People listen when they speak", socialBonus: 2, moraleBias: 0 },
    { id: "blunt", label: "Blunt", summary: "Says it plain, even when it hurts", socialBonus: 0, opinionBias: -1 },
    { id: "polite", label: "Polite", summary: "Keeps manners under strain", socialBonus: 1, moraleBias: 0 },
    { id: "jealous", label: "Jealous", summary: "Keeps score of attention", opinionBias: -2, socialBonus: 0 },
    { id: "loyal", label: "Loyal", summary: "Sticks close in hard hours", socialBonus: 1, moraleBias: 1 },
    { id: "vengeful", label: "Vengeful", summary: "Never forgets a slight", opinionBias: -2, moraleBias: 0 },
    { id: "generous", label: "Generous", summary: "Shares without being asked", socialBonus: 2, moraleBias: 0 },
    { id: "miserly", label: "Miserly", summary: "Hates spending supplies", opinionBias: -1, moraleBias: 0 },
    { id: "romantic", label: "Romantic", summary: "Dreams of love at the fire", moraleBias: 1, socialBonus: 1 },
    { id: "chaperone", label: "Chaperone", summary: "Keeps propriety in camp", socialBonus: 0, opinionBias: 1 },
    { id: "night_watch", label: "Night watch", summary: "Wakes at every sound", skillMods: { guard: 2 }, moraleBias: 0 },
    { id: "sleepy_watch", label: "Sleepy watch", summary: "Nods off at the worst time", guardPenalty: 1, moraleBias: -1 },
    { id: "sharp_temper", label: "Sharp temper", summary: "Quick to threaten strangers", guardBonus: 1, opinionBias: -1 },
    { id: "soft_spoken", label: "Soft-spoken", summary: "De-escalates by instinct", guardBonus: 1, socialBonus: 1 },
    { id: "skittish", label: "Skittish", summary: "Startles easily", guardBonus: 1, moraleBias: -1 },
    { id: "fearless_fool", label: "Fearless fool", summary: "Bravery without caution", guardBonus: 1, moraleBias: -1 },
    { id: "haggler", label: "Haggler", summary: "Squeezes better terms", socialBonus: 1, moraleBias: 0 },
    { id: "silver_tongue", label: "Silver tongue", summary: "Talks doors open", socialBonus: 2, moraleBias: 0 },
    { id: "gullible", label: "Gullible", summary: "Falls for tall promises", socialBonus: 0, opinionBias: -1 },
    { id: "gambler", label: "Gambler", summary: "Can’t resist a wager", moraleBias: -1, socialBonus: 1 },
    { id: "lucky", label: "Lucky", summary: "Things break in someone else’s hands", moraleBias: 1, rare: true },
    { id: "jinxed", label: "Jinxed", summary: "Bad timing follows", moraleBias: -1, rare: true },
    { id: "klepto", label: "Light-fingered", summary: "Things go missing around them", moraleBias: -1, opinionBias: -2, rare: true },
    { id: "runaway", label: "Runaway", summary: "Fears being found", moraleBias: -1, socialBonus: 0, rare: true },
    { id: "wanted", label: "Wanted poster", summary: "A price on their head", moraleBias: -2, socialBonus: -1, rare: true },
    { id: "liar", label: "Liar", summary: "Stories don’t match the facts", opinionBias: -2, socialBonus: 1 },
    { id: "truthbound", label: "Truthbound", summary: "Refuses to lie", moraleBias: 1, socialBonus: 1 },
    { id: "secretive", label: "Secretive", summary: "Keeps to themselves", socialBonus: -1, moraleBias: 0 },
    { id: "bossy", label: "Bossy", summary: "Orders people around", opinionBias: -2, moraleBias: 0 },
    { id: "superstitious", label: "Superstitious", summary: "Sees omens in small things", moraleBias: 0, socialBonus: 0 },
    { id: "ritualist", label: "Ritualist", summary: "Insists on little routines", moraleBias: 1, socialBonus: 0 },
    { id: "iconoclast", label: "Iconoclast", summary: "Mocks sacred talk", moraleBias: 0, opinionBias: -1 },
    { id: "pilgrim", label: "Pilgrim", summary: "Believes the trail is a test", moraleBias: 1, socialBonus: 1 },
    { id: "night_owl", label: "Night owl", summary: "Wakes late, thrives at night", moraleBias: 0, guardBonus: 1 },
    { id: "early_riser", label: "Early riser", summary: "Up before dawn", moraleBias: 1, skillMods: { travel: 1 } },
    { id: "insomniac", label: "Insomniac", summary: "Sleeps in scraps", moraleBias: -1, guardBonus: 1 },
    { id: "sleepwalker", label: "Sleepwalker", summary: "Wanders at night", moraleBias: -1, rare: true },
    { id: "snorer", label: "Snorer", summary: "Keeps others awake", socialBonus: -1, moraleBias: -1 },
    { id: "cold_tough", label: "Cold-tough", summary: "Handles frost better than most", moraleBias: 1 },
    { id: "cold_sickly", label: "Cold-sickly", summary: "Shivers into misery", moraleBias: -1 },
    { id: "heat_hardy", label: "Heat-hardy", summary: "Works through blazing days", moraleBias: 1 },
    { id: "heat_faint", label: "Heat-faint", summary: "Sun knocks them flat", moraleBias: -1 },
    { id: "storm_singer", label: "Storm singer", summary: "Sings through thunder", socialBonus: 1, moraleBias: 1 },
    { id: "stock_hand", label: "Stock hand", summary: "Knows feed and footing", skillMods: { travel: 1, woodcutting: 1 }, moraleBias: 0 },
    { id: "animal_wary", label: "Animal-wary", summary: "Doesn’t trust big beasts", moraleBias: -1 },
    { id: "mule_skinner", label: "Mule-skinner", summary: "Hard on animals, fast miles", skillMods: { travel: 2 }, moraleBias: -1, opinionBias: -1 },
    { id: "journaler", label: "Journaler", summary: "Writes everything down", moraleBias: 1, socialBonus: 0 },
    { id: "map_maker", label: "Map-maker", summary: "Sketches routes and rivers", skillMods: { travel: 1, craft: 1 }, moraleBias: 0 },
    { id: "tinkering_mind", label: "Tinkering mind", summary: "Can’t stop improving things", skillMods: { repair: 1, craft: 1 }, moraleBias: 0 },
    { id: "omen_reader", label: "Omen-reader", summary: "Reads signs in birds and smoke", rare: true, moraleBias: 0, socialBonus: 1 },
    { id: "dream_touched", label: "Dream-touched", summary: "Wakes with warnings they can’t explain", rare: true, moraleBias: -1, socialBonus: 0 },
    { id: "ghost_hearer", label: "Ghost-hearer", summary: "Hears names in the wind", rare: true, moraleBias: -2, socialBonus: -1 },
    { id: "starbound", label: "Starbound", summary: "Feels watched by distant lights", rare: true, moraleBias: 0, socialBonus: 0 },
    { id: "thin_place", label: "Thin-place sense", summary: "Knows when ground feels wrong", rare: true, skillMods: { travel: 1 }, moraleBias: -1 },
    { id: "warded", label: "Warded", summary: "Carries a charm that ‘works’", rare: true, moraleBias: 1, mythicGuard: true },
    { id: "whisper_sick", label: "Whisper-sick", summary: "Voices rise when camp goes quiet", rare: true, moraleBias: -2, socialBonus: -1 },
    { id: "lantern_glow", label: "Lantern-glow", summary: "Strange light clings to them", rare: true, moraleBias: -1, socialBonus: -1 },
    { id: "time_lost", label: "Time-lost", summary: "Swears they’ve lived this mile before", rare: true, moraleBias: 0, socialBonus: 0 },
    { id: "name_itch", label: "Name-itch", summary: "Hates being called by full name", rare: true, moraleBias: -1, opinionBias: -1 },
    { id: "rationalist", label: "Rationalist", summary: "Demands proof, hates superstition", moraleBias: 0, mythicGuard: true, opinionBias: -1 },
    { id: "story_breaker", label: "Story-breaker", summary: "Ruins a good ghost tale", moraleBias: 0, mythicGuard: true, socialBonus: -1 },
    { id: "panhandler", label: "Pan-handler", summary: "Always ‘just checking’ the cookware", moraleBias: 0, opinionBias: -1 },
    { id: "boot_swapper", label: "Boot-swapper", summary: "Mischief with gear", moraleBias: 0, socialBonus: 1, opinionBias: -1, rare: true },
    { id: "doom_sayer", label: "Doom-sayer", summary: "Predicts disaster daily", moraleBias: -1, socialBonus: -1 },
    { id: "tall_order", label: "Tall order", summary: "Always wants ‘one more thing’", moraleBias: -1, opinionBias: -1 },
    { id: "camp_poet", label: "Camp poet", summary: "Turns misery into verse", moraleBias: 1, socialBonus: 1 },
    { id: "harmonica_hand", label: "Harmonica hand", summary: "Music softens hard nights", moraleBias: 1, socialBonus: 1 },
  ];

  const TRAIT_BUCKET_WEIGHTS_V1 = { common: 70, uncommon: 23, rare: 6, mythic: 1 };

  const TRAIT_BUCKETS_V1 = {
    common: [
      "steady",
      "merciful",
      "pious",
      "wry",
      "tireless",
      "skeptical",
      "caretaker",
      "sharp_eyed",
      "camp_medic",
      "organizer",
      "wilderness_lore",
      "industrious",
      "meticulous",
      "improviser",
      "firekeeper",
      "water_saver",
      "gear_oiler",
      "tidy_camp",
      "quartermaster",
      "frugal",
      "minimalist",
      "surefooted",
      "trailwise",
      "navigator",
      "wanderer",
      "riverhand",
      "ox_whisperer",
      "mud_larked",
      "tracker",
      "patient_shot",
      "butcher",
      "forager",
      "berry_sense",
      "bread_blesser",
      "stew_master",
      "camp_host",
      "harmonica_hand",
      "camp_poet",
      "herbalist",
      "midwife",
      "iron_stomach",
      "quick_healer",
      "germ_wary",
      "stoic",
      "patient",
      "easygoing",
      "peacemaker",
      "charismatic",
      "polite",
      "loyal",
      "generous",
      "truthbound",
      "ritualist",
      "pilgrim",
      "night_watch",
      "early_riser",
      "cold_tough",
      "heat_hardy",
      "storm_singer",
      "stock_hand",
      "journaler",
      "map_maker",
      "tinkering_mind",
    ],
    uncommon: [
      "cheerful",
      "argumentative",
      "hard",
      "cowardly",
      "reckless",
      "fussy_cook",
      "trail_teller",
      "brave",
      "lazy",
      "sour",
      "bungler",
      "packrat",
      "slovenly",
      "wasteful",
      "panhandler",
      "tall_order",
      "homesick",
      "vertigo",
      "river_shy",
      "loud_step",
      "picky_forager",
      "animal_wary",
      "mule_skinner",
      "coffee_devotee",
      "salt_fiend",
      "squeamish",
      "delicate_stomach",
      "hypochondriac",
      "stiff_joints",
      "frail",
      "melancholy",
      "anxious",
      "stubborn",
      "grim",
      "prankster",
      "gossip",
      "loner",
      "blunt",
      "jealous",
      "miserly",
      "romantic",
      "chaperone",
      "vengeful",
      "secretive",
      "bossy",
      "sleepy_watch",
      "sharp_temper",
      "soft_spoken",
      "skittish",
      "night_owl",
      "insomniac",
      "snorer",
      "superstitious",
      "iconoclast",
      "haggler",
      "silver_tongue",
      "gullible",
      "gambler",
      "liar",
    ],
    rare: [
      "tall_tale",
      "mythic_mark",
      "lucky",
      "jinxed",
      "klepto",
      "runaway",
      "wanted",
      "fearless_fool",
      "hotheaded",
      "sleepwalker",
      "boot_swapper",
      "doom_sayer",
    ],
    mythic: [
      "omen_reader",
      "dream_touched",
      "ghost_hearer",
      "starbound",
      "thin_place",
      "warded",
      "whisper_sick",
      "lantern_glow",
      "time_lost",
      "name_itch",
      "rationalist",
      "story_breaker",
    ],
  };

  const CURIO_DEFS = [
    {
      id: "wisp_lantern",
      name: "Wisp Lantern",
      shortDesc: "A glass lamp that burns with no fuel, guiding steps at night.",
      boon: { guardBonus: 1, morale: 2 },
      upkeep: { kind: "wood", cost: 1, periodHours: 24 },
      tags: ["mythic", "light"],
    },
    {
      id: "home_marker",
      name: "Home Marker",
      shortDesc: "A carved mile post that hums when storms roll in.",
      boon: { travel: 1, warmth: 2 },
      upkeep: { kind: "time", cost: 1, periodHours: 48 },
      tags: ["mythic", "wayfinding"],
    },
    {
      id: "gray_token",
      name: "Gray Token",
      shortDesc: "An odd coin that rumors say wards off unseen eyes.",
      boon: { mythicGuard: true, morale: 1 },
      upkeep: { kind: "morale", cost: 2, periodHours: 36 },
      tags: ["mythic", "omen"],
    },
  ];

  const DREAMWEST_B_SEEDS = [
    {
      id: "seed_b02_open_eye_leaflet",
      kind: "breather",
      condition: function (ctx) {
        return (
          ctx.block === "evening" &&
          hoursSinceFlag("seed_b02_open_eye_leaflet_time") >= 72 &&
          hoursSinceFlag("seed_b_global_time") >= 36
        );
      },
      weight: function () {
        return 3;
      },
      run: async function (ctx) {
        const selection = await presentEncounter({
          id: "seed_b02_open_eye_leaflet",
          title: "Leaflet with an open eye",
          subtitle: ctx.location,
          body: [
            "Among your papers is a folded leaflet, inked with an eye that seems to watch even in the twilight.",
          ],
          tags: ["camp", "cult"],
          options: [
            { id: "read", label: "Read it", tone: "neutral", hint: "Murmured slogans stir the camp." },
            { id: "burn", label: "Burn it", tone: "danger", hint: "Char it and move on." },
            { id: "pocket", label: "Pocket it", tone: "warm", hint: "Keep it for later." },
          ],
          defaultId: "read",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b02_open_eye_leaflet_time", nowHour);
        let logText = "You tuck the strange leaflet away and return to the firelight.";
        if (selection === "read") {
          getAllPeople().forEach(function (p) {
            adjustPersonStat(p, "morale", 2);
          });
          setEventFlag("open_eye_seen", true);
          if (ctx.storyState.mythicEnabled !== false) {
            ctx.storyState.mythicRumor = clamp((ctx.storyState.mythicRumor || 0) + 1, 0, 100);
          }
          logText = "You pass the leaflet around; the stylized eye and fervent words linger in everyone's mind.";
        } else if (selection === "burn") {
          adjustFactionRep("open_eye", -4, null, ctx);
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) - 1, 0, 100);
          const target = choice(ctx.people || getAllPeople());
          if (target) {
            addThought(target, {
              id: "open_eye_burn",
              label: "Burned an odd leaflet",
              value: -2,
              hoursLeft: 10,
              source: "camp",
            });
          }
          logText = "You feed the leaflet to the coals. A few uneasy looks follow the curling inked eye.";
        } else if (selection === "pocket") {
          setEventFlag("open_eye_leaflet_kept", true);
          logText = "You slip the leaflet into a pouch, inked eye hidden for now.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "cult", "Found an Open Eye leaflet", { choice: selection });
      },
    },
    {
      id: "seed_b09_caravan_ledger",
      kind: "breather",
      condition: function (ctx) {
        const blockOk = ctx.block === "morning" || ctx.block === "evening";
        return (
          blockOk &&
          hoursSinceFlag("seed_b09_caravan_ledger_time") >= 120 &&
          hoursSinceFlag("seed_b_global_time") >= 36 &&
          !getNearbyFortPOI()
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const selection = await presentEncounter({
          id: "seed_b09_caravan_ledger",
          title: "Passing caravan ledger",
          subtitle: ctx.location,
          body: [
            "Canvas tops ripple as a passing caravan slows. A trader sets a ledger on a crate, leather and spice thick in the dust.",
            "Quiet eyes watch your team while mules nose at feed sacks.",
          ],
          tags: ["travel", "trade"],
          options: [
            {
              id: "trade",
              label: "Trade (open ledger)",
              tone: "warm",
              hint: "Light caravan stock; terms hinge on your standing.",
            },
            {
              id: "chat",
              label: "Chat by the wagons",
              tone: "neutral",
              hint: "Swap news; ease nerves a touch.",
            },
            { id: "move", label: "Move on", tone: "neutral", hint: "Keep the team rolling." },
          ],
          defaultId: "trade",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b09_caravan_ledger_time", nowHour);
        let logText = "The caravan keeps its ledger shut as you roll past.";
        if (selection === "trade") {
          adjustFactionRep("caravans", 1, null, ctx);
          logText = "You thumb through the caravan ledger and trade for what they'll spare.";
          addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
          openVendorTradeModal("caravans", "caravan_peddler");
          return;
        } else if (selection === "chat") {
          adjustFactionRep("caravans", 1, null, ctx);
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) - 1, 0, 100);
          logText = "You share trail news and a quiet nod before they roll on.";
        } else if (selection === "move") {
          logText = "You wave the caravan by and keep the oxen steady.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
      },
    },
    {
      id: "seed_b10_quiet_ledger",
      kind: "minor",
      condition: function (ctx) {
        return (
          ctx.storyState.mythicEnabled !== false &&
          ctx.mode === "camp" &&
          ctx.block === "night" &&
          getEventFlag("men_in_gray_contact") === true &&
          hoursSinceFlag("seed_b10_quiet_ledger_time") >= 168 &&
          hoursSinceFlag("seed_b_global_time") >= 36
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const selection = await presentEncounter({
          id: "seed_b10_quiet_ledger",
          title: "Quiet ledger in the dark",
          subtitle: ctx.location,
          body: [
            "Men in gray set a small ledger on a crate, its pages already opened to a neat column of figures.",
          ],
          tags: ["camp", "mythic", "trade"],
          options: [
            { id: "open", label: "Open the quiet ledger (trade)", tone: "warm", hint: "Contraband rates stay hushed." },
            {
              id: "ask",
              label: "Ask what the forts whisper about",
              tone: "neutral",
              hint: "Gauge the rumors; tension shifts.",
            },
            { id: "send", label: "Send them away", tone: "danger", hint: "Risk slight offense." },
          ],
          defaultId: "open",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b10_quiet_ledger_time", nowHour);
        let logText = "The gray coats wait in silence, ledger untouched.";
        if (selection === "open") {
          adjustFactionRep("men_in_gray", 1, null, ctx);
          setEventFlag("seed_b10_quiet_ledger_opened", true);
          logText = "You scan the quiet ledger; the gray coats nod once as you trade.";
          addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
          recordStoryBeat("seed", "mythic", "Opened the quiet ledger", { choice: selection });
          openVendorTradeModal("men_in_gray", "men_in_gray_ledger");
          return;
        } else if (selection === "ask") {
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) + 1, 0, 100);
          logText = "You ask about fort whispers; they mention stamped tariffs and rival clerks with thin smiles.";
        } else if (selection === "send") {
          adjustFactionRep("men_in_gray", -1, null, ctx);
          logText = "You wave them off. The ledger snaps shut without a word.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "mythic", "Turned away the quiet ledger", { choice: selection });
      },
    },
    {
      id: "seed_b03_men_in_gray_sighting",
      kind: "minor",
      condition: function (ctx) {
        return (
          ctx.storyState.mythicEnabled !== false &&
          ctx.mode === "camp" &&
          ctx.block === "night" &&
          hoursSinceFlag("seed_b03_men_in_gray_sighting_time") >= 168 &&
          hoursSinceFlag("seed_b_global_time") >= 36
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const selection = await presentEncounter({
          id: "seed_b03_men_in_gray_sighting",
          title: "Men in gray linger",
          subtitle: ctx.location,
          body: [
            "Figures in gray coats stand just beyond the lantern light, hats low, too quiet for travelers.",
          ],
          tags: ["camp", "mythic"],
          options: [
            { id: "hail", label: "Hail them", tone: "neutral", hint: "Spend a little water; maybe gain coin." },
            { id: "hide", label: "Stay quiet", tone: "warm", hint: "Lower the camp's tension." },
            { id: "drive", label: "Drive them off", tone: "danger", hint: "Costs ammo; could spark trouble." },
          ],
          defaultId: "hail",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b03_men_in_gray_sighting_time", nowHour);
        let logText = "You keep the lamps low until the gray coats melt back into the night.";
        if (selection === "hail") {
          const terms = getTradeTermsForFaction("men_in_gray");
          const waterCost = Math.max(1, Math.round(1 * terms.costMult));
          const payout = Math.max(3, Math.round(4 * terms.gainMult));
          gameState.supplies.water = Math.max(0, (gameState.supplies.water || 0) - waterCost);
          gameState.money = (gameState.money || 0) + payout;
          adjustFactionRep("men_in_gray", 6, null, ctx);
          ctx.storyState.mythicRumor = clamp((ctx.storyState.mythicRumor || 0) + 2, 0, 100);
          setEventFlag("men_in_gray_contact", true);
          logText =
            "You offer a dipper of water. Silver coins change hands and the gray coats nod once before vanishing.";
        } else if (selection === "hide") {
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) - 2, 0, 100);
          setEventFlag("men_in_gray_footprints", true);
          logText = "You douse lanterns and wait. Dawn reveals neat bootprints circling the wagons.";
        } else if (selection === "drive") {
          gameState.supplies.ammo = Math.max(0, (gameState.supplies.ammo || 0) - 1);
          adjustFactionRep("men_in_gray", -8, null, ctx);
          if (Math.random() < 0.25) {
            const target = choice(ctx.people || getAllPeople());
            if (target) {
              target.condition = clamp((target.condition || 50) - 6, 0, 100);
              addAffliction(target, "sprain", { severity: 1 });
            }
          }
          logText = "Shots crack into the dark. The watchers scatter, and unease lingers over camp.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "mythic", "Saw Men in Gray at camp", { choice: selection });
      },
    },
    {
      id: "seed_b04_mirror_wagon",
      kind: "breather",
      condition: function (ctx) {
        return (
          ctx.mode === "travel" &&
          ctx.block === "noon" &&
          (ctx.weather.tempC || 0) >= 22 &&
          !ctx.weather.storm &&
          hoursSinceFlag("seed_b04_mirror_wagon_time") >= 96 &&
          hoursSinceFlag("seed_b_global_time") >= 36
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const selection = await presentEncounter({
          id: "seed_b04_mirror_wagon",
          title: "Wagon in the heat shimmer",
          subtitle: ctx.location,
          body: [
            "Heat makes the air dance. A wagon ahead looks exactly like yours until it turns where no track exists.",
          ],
          tags: ["travel", "omen"],
          options: [
            { id: "chase", label: "Chase it", tone: "danger", hint: "Costs energy; outcome uncertain." },
            { id: "signal", label: "Signal with a lantern", tone: "warm", hint: "Boost spirits; maybe spread a rumor." },
            { id: "ignore", label: "Ignore it", tone: "neutral", hint: "Stay the course." },
          ],
          defaultId: "signal",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b04_mirror_wagon_time", nowHour);
        let logText = "You keep to the ruts, the mirage wagon fading in the shimmer.";
        if (selection === "chase") {
          (ctx.people || getAllPeople()).forEach(function (p) {
            p.energy = clamp((p.energy || 50) - 3, 0, 110);
          });
          if (Math.random() < 0.5) {
            gameState.supplies.flour = (gameState.supplies.flour || 0) + 3;
            gameState.supplies.coffee = (gameState.supplies.coffee || 0) + 1;
            logText = "You push the team hard and find only a small cache—flour and coffee tucked beside the trail.";
          } else {
            gameState.supplies.firewood = Math.max(0, (gameState.supplies.firewood || 0) - 1);
            ctx.storyState.tension = clamp((ctx.storyState.tension || 0) + 1, 0, 100);
            logText = "The chase yields nothing. A dropped bundle of wood and frayed nerves are all you carry back.";
          }
        } else if (selection === "signal") {
          getAllPeople().forEach(function (p) {
            adjustPersonStat(p, "morale", 1);
          });
          if (ctx.storyState.mythicEnabled !== false) {
            ctx.storyState.mythicRumor = clamp((ctx.storyState.mythicRumor || 0) + 1, 0, 100);
          }
          setEventFlag("mirror_wagon_signal", true);
          logText = "You wave a lantern in the wavering heat. Spirits lift even as the twin wagon slips away.";
        } else if (selection === "ignore") {
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) - 3, 0, 100);
          const leader = gameState.leader || (ctx.people && ctx.people[0]);
          if (leader) {
            addThought(leader, {
              id: "mirror_wagon_focus",
              label: "Kept moving",
              value: 3,
              hoursLeft: 10,
              source: "travel",
            });
          }
          logText = "You keep everyone steady, letting the heat mirage drift aside as miles tick by.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "omen", "Chased a mirror wagon mirage", { choice: selection });
      },
    },
    {
      id: "seed_b05_milepost_twisted",
      kind: "minor",
      condition: function (ctx) {
        return (
          ctx.mode === "travel" &&
          ctx.block === "morning" &&
          hoursSinceFlag("seed_b05_milepost_twisted_time") >= 120 &&
          hoursSinceFlag("seed_b_global_time") >= 36
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const selection = await presentEncounter({
          id: "seed_b05_milepost_twisted",
          title: "Twisted milepost",
          subtitle: ctx.location,
          body: [
            "A carved milepost stands at a fork, twisted to point the wrong way. Fresh gouges hide the original marks.",
          ],
          tags: ["travel", "route"],
          options: [
            { id: "fix", label: "Set it right", tone: "warm", hint: "Slight reputation gain; ease tension." },
            { id: "leave", label: "Leave it be", tone: "neutral", hint: "Move on." },
            { id: "twist", label: "Twist it further", tone: "danger", hint: "Risk reputation; gain a dollar." },
          ],
          defaultId: "fix",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b05_milepost_twisted_time", nowHour);
        let logText = "You mark the crooked post and keep the team steady as you choose your path.";
        if (selection === "fix") {
          adjustReputation(1, "Set a milepost right");
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) - 1, 0, 100);
          logText = "You straighten the milepost and scrape clean the carving so others won’t be misled.";
        } else if (selection === "leave") {
          logText = "You study the twisted milepost, make your own choice, and move on without touching it.";
        } else if (selection === "twist") {
          adjustReputation(-2, "Left a false sign");
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) + 2, 0, 100);
          gameState.money = Math.max(0, (gameState.money || 0) + 1);
          logText = "You carve a new false trail and pocket a tossed coin from a passing wagon amused by the prank.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "route", "Found a twisted milepost", { choice: selection });
      },
    },
    {
      id: "seed_b06_open_eye_peddler",
      kind: "breather",
      condition: function (ctx) {
        const seenEye = getEventFlag("open_eye_seen") || getEventFlag("open_eye_leaflet_kept");
        const blockOk = (ctx.mode === "travel" && ctx.block === "morning") || (ctx.mode === "camp" && ctx.block === "evening");
        return (
          seenEye &&
          blockOk &&
          hoursSinceFlag("seed_b06_open_eye_peddler_time") >= 96 &&
          hoursSinceFlag("seed_b_global_time") >= 36
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const lineByRegion = {
          plains: "Their wagon smells of ink and sage; prairie grass whispers underfoot.",
          central_plains: "Bundles sway as wind combs the tallgrass beside the trail.",
          high_plains: "Dust and sky swallow the horizon; the charm's ink feels fresh against the dry air.",
          mountains: "Pines creak nearby as the peddler sets out their cloth-wrapped bundle.",
          snake_plain: "Alkali streaks the wagon wheels; the charm's eye is ringed in white salt.",
          blue_mountains: "A chill breeze carries woodsmoke; the peddler speaks softly of safe passes.",
          columbia: "Mist from distant falls beads on the inked charm dangling at their throat.",
        };
        const regionLine = lineByRegion[ctx.regionKey] || lineByRegion.plains;
        const terms = getTradeTermsForFaction("open_eye");
        const moneyCost = Math.max(2, Math.round(5 * terms.costMult));
        const flourCost = Math.max(1, Math.round(3 * terms.costMult));
        const medicineGain = Math.max(1, Math.round(1 * terms.gainMult));
        const selection = await presentEncounter({
          id: "seed_b06_open_eye_peddler",
          title: "Peddler with an inked eye charm",
          subtitle: ctx.location,
          body: [
            "A soft-spoken peddler wheels close, a small charm painted with an open eye at their throat.",
            regionLine,
            "They offer a bundled 'blessing' of herbs and cord, asking only what you can spare.",
          ],
          tags: ["cult", "trade"],
          options: [
            {
              id: "ledger",
              label: "Trade (open ledger)",
              tone: "warm",
              hint: "Open the peddler's ledger for small goods.",
            },
            {
              id: "trade",
              label: `Trade for the bundle ($${moneyCost} or ${flourCost} flour)`,
              tone: "warm",
              hint: `${terms.label} terms: +medicine or eased spirits.`,
            },
            {
              id: "listen",
              label: "Listen, then move on",
              tone: "neutral",
              hint: "A moment of calm; let tension ebb.",
            },
            {
              id: "drive",
              label: "Drive them off",
              tone: "danger",
              hint: "Costs supplies; reputation will suffer.",
            },
          ],
          defaultId: "trade",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b06_open_eye_peddler_time", nowHour);
        let logText = "The ink-eyed peddler wheels away, wagon creaking back into the dust.";
        if (selection === "ledger") {
          adjustFactionRep("open_eye", 2, null, ctx);
          logText = "You open the inked ledger; the peddler smiles thinly as you trade.";
          openVendorTradeModal("open_eye", "open_eye_peddler");
        } else if (selection === "trade") {
          let paid = false;
          if ((gameState.money || 0) >= moneyCost) {
            gameState.money = Math.max(0, (gameState.money || 0) - moneyCost);
            paid = true;
          } else if ((gameState.supplies.flour || 0) >= flourCost) {
            gameState.supplies.flour = Math.max(0, (gameState.supplies.flour || 0) - flourCost);
            paid = true;
          }
          if (paid) {
            gameState.supplies.med_kits = (gameState.supplies.med_kits || 0) + medicineGain;
            adjustFactionRep("open_eye", 4, null, ctx);
            const target = choice(ctx.people || getAllPeople());
            if (target) {
              addThought(target, {
                id: "open_eye_bundle",
                label: "Carried a blessing bundle",
                value: 2,
                hoursLeft: 10,
                source: "cult",
              });
            }
            logText = "You swap a few staples for the bundle; the charm watcher nods and wishes safe miles.";
          } else {
            logText = "Short on coin and flour, you pass on the offer and the peddler shrugs into the ruts.";
          }
        } else if (selection === "listen") {
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) - 1, 0, 100);
          const target = choice(ctx.people || getAllPeople());
          if (target) {
            addThought(target, {
              id: "open_eye_sermon",
              label: "Heard the open eye's words",
              value: 1,
              hoursLeft: 8,
              source: "cult",
            });
          }
          logText = "You listen to their soft assurances, then move on with nerves a shade steadier.";
        } else if (selection === "drive") {
          gameState.supplies.ammo = Math.max(0, (gameState.supplies.ammo || 0) - 1);
          adjustFactionRep("open_eye", -6, null, ctx);
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) + 2, 0, 100);
          const target = choice(ctx.people || getAllPeople());
          if (target) {
            addThought(target, {
              id: "open_eye_runoff",
              label: "Chased off a peddler",
              value: -2,
              hoursLeft: 6,
              source: "guard",
            });
          }
          logText = "You snap at the peddler and send them packing, their charm flashing once as they go.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "cult", "Met an ink-eyed peddler", { choice: selection });
      },
    },
    {
      id: "seed_b07_men_in_gray_offer",
      kind: "minor",
      condition: function (ctx) {
        return (
          ctx.storyState.mythicEnabled !== false &&
          ctx.mode === "camp" &&
          ctx.block === "night" &&
          hoursSinceFlag("seed_b07_men_in_gray_offer_time") >= 168 &&
          hoursSinceFlag("seed_b_global_time") >= 36
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const terms = getTradeTermsForFaction("men_in_gray");
        const price = Math.max(2, Math.round(5 * terms.costMult));
        const waterAsk = Math.max(1, Math.round(2 * terms.costMult));
        const payout = Math.max(4, Math.round(9 * terms.gainMult));
        const selection = await presentEncounter({
          id: "seed_b07_men_in_gray_offer",
          title: "Men in Gray make an offer",
          subtitle: ctx.location,
          body: [
            "Gray-coated figures appear at the edge of camp with a wrapped token, offering quiet protection for a price.",
          ],
          tags: ["camp", "mythic", "trade"],
          options: [
            {
              id: "accept",
              label: `Accept the offer ($${price} or ${waterAsk} water)`,
              tone: "neutral",
              hint: `${terms.label} terms; reward scales with standing.`,
            },
            {
              id: "silent",
              label: "Stay silent",
              tone: "warm",
              hint: "Lower tension; they leave faint tracks.",
            },
            {
              id: "refuse",
              label: "Refuse harshly",
              tone: "danger",
              hint: "Spend ammo; risk injury and sour relations.",
            },
          ],
          defaultId: "accept",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b07_men_in_gray_offer_time", nowHour);
        let logText = "The gray coats slip away without another word.";
        if (selection === "accept") {
          let paid = false;
          if ((gameState.money || 0) >= price) {
            gameState.money = Math.max(0, (gameState.money || 0) - price);
            paid = true;
          } else if ((gameState.supplies.water || 0) >= waterAsk) {
            gameState.supplies.water = Math.max(0, (gameState.supplies.water || 0) - waterAsk);
            paid = true;
          }
          if (paid) {
            gameState.money = (gameState.money || 0) + payout;
            adjustFactionRep("men_in_gray", 4, null, ctx);
            setEventFlag("men_in_gray_token", true);
            const target = choice(ctx.people || getAllPeople());
            if (target) {
              addThought(target, {
                id: "gray_token_whisper",
                label: "Accepted gray token",
                value: 2,
                hoursLeft: 12,
                source: "mythic",
              });
            }
            logText = "Coins and water change hands; the gray coats leave a token that feels heavier than metal.";
          } else {
            logText = "Unable to meet their price, you watch them fade back into the dark without a deal.";
          }
        } else if (selection === "silent") {
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) - 1, 0, 100);
          setEventFlag("men_in_gray_footprints", true);
          logText = "You wait them out. By dawn only crisp bootprints remain around camp.";
        } else if (selection === "refuse") {
          gameState.supplies.ammo = Math.max(0, (gameState.supplies.ammo || 0) - 1);
          adjustFactionRep("men_in_gray", -7, null, ctx);
          if (Math.random() < 0.35) {
            const target = choice(ctx.people || getAllPeople());
            if (target) {
              target.condition = clamp((target.condition || 50) - 5, 0, 100);
              addAffliction(target, "bruise", { severity: 1 });
            }
          }
          logText = "You bark them off with a warning shot; shadows scatter and unease lingers.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "mythic", "Men in Gray made an offer", { choice: selection });
      },
    },
    {
      id: "seed_b08_paper_sun_dusk",
      kind: "breather",
      condition: function (ctx) {
        return (
          ctx.mode === "travel" &&
          (ctx.block === "noon" || ctx.block === "evening") &&
          hoursSinceFlag("seed_b08_paper_sun_dusk_time") >= 84 &&
          hoursSinceFlag("seed_b_global_time") >= 36
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const lineByRegion = {
          mountains: "Peaks look cut from paper, the sun a punched-out disk hovering over the pass.",
          snake_plain: "Heat makes the sage shimmer until the sun seems pasted on a white sky.",
          columbia: "Mist from the gorge turns light into layered sheets, the wagon's shadow doubled on the water.",
        };
        const regionLine = lineByRegion[ctx.regionKey] ||
          "Wagon shadows stretch thin and strange, as if another team walks beside you.";
        const selection = await presentEncounter({
          id: "seed_b08_paper_sun_dusk",
          title: "Paper sun at dusk",
          subtitle: ctx.location,
          body: [
            "The sky feels wrong for a moment—a paper-thin sun and an echo of your wagon rolling just out of sight.",
            regionLine,
          ],
          tags: ["travel", "omen"],
          options: [
            { id: "write", label: "Write it down", tone: "neutral", hint: "A thought for the journal; tension eases." },
            { id: "share", label: "Share it at the fire", tone: "warm", hint: "Lift morale for a bit." },
            { id: "shake", label: "Shake it off", tone: "neutral", hint: "Focus ahead; steady the team." },
          ],
          defaultId: "share",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b08_paper_sun_dusk_time", nowHour);
        let logText = "The odd light passes and the wagon creaks on.";
        if (selection === "write") {
          const leader = getActiveLeader();
          if (leader) {
            addThought(leader, {
              id: "paper_sun_note",
              label: "Noted the paper sun",
              value: 2,
              hoursLeft: 12,
              source: "journal",
            });
          }
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) - 1, 0, 100);
          logText = "You jot the paper-sun moment into your journal, easing nerves a notch.";
        } else if (selection === "share") {
          (ctx.people || getAllPeople()).forEach(function (p) {
            adjustPersonStat(p, "morale", 1);
          });
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) - 1, 0, 100);
          logText = "You share the tale at the fire; laughter and wonder chase off the strange chill.";
        } else if (selection === "shake") {
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) - 2, 0, 100);
          logText = "You shake the image loose and focus on the trail ahead.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "omen", "Saw a paper-thin sun", { choice: selection });
      },
    },
    {
      id: "seed_b11_tariff_stamp",
      kind: "minor",
      condition: function (ctx) {
        const recent = findRecentTrade(function (e, hrsAgo) {
          if (hrsAgo > 72) return false;
          if (e.vendor !== "forts") return false;
          if (!e.vendorPoi) return false;
          const def = getFortTradeDef(e.vendorPoi);
          const policy = getFortPolicyForTradeDef(def);
          if (!policy) return false;
          return (policy.buyTariffPct || 0) >= 0.08 || (policy.sellTariffPct || 0) >= 0.04;
        });
        return (
          ctx.mode === "camp" &&
          (ctx.block === "evening" || ctx.block === "night") &&
          hoursSinceFlag("seed_b11_tariff_stamp_time") >= 168 &&
          hoursSinceFlag("seed_b_global_time") >= 36 &&
          !!recent
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const recent = findRecentTrade(function (e, hrsAgo) {
          if (hrsAgo > 72) return false;
          if (e.vendor !== "forts") return false;
          if (!e.vendorPoi) return false;
          const def = getFortTradeDef(e.vendorPoi);
          const policy = getFortPolicyForTradeDef(def);
          if (!policy) return false;
          return (policy.buyTariffPct || 0) >= 0.08 || (policy.sellTariffPct || 0) >= 0.04;
        });
        if (!recent || !recent.entry) return;
        const nowHour = getCurrentTrailHour(gameState);
        const tradeDef = getFortTradeDef(recent.entry.vendorPoi);
        const policy = getFortPolicyForTradeDef(tradeDef) || {};
        const fortLabel = (tradeDef && tradeDef.label) || "the last fort";
        const regionLine =
          {
            mountains: "Ink beads on the page like dew on granite, each tariff mark hard as the peaks.",
            snake_plain: "Dust from the sage seems trapped in the ink; the stamp looks sun-bleached already.",
            columbia: "Moist river air smudges the mark, as if the seal had crossed water in secret.",
          }[ctx.regionKey] || "The mark wasn't there before—a fresh stamp pressed over your ledger lines.";
        const selection = await presentEncounter({
          id: "seed_b11_tariff_stamp",
          title: "A tariff stamp appears",
          subtitle: ctx.location,
          body: [
            "You flip through your trade notes and freeze. A small tariff stamp has appeared beside the last fort's entry.",
            regionLine,
            "The ink looks official, matching " + fortLabel + "'s seal though you don't recall it being there.",
          ],
          tags: ["camp", "trade"],
          options: [
            { id: "pay", label: "Pay the duty quietly", tone: "neutral", hint: "Settle accounts before anyone asks." },
            { id: "dispute", label: "Dispute it at the next post", tone: "warm", hint: "Argue the charge later." },
            { id: "forge", label: "Scratch in your own figures", tone: "danger", hint: "Risk a harsher audit." },
          ],
          defaultId: "pay",
        });
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b11_tariff_stamp_time", nowHour);
        setEventFlag("b11_lastFortPoi", recent.entry.vendorPoi);
        setEventFlag("b11_choice", selection);
        const ss = ensureStoryState();
        let logText = "You note the phantom tariff stamp and move on.";
        const baseCost = clamp(roundToCents((gameState.money || 0) * 0.03), 2, 12);
        const tariffPct = Math.max(policy.buyTariffPct || 0, policy.sellTariffPct || 0);
        const moneyCost = clamp(roundToCents(baseCost * (1 + tariffPct)), 1, 25);
        if (selection === "pay") {
          let paid = false;
          if ((gameState.money || 0) >= moneyCost) {
            gameState.money = Math.max(0, (gameState.money || 0) - moneyCost);
            paid = true;
          }
          adjustFactionRep("forts", 2, null, ctx);
          ss.tension = clamp((ss.tension || 0) - 1, 0, 100);
          logText = paid
            ? "You settle the stamped duty quietly and hope the ledger stays closed."
            : "You acknowledge the stamp but lack the coin; you promise to settle next post.";
        } else if (selection === "dispute") {
          setEventFlag("b11_dispute_pending", true);
          adjustFactionRep("forts", -1, null, ctx);
          ss.tension = clamp((ss.tension || 0) + 1, 0, 100);
          logText = "You mark the stamp for dispute at the next fort, readying your arguments.";
        } else if (selection === "forge") {
          setEventFlag("b11_forged_stamp", true);
          const take = clamp(3 + Math.round(Math.random() * 7), 3, 10);
          gameState.money = (gameState.money || 0) + take;
          adjustFactionRep("forts", -3, null, ctx);
          ss.tension = clamp((ss.tension || 0) + 2, 0, 100);
          logText = "You scrape and rewrite the figures, pocketing a little more for the risk.";
        }
        const thoughtTarget = getActiveLeader() || choice(ctx.people || getAllPeople());
        if (thoughtTarget) {
          addThought(thoughtTarget, {
            id: "tariff_stamp_mark",
            label: selection === "dispute" ? "Argued over ledger duty" : "Studied the tariff stamp",
            value: selection === "forge" ? -1 : 1,
            hoursLeft: 12,
            source: "camp",
          });
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "trade", "Tariff stamp", {
          choice: selection,
          fort: recent.entry.vendorPoi,
        });
      },
    },
    {
      id: "seed_b11_tariff_followup",
      kind: "minor",
      condition: function (ctx) {
        const dispute = getEventFlag("b11_dispute_pending") === true;
        const forged = getEventFlag("b11_forged_stamp") === true;
        const sinceStamp = hoursSinceFlag("seed_b11_tariff_stamp_time");
        const atFort = ctx.location && (ctx.location.indexOf("Fort") >= 0 || ctx.location.indexOf("Mission") >= 0);
        return (
          (dispute || forged) &&
          sinceStamp >= 24 &&
          sinceStamp <= 168 &&
          hoursSinceFlag("seed_b11_tariff_followup_time") >= 168 &&
          atFort
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const dispute = getEventFlag("b11_dispute_pending") === true;
        const forged = getEventFlag("b11_forged_stamp") === true;
        if (!dispute && !forged) return;
        const nowHour = getCurrentTrailHour(gameState);
        const ss = ensureStoryState();
        const subtitle = ctx.location || "Fort gate";
        const bodyLine = dispute
          ? "A clerk at the counter taps the stamped line on your ledger, eyebrow raised."
          : "The gate officer squints at the stamp and the shaky figures beside it.";
        const options = dispute
          ? [
              { id: "pay", label: "Back down and pay", tone: "neutral", hint: "Lose a bit of coin; ease the clerk." },
              { id: "hold", label: "Hold your ground", tone: "danger", hint: "Risk souring the post." },
            ]
          : [
              { id: "bribe", label: "Offer a bribe", tone: "danger", hint: "Coin for quiet." },
              { id: "ignorant", label: "Play ignorant", tone: "neutral", hint: "Hope they let it slide." },
            ];
        const selection = await presentEncounter({
          id: "seed_b11_tariff_followup",
          title: dispute ? "Tariff dispute at the counter" : "Clerk eyes your stamp",
          subtitle: subtitle,
          body: [bodyLine],
          tags: ["trade", "fort"],
          options: options,
          defaultId: options[0].id,
        });
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b11_tariff_followup_time", nowHour);
        let logText = "The tariff note is set aside without incident.";
        if (dispute) {
          if (selection === "pay") {
            const cost = clamp(roundToCents((gameState.money || 0) * 0.02), 1, 10);
            if ((gameState.money || 0) >= cost) {
              gameState.money = Math.max(0, (gameState.money || 0) - cost);
            }
            adjustFactionRep("forts", 1, null, ctx);
            logText = "You pay the tariff and the clerk stamps a quiet resolution.";
          } else if (selection === "hold") {
            adjustFactionRep("forts", -3, null, ctx);
            const target = getActiveLeader() || choice(ctx.people || getAllPeople());
            if (target) {
              addThought(target, {
                id: "tariff_argued",
                label: "Held firm against a tariff",
                value: -2,
                hoursLeft: 10,
                source: "camp",
              });
            }
            logText = "You argue the stamp is wrong; the clerk frowns and waves you through curtly.";
          }
          setEventFlag("b11_dispute_pending", false);
        } else if (forged) {
          if (selection === "bribe") {
            const cost = clamp(roundToCents((gameState.money || 0) * 0.04), 2, 14);
            if ((gameState.money || 0) >= cost) {
              gameState.money = Math.max(0, (gameState.money || 0) - cost);
            }
            adjustFactionRep("forts", -1, null, ctx);
            logText = "A few coins slide across; the clerk's ledger closes with a sigh.";
          } else if (selection === "ignorant") {
            if (Math.random() < 0.5) {
              ss.tension = clamp((ss.tension || 0) + 1, 0, 100);
              logText = "You plead ignorance. The clerk scolds you and stamps a warning.";
            } else {
              adjustFactionRep("forts", -3, null, ctx);
              setEventFlag("forts_audit_watch_time", nowHour);
              logText = "The ruse fails; a harsher note goes in the ledger and a watch is logged.";
            }
          }
          setEventFlag("b11_forged_stamp", false);
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "trade", "Tariff stamp follow-up", { choice: selection });
      },
    },
    {
      id: "seed_b12_rival_stamp_whisper",
      kind: "breather",
      condition: function (ctx) {
        const recentRep =
          getHoursSinceRepChange("forts") <= 72 || getHoursSinceRepChange("open_eye") <= 72;
        const recentLedger = findRecentTrade(function (e, hrsAgo) {
          return hrsAgo <= 120;
        });
        return (
          (ctx.mode === "travel" || ctx.mode === "camp") &&
          hoursSinceFlag("seed_b12_rival_stamp_whisper_time") >= 168 &&
          hoursSinceFlag("seed_b_global_time") >= 36 &&
          recentRep &&
          !!recentLedger
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const nowHour = getCurrentTrailHour(gameState);
        const regionLine =
          {
            mountains: "Someone scrawled a note about tariffs climbing where the passes pinch the road.",
            snake_plain: "The whisper names alkali posts and clerks tightening stamps after caravan squabbles.",
            columbia: "Ink mentions river forts relaxing one fee while doubling another if barges are late.",
          }[ctx.regionKey] || "A margin note hints rival clerks will shift tariffs soon—no source is cited.";
        const selection = await presentEncounter({
          id: "seed_b12_rival_stamp_whisper",
          title: "Whispered stamp forecast",
          subtitle: ctx.location,
          body: [
            "A companion reads a faded margin note: a rumor about tariffs and rival clerks jostling for coin.",
            regionLine,
          ],
          tags: ["travel", "trade"],
          options: [
            { id: "laugh", label: "Laugh it off", tone: "neutral", hint: "Ease the air." },
            { id: "write", label: "Write it down", tone: "warm", hint: "Journal the whisper." },
            { id: "count", label: "Count the goods twice", tone: "neutral", hint: "A brief pause to double-check." },
          ],
          defaultId: "laugh",
        });
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b12_rival_stamp_whisper_time", nowHour);
        let logText = "The rumor fades with the trail dust.";
        if (selection === "laugh") {
          ensureStoryState().tension = clamp((ensureStoryState().tension || 0) - 1, 0, 100);
          logText = "You laugh it off, shaking some edge from the air.";
        } else if (selection === "write") {
          const leader = getActiveLeader();
          if (leader) {
            addThought(leader, {
              id: "stamp_whisper_note",
              label: "Noted the tariff whisper",
              value: 2,
              hoursLeft: 16,
              source: "journal",
            });
            adjustPersonStat(leader, "morale", 1);
          }
          logText = "You jot the whisper down, treating it like a lead worth keeping.";
        } else if (selection === "count") {
          const until = nowHour + 24;
          setEventFlag("b12_cautious_until", until);
          ensureStoryState().tension = clamp((ensureStoryState().tension || 0) - 1, 0, 100);
          logText = "You halt long enough to count crates twice, deciding to tread carefully for a day.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "trade", "Heard a rival tariff whisper", { choice: selection });
      },
    },
    {
      id: "seed_b13_open_eye_receipt",
      kind: "minor",
      condition: function (ctx) {
        const openEyeRecent = getHoursSinceRepChange("open_eye") <= 96;
        const recentTrade = findRecentTrade(function (e, hrsAgo) {
          return hrsAgo <= 120 && e.vendor === "open_eye";
        });
        return (
          ctx.mode === "camp" &&
          (ctx.block === "morning" || ctx.block === "evening") &&
          hoursSinceFlag("seed_b13_open_eye_receipt_time") >= 168 &&
          hoursSinceFlag("seed_b_global_time") >= 36 &&
          (openEyeRecent || !!recentTrade)
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const nowHour = getCurrentTrailHour(gameState);
        const selection = await presentEncounter({
          id: "seed_b13_open_eye_receipt",
          title: "Sealed receipt by the fire",
          subtitle: ctx.location,
          body: [
            "An ink-eyed traveler sits near the wagon, holding a folded receipt sealed with a faint eye symbol.",
            "They ask you to hand it to the next fort clerk who minds tariffs.",
          ],
          tags: ["camp", "trade"],
          options: [
            { id: "take", label: "Take the sealed receipt", tone: "warm", hint: "Carry it to the next fort." },
            { id: "bless", label: "Ask for a small blessing instead", tone: "neutral", hint: "Skip the errand." },
            { id: "decline", label: "Decline", tone: "neutral", hint: "Avoid entanglement." },
          ],
          defaultId: "take",
        });
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b13_open_eye_receipt_time", nowHour);
        let logText = "The traveler nods and vanishes into the trees.";
        if (selection === "take") {
          setEventFlag("b13_receipt_pending", true);
          setEventFlag("b13_receipt_deadline_hour", nowHour + 240);
          adjustFactionRep("open_eye", 2, null, ctx);
          ensureStoryState().tension = clamp((ensureStoryState().tension || 0) + 1, 0, 100);
          logText = "You take the sealed receipt, promising to hand it over at the next fort.";
        } else if (selection === "bless") {
          (ctx.people || getAllPeople()).forEach(function (p) {
            adjustPersonStat(p, "morale", 1);
          });
          ensureStoryState().tension = clamp((ensureStoryState().tension || 0) - 1, 0, 100);
          logText = "You ask for a simple blessing instead; the traveler smiles and whispers a quiet thanks.";
        } else if (selection === "decline") {
          ensureStoryState().tension = clamp((ensureStoryState().tension || 0) - 1, 0, 100);
          logText = "You decline the errand and keep the fire fed instead.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "trade", "Open-eye receipt offered", { choice: selection });
      },
    },
    {
      id: "seed_b13_open_eye_delivery",
      kind: "minor",
      condition: function (ctx) {
        const pending = getEventFlag("b13_receipt_pending") === true;
        const deadline = getEventFlag("b13_receipt_deadline_hour");
        const withinDeadline = deadline == null ? true : getCurrentTrailHour(gameState) <= deadline;
        const atFort = ctx.location && (ctx.location.indexOf("Fort") >= 0 || ctx.location.indexOf("Mission") >= 0);
        return (
          pending &&
          withinDeadline &&
          hoursSinceFlag("seed_b13_open_eye_delivery_time") >= 168 &&
          atFort &&
          hoursSinceFlag("seed_b13_open_eye_receipt_time") >= 24
        );
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const pending = getEventFlag("b13_receipt_pending") === true;
        if (!pending) return;
        const nowHour = getCurrentTrailHour(gameState);
        const selection = await presentEncounter({
          id: "seed_b13_open_eye_delivery",
          title: "Clerk eyes the sealed receipt",
          subtitle: ctx.location,
          body: [
            "At the fort counter, a clerk notices the faint eye seal on the folded note you carry.",
            "Their expression tightens, waiting to see what you'll do.",
          ],
          tags: ["trade", "fort"],
          options: [
            { id: "hand", label: "Hand it over", tone: "warm", hint: "Collect a quiet reward." },
            { id: "pocket", label: "Pocket it / tear it up", tone: "danger", hint: "Risk offense." },
          ],
          defaultId: "hand",
        });
        setEventFlag("seed_b_global_time", nowHour);
        setEventFlag("seed_b13_open_eye_delivery_time", nowHour);
        setEventFlag("b13_receipt_pending", false);
        setEventFlag("b13_receipt_deadline_hour", null);
        let logText = "The sealed receipt changes nothing at the counter.";
        if (selection === "hand") {
          gameState.supplies.med_kits = (gameState.supplies.med_kits || 0) + 1;
          adjustFactionRep("open_eye", 3, null, ctx);
          adjustFactionRep("forts", -1, null, ctx);
          logText = "You hand over the seal; the clerk swaps in a small packet of supplies with a frown.";
        } else if (selection === "pocket") {
          adjustFactionRep("open_eye", -4, null, ctx);
          ensureStoryState().tension = clamp((ensureStoryState().tension || 0) + 1, 0, 100);
          logText = "You pocket the note instead; the clerk notices the seal and stiffens at the slight.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "trade", "Open-eye receipt delivered", { choice: selection });
      },
    },
  ];

  const ROUTE_MILESTONES = [
    { mile: 0, name: "Independence", region: "plains" },
    { mile: 80, name: "Kansas River crossing", region: "plains" },
    { mile: 150, name: "Big Blue River", region: "plains" },
    { mile: 300, name: "Fort Kearny", region: "central_plains" },
    { mile: 450, name: "Chimney Rock", region: "central_plains" },
    { mile: 560, name: "Fort Laramie", region: "high_plains" },
    { mile: 700, name: "Independence Rock", region: "high_plains" },
    { mile: 820, name: "South Pass", region: "high_plains" },
    { mile: 980, name: "Fort Bridger", region: "mountains" },
    { mile: 1180, name: "Fort Hall", region: "snake_plain" },
    { mile: 1450, name: "Three Island Crossing", region: "snake_plain" },
    { mile: 1650, name: "Blue Mountains", region: "blue_mountains" },
    { mile: 1880, name: "The Dalles / Columbia", region: "columbia" },
    { mile: 2050, name: "Oregon City", region: "willamette" },
  ];

  const SCENE_BANDS = [
    {
      from: 0,
      to: 120,
      label: "Missouri farm country",
      clear: [IMAGE_URLS.leaving_independence, IMAGE_URLS.independence_start_edge],
      heat: [IMAGE_URLS.leaving_independence],
      storm: [IMAGE_URLS.prairie_storm],
    },
    {
      from: 120,
      to: 260,
      label: "Kansas River & bottomlands",
      clear: [IMAGE_URLS.kansas_bottomlands, IMAGE_URLS.kansasriver_calm_day],
      heat: [IMAGE_URLS.kansasriver_calm_day],
      storm: [IMAGE_URLS.kansasriver_danger],
    },
    {
      from: 260,
      to: 420,
      label: "Little Blue & central Platte",
      clear: [IMAGE_URLS.little_blue_spring, IMAGE_URLS.platte_clear],
      heat: [IMAGE_URLS.buffalo_plains_heat],
      storm: [IMAGE_URLS.buffalo_plains_storm],
    },
    {
      from: 420,
      to: 620,
      label: "Chimney Rock & Scotts Bluff",
      clear: [IMAGE_URLS.chimney_clear],
      heat: [IMAGE_URLS.chimney_clear],
      storm: [IMAGE_URLS.chimney_storm],
    },
    {
      from: 620,
      to: 820,
      label: "Fort Laramie & Sweetwater",
      clear: [IMAGE_URLS.fort_laramie_approach, IMAGE_URLS.register_cliffs],
      cold: [IMAGE_URLS.register_cliffs],
      storm: [IMAGE_URLS.prairie_storm],
    },
    {
      from: 820,
      to: 1050,
      label: "South Pass & high plains",
      clear: [IMAGE_URLS.south_pass_clear, IMAGE_URLS.independence_rock],
      cold: [IMAGE_URLS.south_pass_midsummer],
      storm: [IMAGE_URLS.bluemtns_flurries],
    },
    {
      from: 1050,
      to: 1400,
      label: "Snake River plain & Salmon Falls",
      clear: [IMAGE_URLS.soda_springs_warm, IMAGE_URLS.salmon_falls_summer],
      heat: [IMAGE_URLS.snake_bench_heat, IMAGE_URLS.alkali_flats_day],
      storm: [IMAGE_URLS.snake_bench_storm],
    },
    {
      from: 1400,
      to: 1700,
      label: "Grande Ronde & Blue Mountains",
      clear: [IMAGE_URLS.grande_ronde_summer, IMAGE_URLS.blue_mountains_clear],
      cold: [IMAGE_URLS.bluemtns_flurries],
      storm: [IMAGE_URLS.blue_mountains_rain],
    },
    {
      from: 1700,
      to: 1900,
      label: "Columbia Gorge & The Dalles",
      clear: [IMAGE_URLS.columbia_gorge_primary, IMAGE_URLS.dalles_primary],
      storm: [IMAGE_URLS.columbia_gorge_rain],
      cold: [IMAGE_URLS.dalles_evening],
    },
    {
      from: 1900,
      to: 2050,
      label: "Willamette Valley & Oregon City",
      clear: [IMAGE_URLS.oregon_city_primary, IMAGE_URLS.willamette_valley],
      storm: [IMAGE_URLS.oregon_city_rain],
      cold: [IMAGE_URLS.oregon_city_spring],
    },
  ];

  /* --- Monthly climate baselines by region (rough, era-appropriate) ------- */

  const CLIMATE = {
    GreatPlains: {
      monthly: {
        April: { pRain: 0.28, pStorm: 0.06, tMin: 2, tMax: 16, windKph: [8, 24] },
        May: { pRain: 0.34, pStorm: 0.1, tMin: 8, tMax: 22, windKph: [8, 28] },
        June: { pRain: 0.3, pStorm: 0.14, tMin: 13, tMax: 29, windKph: [10, 32] },
        July: { pRain: 0.25, pStorm: 0.12, tMin: 15, tMax: 33, windKph: [12, 36] },
        August: { pRain: 0.22, pStorm: 0.1, tMin: 14, tMax: 32, windKph: [10, 30] },
        September: { pRain: 0.2, pStorm: 0.08, tMin: 10, tMax: 27, windKph: [9, 26] },
      },
    },
    HighPlains: {
      monthly: {
        April: { pRain: 0.24, pStorm: 0.07, tMin: -1, tMax: 14, windKph: [10, 28] },
        May: { pRain: 0.28, pStorm: 0.1, tMin: 4, tMax: 19, windKph: [10, 30] },
        June: { pRain: 0.26, pStorm: 0.14, tMin: 9, tMax: 24, windKph: [12, 32] },
        July: { pRain: 0.22, pStorm: 0.12, tMin: 12, tMax: 29, windKph: [12, 34] },
        August: { pRain: 0.18, pStorm: 0.1, tMin: 10, tMax: 28, windKph: [10, 30] },
        September: { pRain: 0.18, pStorm: 0.08, tMin: 6, tMax: 23, windKph: [9, 28] },
      },
    },
    Rockies: {
      monthly: {
        April: { pRain: 0.26, pStorm: 0.1, tMin: -6, tMax: 11, windKph: [10, 32] },
        May: { pRain: 0.26, pStorm: 0.12, tMin: -2, tMax: 15, windKph: [10, 34] },
        June: { pRain: 0.24, pStorm: 0.16, tMin: 2, tMax: 20, windKph: [12, 36] },
        July: { pRain: 0.2, pStorm: 0.14, tMin: 6, tMax: 23, windKph: [12, 36] },
        August: { pRain: 0.18, pStorm: 0.12, tMin: 5, tMax: 22, windKph: [10, 32] },
        September: { pRain: 0.22, pStorm: 0.14, tMin: 0, tMax: 17, windKph: [10, 30] },
      },
    },
    SnakePlain: {
      monthly: {
        May: { pRain: 0.18, pStorm: 0.08, tMin: 7, tMax: 24, windKph: [8, 26] },
        June: { pRain: 0.14, pStorm: 0.1, tMin: 10, tMax: 30, windKph: [10, 30] },
        July: { pRain: 0.12, pStorm: 0.12, tMin: 13, tMax: 34, windKph: [10, 32] },
        August: { pRain: 0.1, pStorm: 0.1, tMin: 12, tMax: 33, windKph: [10, 30] },
        September: { pRain: 0.12, pStorm: 0.08, tMin: 8, tMax: 27, windKph: [8, 26] },
      },
    },
    Columbia: {
      monthly: {
        June: { pRain: 0.18, pStorm: 0.08, tMin: 9, tMax: 24, windKph: [8, 24] },
        July: { pRain: 0.16, pStorm: 0.08, tMin: 11, tMax: 27, windKph: [8, 24] },
        August: { pRain: 0.18, pStorm: 0.08, tMin: 11, tMax: 26, windKph: [8, 22] },
        September: { pRain: 0.22, pStorm: 0.12, tMin: 8, tMax: 22, windKph: [8, 22] },
        October: { pRain: 0.28, pStorm: 0.14, tMin: 5, tMax: 18, windKph: [8, 20] },
      },
    },
  };

  const PACE_CONFIG = {
    steady: { id: "steady", label: "Steady", milesPerHour: 1.5, staminaCost: 4 },
    slow: { id: "slow", label: "Slow", milesPerHour: 1.1, staminaCost: 2 },
    grueling: {
      id: "grueling",
      label: "Grueling",
      milesPerHour: 1.8,
      staminaCost: 7,
    },
    caravan_peddler: {
      label: "Ledger of a passing caravan",
      catalog: [
        "flour",
        "bacon",
        "beans_rice",
        "hardtack",
        "dried_fruit",
        "coffee",
        "sugar",
        "salt_soda",
        "firewood",
        "water_barrels",
        "ammo",
        "rifles",
        "med_kits",
      ],
      baseStock: {
        flour: 80,
        bacon: 26,
        beans_rice: 40,
        hardtack: 36,
        dried_fruit: 18,
        coffee: 12,
        sugar: 14,
        salt_soda: 10,
        firewood: 22,
        water_barrels: 4,
        ammo: 70,
        rifles: 2,
        med_kits: 6,
      },
      stockCap: {
        flour: 120,
        bacon: 40,
        beans_rice: 60,
        hardtack: 54,
        dried_fruit: 28,
        coffee: 20,
        sugar: 22,
        salt_soda: 15,
        firewood: 32,
        water_barrels: 6,
        ammo: 110,
        rifles: 3,
        med_kits: 9,
      },
      restockPerDay: {
        flour: 6,
        bacon: 2.2,
        beans_rice: 3.4,
        hardtack: 3,
        dried_fruit: 1.2,
        coffee: 1,
        sugar: 1,
        salt_soda: 0.6,
        firewood: 3,
        water_barrels: 0.35,
        ammo: 6,
        rifles: 0.08,
        med_kits: 0.25,
      },
      flavorNotes: [
        "Canvas ledger smells of dust and cardamom; pages flutter with each gust.",
        "Freighter boys tally bacon twice—once for freight, once for camp kitchens.",
        "Ruts deep as graves near the last crossing; flour shook loose in half the sacks.",
        "Night watch keeps rifles hidden until trust is earned.",
        "Coffee tins are banded with twine and road grit—ask gentle.",
      ],
    },
    open_eye_peddler: {
      label: "Inked-eye satchel",
      catalog: ["tea", "coffee", "dried_fruit", "salt_soda", "med_kits", "buffalo_chips", "ammo"],
      baseStock: { tea: 14, coffee: 8, dried_fruit: 12, salt_soda: 6, med_kits: 4, buffalo_chips: 18, ammo: 24 },
      stockCap: { tea: 22, coffee: 14, dried_fruit: 18, salt_soda: 10, med_kits: 6, buffalo_chips: 28, ammo: 36 },
      restockPerDay: { tea: 1.2, coffee: 0.8, dried_fruit: 0.8, salt_soda: 0.5, med_kits: 0.24, buffalo_chips: 1.4, ammo: 1.4 },
      flavorNotes: [
        "Steeped leaves sold with a blessing, wrapped in blue cloth.",
        "Charcoal marks an open eye on the ledger's cover, watched closely as coins change hands.",
        "They trade stories for salt-soda, listening more than they speak.",
        "Powder tins rattle softly under dried sprigs of sage.",
      ],
    },
    men_in_gray_ledger: {
      label: "Quiet Ledger",
      catalog: ["ammo", "rifles", "med_kits", "coffee", "tea", "dried_fruit", "salt_soda"],
      baseStock: {
        ammo: 52,
        rifles: 3,
        med_kits: 6,
        coffee: 10,
        tea: 14,
        dried_fruit: 12,
        salt_soda: 6,
      },
      stockCap: {
        ammo: 90,
        rifles: 4,
        med_kits: 10,
        coffee: 16,
        tea: 20,
        dried_fruit: 18,
        salt_soda: 10,
      },
      restockPerDay: {
        ammo: 4.5,
        rifles: 0.08,
        med_kits: 0.35,
        coffee: 0.9,
        tea: 1.1,
        dried_fruit: 0.8,
        salt_soda: 0.4,
      },
      flavorNotes: [
        "Pages are faintly oiled to hide notes; the ledger opens without a sound.",
        "Rifles are wrapped in gray cloth, initials stitched where a stamp should be.",
        "A dull silver token weights the corner of the page when you look away.",
      ],
    },
  };

  const RATION_CONFIG = {
    filling: {
      id: "filling",
      label: "Full rations",
      targetHunger: 80,
      targetThirst: 80,
      hungerDrainPerHour: 3,
      thirstDrainPerHour: 4,
    },
    normal: {
      id: "normal",
      label: "Normal rations",
      targetHunger: 70,
      targetThirst: 75,
      hungerDrainPerHour: 3.5,
      thirstDrainPerHour: 4.5,
    },
    meager: {
      id: "meager",
      label: "Meager rations",
      targetHunger: 60,
      targetThirst: 70,
      hungerDrainPerHour: 4.2,
      thirstDrainPerHour: 5,
    },
    barebones: {
      id: "barebones",
      label: "Bare-bones",
      targetHunger: 55,
      targetThirst: 65,
      hungerDrainPerHour: 4.8,
      thirstDrainPerHour: 5.2,
    },
  };

  const SOUND_DEFS = {
    campfire_loop: "audio/campfire-loop.ogg",
    craft_tick: "audio/craft-tick.ogg",
    log_pop: "audio/log-pop.ogg",
  };
  const soundCache = {};
  function loadSound(key) {
    if (!SOUND_DEFS[key]) return null;
    if (soundCache[key]) return soundCache[key];
    try {
      const audio = new Audio(SOUND_DEFS[key]);
      audio.preload = "auto";
      soundCache[key] = audio;
      return audio;
    } catch (e) {
      soundCache[key] = null;
      return null;
    }
  }
  function playSound(key, opts) {
    const audio = loadSound(key);
    if (!audio) return;
    try {
      audio.loop = !!(opts && opts.loop);
      audio.volume = opts && opts.volume != null ? opts.volume : 0.35;
      audio.currentTime = 0;
      audio.play();
    } catch (e) {
      // ignore audio issues in browsers that block autoplay
    }
  }

  const TASKS = [
    { id: "auto", label: "Let them decide (auto)" },
    { id: "travel", label: "Travel with wagon" },
    { id: "scout", label: "Scout ahead" },
    { id: "hunt", label: "Hunt for game" },
    { id: "gather_wood", label: "Gather wood / chips" },
    { id: "fetch_water", label: "Fetch water" },
    { id: "cook", label: "Cook meals" },
    { id: "repair", label: "Repair wagon / gear" },
    { id: "guard", label: "Stand watch / guard" },
    { id: "doctor", label: "Doctor / care" },
    { id: "rest", label: "Rest" },
    { id: "sleep", label: "Sleep" },
  ];

  // Delegation job definitions for the priority matrix
  const JOB_DEFS = [
    { id: "travel",      label: "Travel",      taskId: "travel",      relatedSkill: "travel",     vital: false },
    { id: "scout",       label: "Scout",       taskId: "scout",       relatedSkill: "travel",     vital: false },
    { id: "hunt",        label: "Hunt",        taskId: "hunt",        relatedSkill: "hunting",    vital: true  },
    { id: "cook",        label: "Cook",        taskId: "cook",        relatedSkill: "cooking",    vital: true  },
    { id: "gather_wood", label: "Wood",        taskId: "gather_wood", relatedSkill: "woodcutting", vital: false },
    { id: "fetch_water", label: "Water",       taskId: "fetch_water", relatedSkill: "travel",     vital: true  },
    { id: "repair",      label: "Repair",      taskId: "repair",      relatedSkill: "woodcutting", vital: true },
    { id: "guard",       label: "Guard",       taskId: "guard",       relatedSkill: "travel",     vital: true  },
    { id: "doctor",      label: "Doctor",      taskId: "doctor",      relatedSkill: "doctoring",  vital: true  },
  ];

  // Supplies including prepared meal types
  const SUPPLY_ITEMS = [
    {
      id: "flour",
      name: "Flour",
      category: "FOOD",
      unit: "lb",
      cost: 0.02,
      weight: 1,
      recommended: 600,
    },
    {
      id: "bacon",
      name: "Bacon / salt pork",
      category: "FOOD",
      unit: "lb",
      cost: 0.08,
      weight: 1,
      recommended: 150,
    },
    {
      id: "beans_rice",
      name: "Beans & rice",
      category: "FOOD",
      unit: "lb",
      cost: 0.06,
      weight: 1,
      recommended: 80,
    },
    {
      id: "hardtack",
      name: "Hardtack biscuits",
      category: "FOOD",
      unit: "lb",
      cost: 0.03,
      weight: 1,
      recommended: 40,
    },
    {
      id: "dried_fruit",
      name: "Dried fruit",
      category: "FOOD",
      unit: "lb",
      cost: 0.06,
      weight: 1,
      recommended: 50,
    },
    {
      id: "coffee",
      name: "Coffee",
      category: "FOOD",
      unit: "lb",
      cost: 0.10,
      weight: 1,
      recommended: 8,
    },
    {
      id: "tea",
      name: "Tea",
      category: "FOOD",
      unit: "lb",
      cost: 0.10,
      weight: 1,
      recommended: 2,
    },
    {
      id: "sugar",
      name: "Sugar & molasses",
      category: "FOOD",
      unit: "lb",
      cost: 0.08,
      weight: 1,
      recommended: 40,
    },
    {
      id: "salt_soda",
      name: "Salt & soda",
      category: "FOOD",
      unit: "lb",
      cost: 0.06,
      weight: 1,
      recommended: 12,
    },
    {
      id: "fresh_meat",
      name: "Fresh game meat",
      category: "FOOD",
      unit: "lb",
      cost: 0.05,
      weight: 1,
      recommended: 0,
      perishable: true,
      defaultMethod: "raw",
    },
    {
      id: "pickled_veg",
      name: "Pickled vegetables",
      category: "FOOD",
      unit: "lb",
      cost: 0,
      weight: 1,
      recommended: 0,
      perishable: true,
      defaultMethod: "pickled",
      readOnly: true,
    },
    {
      id: "salted_meat",
      name: "Salted meat",
      category: "FOOD",
      unit: "lb",
      cost: 0,
      weight: 1,
      recommended: 0,
      perishable: true,
      defaultMethod: "salted",
      readOnly: true,
    },
    {
      id: "trail_jerky",
      name: "Trail jerky",
      category: "FOOD",
      unit: "lb",
      cost: 0,
      weight: 0.6,
      recommended: 0,
      perishable: true,
      defaultMethod: "dried",
      readOnly: true,
    },
    {
      id: "meal_simple",
      name: "Simple hot meals",
      category: "FOOD_PREPARED",
      unit: "meal",
      cost: 0,
      weight: 0.5,
      recommended: 0,
      readOnly: true,
    },
    {
      id: "meal_hearty",
      name: "Hearty suppers",
      category: "FOOD_PREPARED",
      unit: "meal",
      cost: 0,
      weight: 0.6,
      recommended: 0,
      readOnly: true,
    },
    {
      id: "meal_feast",
      name: "Trail feasts",
      category: "FOOD_PREPARED",
      unit: "meal",
      cost: 0,
      weight: 0.7,
      recommended: 0,
      readOnly: true,
    },
    {
      id: "cooked_meals",
      name: "Cooked meals (legacy)",
      category: "FOOD_PREPARED",
      unit: "meal",
      cost: 0,
      weight: 0.5,
      recommended: 0,
      readOnly: true,
    },
    {
      id: "water_barrels",
      name: "Water barrels",
      category: "WATER",
      unit: "barrel",
      cost: 3.0,
      weight: 40,
      recommended: 1,
    },
    {
      id: "water",
      name: "Water in camp (gallons)",
      category: "WATER",
      unit: "gal",
      cost: 0,
      weight: 8,
      recommended: 40,
      readOnly: true,
    },
    {
      id: "firewood",
      name: "Firewood",
      category: "FUEL",
      unit: "bundle",
      cost: 0.2,
      weight: 20,
      recommended: 4,
    },
    {
      id: "buffalo_chips",
      name: "Buffalo chips (fuel)",
      category: "FUEL",
      unit: "sack",
      cost: 0.25,
      weight: 10,
      recommended: 0,
    },
    {
      id: "oxen",
      name: "Oxen",
      category: "ANIMALS",
      unit: "head",
      cost: 30,
      weight: 0,
      recommended: 6,
    },
    {
      id: "milk_cows",
      name: "Milk cows",
      category: "ANIMALS",
      unit: "head",
      cost: 70,
      weight: 0,
      recommended: 1,
    },
    {
      id: "wheels",
      name: "Spare wheels",
      category: "PARTS",
      unit: "ea",
      cost: 10,
      weight: 60,
      recommended: 1,
    },
    {
      id: "axles",
      name: "Spare axles",
      category: "PARTS",
      unit: "ea",
      cost: 8,
      weight: 40,
      recommended: 1,
    },
    {
      id: "tongues",
      name: "Spare tongues",
      category: "PARTS",
      unit: "ea",
      cost: 8,
      weight: 40,
      recommended: 1,
    },
    {
      id: "ammo",
      name: "Ammunition",
      category: "AMMO",
      unit: "box",
      cost: 2.5,
      weight: 2,
      recommended: 10,
    },
    {
      id: "rifles",
      name: "Rifles",
      category: "AMMO",
      unit: "ea",
      cost: 15,
      weight: 8,
      recommended: 2,
    },
    {
      id: "med_kits",
      name: "Medicines & bandages",
      category: "MED",
      unit: "kit",
      cost: 6,
      weight: 2,
      recommended: 2,
    },
  ];

  // Food values for auto-eating & inventory
  const FOOD_VALUES = {
    flour: { lbsPerServing: 0.4, hungerGain: 18, moraleGain: 1 },
    bacon: { lbsPerServing: 0.4, hungerGain: 22, moraleGain: 2 },
    beans_rice: { lbsPerServing: 0.4, hungerGain: 20, moraleGain: 1 },
    hardtack: { lbsPerServing: 0.4, hungerGain: 14, moraleGain: 0 },
    dried_fruit: { lbsPerServing: 0.3, hungerGain: 10, moraleGain: 1 },
    fresh_meat: { lbsPerServing: 0.5, hungerGain: 24, moraleGain: 2, warmthGain: 1 },
    pickled_veg: { lbsPerServing: 0.35, hungerGain: 16, moraleGain: 2 },
    salted_meat: { lbsPerServing: 0.45, hungerGain: 22, moraleGain: 1, warmthGain: 1 },
    trail_jerky: { lbsPerServing: 0.35, hungerGain: 20, moraleGain: 1, warmthGain: 1 },
    meal_simple: {
      lbsPerServing: 0.5,
      hungerGain: 28,
      moraleGain: 2,
      warmthGain: 2,
      isPrepared: true,
    },
    meal_hearty: {
      lbsPerServing: 0.6,
      hungerGain: 35,
      moraleGain: 3,
      warmthGain: 2,
      energyGain: 4,
      isPrepared: true,
    },
    meal_feast: {
      lbsPerServing: 0.7,
      hungerGain: 42,
      moraleGain: 5,
      warmthGain: 3,
      energyGain: 6,
      isPrepared: true,
    },
    cooked_meals: {
      lbsPerServing: 0.5,
      hungerGain: 35,
      moraleGain: 3,
      warmthGain: 2,
      isPrepared: true,
    },
    // NEW – drinks for morale / warmth
    coffee: {
      lbsPerServing: 0.05, // ~20 cups / lb
      hungerGain: 0,
      moraleGain: 2,
      warmthGain: 1,
      energyGain: 4,
      isPrepared: true,
    },
    tea: {
      lbsPerServing: 0.04,
      hungerGain: 0,
      moraleGain: 1,
      warmthGain: 1,
      energyGain: 2,
      isPrepared: true,
    },
  };

    // Nutrition tags for the long‑term diet system
  const NUTRITION_TAGS = {
    flour:       { staples: 1.0 },
    hardtack:    { staples: 0.9 },
    beans_rice:  { staples: 0.8, meatFat: 0.4 },
    bacon:       { meatFat: 1.2 },
    fresh_meat:  { meatFat: 1.0, fruitVeg: 0.2 }, // fresh meat carries a little vitamin C
    pickled_veg:{ fruitVeg: 1.2, staples: 0.3 },
    salted_meat:{ meatFat: 0.9 },
    trail_jerky:{ meatFat: 0.8 },
    dried_fruit: { fruitVeg: 1.8 },
    meal_simple: { staples: 0.7, meatFat: 0.4, fruitVeg: 0.3 },
    meal_hearty: { staples: 0.6, meatFat: 0.6, fruitVeg: 0.5 },
    meal_feast:  { staples: 0.5, meatFat: 0.8, fruitVeg: 0.7 },
    cooked_meals:{ staples: 0.6, meatFat: 0.5, fruitVeg: 0.3 },
    coffee:      { coffeeTea: 1.0 },
    tea:         { coffeeTea: 0.8 },
  };

  const RECIPE_DEFS = [
    {
      id: "mush_bacon",
      name: "Mush & bacon",
      tier: "meal_hearty",
      blocks: ["morning", "evening"],
      regionTags: ["plains", "central_plains", "high_plains"],
      ingredients: [
        { id: "flour", lbs: 0.45 },
        { id: "bacon", lbs: 0.25 },
      ],
      preservationMethod: "cooked",
      weight: 2,
    },
    {
      id: "beans_bacon",
      name: "Beans & bacon pot",
      tier: "meal_hearty",
      blocks: ["evening", "noon"],
      regionTags: ["plains", "central_plains", "high_plains", "mountains"],
      ingredients: [
        { id: "beans_rice", lbs: 0.4 },
        { id: "bacon", lbs: 0.35 },
      ],
      preservationMethod: "cooked",
      weight: 3,
    },
    {
      id: "trail_stew",
      name: "Trail stew",
      tier: "meal_feast",
      blocks: ["evening"],
      regionTags: ["plains", "central_plains", "high_plains", "mountains"],
      ingredients: [
        { id: "fresh_meat", lbs: 0.6 },
        { id: "flour", lbs: 0.2 },
        { id: "dried_fruit", lbs: 0.2 },
      ],
      preservationMethod: "cooked",
      weight: 2,
    },
    {
      id: "pan_fry_meat",
      name: "Meat fry-up",
      tier: "meal_feast",
      blocks: ["evening", "night"],
      regionTags: ["plains", "central_plains", "high_plains", "mountains"],
      ingredients: [
        { id: "fresh_meat", lbs: 0.8 },
        { id: "flour", lbs: 0.1 },
      ],
      preservationMethod: "cooked",
      weight: 1,
    },
    {
      id: "corn_cakes",
      name: "Corn cakes & coffee",
      tier: "meal_simple",
      blocks: ["morning", "noon"],
      regionTags: ["plains", "central_plains", "willamette"],
      ingredients: [{ id: "flour", lbs: 0.4 }],
      preservationMethod: "cooked",
      weight: 2,
    },
    {
      id: "fruit_mush",
      name: "Fruit mush",
      tier: "meal_simple",
      blocks: ["morning", "noon"],
      regionTags: ["snake_plain", "columbia", "willamette"],
      ingredients: [{ id: "dried_fruit", lbs: 0.3 }],
      preservationMethod: "cooked",
      weight: 1,
    },
    {
      id: "salmon_pot",
      name: "Salmon pot",
      tier: "meal_hearty",
      blocks: ["evening"],
      regionTags: ["snake_plain", "columbia"],
      ingredients: [
        { id: "fresh_meat", lbs: 0.5 },
        { id: "beans_rice", lbs: 0.2 },
        { id: "dried_fruit", lbs: 0.15 },
      ],
      preservationMethod: "cooked",
      weight: 2,
    },
    {
      id: "willamette_stew",
      name: "Willamette root stew",
      tier: "meal_hearty",
      blocks: ["evening"],
      regionTags: ["blue_mountains", "willamette"],
      ingredients: [
        { id: "fresh_meat", lbs: 0.4 },
        { id: "beans_rice", lbs: 0.25 },
        { id: "dried_fruit", lbs: 0.15 },
      ],
      preservationMethod: "cooked",
      weight: 2,
    },
    {
      id: "hardtack_fry",
      name: "Fried hardtack",
      tier: "meal_simple",
      blocks: ["noon", "night", "morning"],
      regionTags: ["plains", "central_plains", "high_plains", "mountains", "snake_plain"],
      ingredients: [{ id: "hardtack", lbs: 0.35 }],
      preservationMethod: "cooked",
      weight: 1,
    },
    {
      id: "smoke_strips",
      name: "Smoked strips for the road",
      kind: "preserve",
      blocks: ["evening", "noon"],
      regionTags: ["plains", "high_plains", "mountains", "snake_plain"],
      ingredients: [
        { id: "fresh_meat", lbs: 2.0 },
        { id: "salt_soda", lbs: 0.1 },
      ],
      outputSupply: "fresh_meat",
      outputQty: 1.8,
      preservationMethod: "smoked",
      weight: 1,
    },
  ];


  const WATER_PER_DRINK = 0.25; // gallons per drink

  const START_PROFILES = {
    early_april: {
      id: "early_april",
      label: "Early April – high rivers & cold",
      summary:
        "Snowmelt keeps the Missouri and Platte swollen; nights are cold and grass is weak.",
      riverHazard: "high",
      heatHazard: "low",
      forageBonus: "low",
      lateSeasonRisk: "low",
      startMonth: 3,
      startDay: 10,
    },
    late_april: {
      id: "late_april",
      label: "Late April – balanced window",
      summary:
        "Classic departure window as rivers fall and new grass appears across the plains.",
      riverHazard: "medium",
      heatHazard: "medium",
      forageBonus: "medium",
      lateSeasonRisk: "medium",
      startMonth: 3,
      startDay: 25,
    },
    mid_may: {
      id: "mid_may",
      label: "Mid May – good grass, some storms",
      summary:
        "Plenty of grass and milder nights, but spring storms can still sweep the prairie.",
      riverHazard: "medium",
      heatHazard: "medium",
      forageBonus: "high",
      lateSeasonRisk: "medium",
      startMonth: 4,
      startDay: 15,
    },
    early_june: {
      id: "early_june",
      label: "Early June – hot plains ahead",
      summary:
        "Most rivers have crested. Expect hotter days, stronger thunderstorms, and dusty drives.",
      riverHazard: "low",
      heatHazard: "high",
      forageBonus: "high",
      lateSeasonRisk: "medium",
      startMonth: 5,
      startDay: 5,
    },
    mid_july: {
      id: "mid_july",
      label: "Mid July – late for the passes",
      summary:
        "Heat and dust on the Platte and Snake, and an anxious race to beat autumn snows in the mountains.",
      riverHazard: "low",
      heatHazard: "high",
      forageBonus: "medium",
      lateSeasonRisk: "high",
      startMonth: 6,
      startDay: 10,
    },
  };

  const AFFLICTION_DEFS = {
    dysentery: {
      id: "dysentery",
      label: "Dysentery",
      type: "disease",
      baseHoursIncubation: [6, 20],
      baseHoursAcute: [32, 90],
      baseHoursRecovery: [40, 80],
      severityRange: [1, 2],
      cause: "bad water in cholera corridor",
      tags: ["waterborne"],
      crisisThreshold: 25,
    },
    cholera: {
      id: "cholera",
      label: "Cholera",
      type: "disease",
      baseHoursIncubation: [4, 14],
      baseHoursAcute: [26, 80],
      baseHoursRecovery: [60, 110],
      severityRange: [2, 3],
      cause: "contaminated river water through the corridor",
      tags: ["waterborne", "contagious"],
      crisisThreshold: 30,
    },
    camp_fever: {
      id: "camp_fever",
      label: "Camp fever",
      type: "disease",
      baseHoursIncubation: [24, 72],
      baseHoursAcute: [48, 144],
      baseHoursRecovery: [36, 80],
      severityRange: [1, 3],
      cause: "weeks of poor rest and damp camps",
      tags: ["contagious"],
      crisisThreshold: 20,
    },
    camp_scurvy: {
      id: "camp_scurvy",
      label: "Camp scurvy",
      type: "disease",
      baseHoursIncubation: [96, 160],
      baseHoursAcute: [200, 320],
      baseHoursRecovery: [120, 180],
      severityRange: [1, 2],
      cause: "weeks without greens or fruit",
      tags: ["nutrition"],
      crisisThreshold: 15,
    },
    mountain_pneumonia: {
      id: "mountain_pneumonia",
      label: "Mountain pneumonia",
      type: "disease",
      baseHoursIncubation: [18, 48],
      baseHoursAcute: [72, 150],
      baseHoursRecovery: [60, 120],
      severityRange: [2, 3],
      cause: "thin, frigid air in the passes",
      tags: ["cold", "respiratory"],
      crisisThreshold: 25,
    },
    snakebite: {
      id: "snakebite",
      label: "Snakebite",
      type: "injury",
      baseHoursIncubation: [0, 2],
      baseHoursAcute: [48, 120],
      baseHoursRecovery: [50, 120],
      severityRange: [2, 3],
      cause: "stepping near brush or creek banks",
      tags: ["injury"],
      crisisThreshold: 20,
    },
    broken_bone: {
      id: "broken_bone",
      label: "Broken bone",
      type: "injury",
      baseHoursIncubation: [0, 1],
      baseHoursAcute: [140, 280],
      baseHoursRecovery: [160, 320],
      severityRange: [2, 3],
      cause: "wagon mishap or hard fall",
      tags: ["injury"],
      crisisThreshold: 30,
    },
    sprain: {
      id: "sprain",
      label: "Sprained ankle",
      type: "injury",
      baseHoursIncubation: [0, 1],
      baseHoursAcute: [24, 72],
      severityRange: [1, 1],
      cause: "misstep on rough ground",
    },
  };

  const CAMP_TASKS = [
    {
      id: "cook_hot_meal",
      label: "Cook a hot meal",
      hours: 2,
      effects: { hunger: 18, morale: 4, warmth: 2 },
      desc: "Warm stew, coffee, and flour cakes for the group.",
      priority: "food",
    },
    {
      id: "gather_fuel",
      label: "Gather fuel",
      hours: 1.5,
      effects: { warmth: 6, energy: -2 },
      desc: "Collect wood or buffalo chips for the night fire.",
      priority: "safety",
    },
    {
      id: "fetch_and_boil_water",
      label: "Fetch & boil water",
      hours: 1.5,
      effects: { thirst: 18, condition: 1 },
      desc: "Haul water, boil to cut illness risk.",
      priority: "water",
    },
    {
      id: "mend_clothes_and_boots",
      label: "Mend clothes & boots",
      hours: 1.5,
      effects: { warmth: 4, condition: 3, morale: 2 },
      desc: "Patch canvas, resew soles.",
      priority: "repair",
    },
    {
      id: "repair_wagon_and_tackle",
      label: "Repair wagon & tackle",
      hours: 1.5,
      effects: { wagon: 6, energy: -2 },
      desc: "Tighten bolts, grease wheels, check yokes.",
      priority: "repair",
    },
    {
      id: "treat_wounds_and_ill",
      label: "Treat wounds & ill",
      hours: 1,
      effects: { condition: 4, morale: 2 },
      desc: "Clean cuts, tend the sick, share tonics.",
      priority: "care",
    },
    {
      id: "preserve_meat",
      label: "Preserve meat",
      hours: 2,
      effects: { supplies: { preserved_meat: 4, fresh_meat: -4 }, morale: 1 },
      desc: "Smoke or dry meat for the days ahead.",
      priority: "food",
    },
    {
      id: "set_snares_short_hunt",
      label: "Set snares / short hunt",
      hours: 2.5,
      effects: { supplies: { fresh_meat: 3, ammo: -1 }, energy: -4 },
      desc: "Chance at meat by dawn; tiring.",
      priority: "food",
    },
    {
      id: "stand_guard_night_watch",
      label: "Night watch",
      hours: 1.5,
      effects: { guard: 1, energy: -3 },
      desc: "Watch for raiders or stampede.",
      priority: "safety",
    },
    {
      id: "extra_sleep",
      label: "Extra sleep",
      hours: 3,
      effects: { energy: 12, condition: 5 },
      desc: "Turn in early and recover.",
      priority: "rest",
    },
    {
      id: "read_book",
      label: "Read by lantern light",
      hours: 1,
      effects: { morale: 4, energy: 2 },
      desc: "Quiet reading that lifts spirits.",
      priority: "rest",
    },
  ];

  const CRAFTING_RECIPES = [
    {
      id: "smoked_meat",
      name: "Smoked meat",
      pattern: "110110000",
      inputs: [
        { key: "fresh_meat", amount: 4 },
        { key: "salt", amount: 1 },
        { key: "fuel", amount: 1 },
      ],
      output: { key: "preserved_meat", amount: 4 },
      hoursCost: 2,
      skillTag: "cooking",
      desc: "Preserve meat for longer stretches of trail.",
      icon: "SM",
    },
    {
      id: "pickle_veg",
      name: "Pickled crock",
      pattern: "111000111",
      inputs: [
        { key: "dried_fruit", amount: 1 },
        { key: "salt_soda", amount: 0.5 },
        { key: "water", amount: 1 },
      ],
      output: { key: "pickled_veg", amount: 3 },
      hoursCost: 2,
      skillTag: "cooking",
      desc: "Pack vegetables or fruit with brine for trail-stable bites.",
      icon: "PV",
    },
    {
      id: "salt_meat",
      name: "Salt meat",
      pattern: "101010101",
      inputs: [
        { key: "fresh_meat", amount: 3 },
        { key: "salt_soda", amount: 1.2 },
      ],
      output: { key: "salted_meat", amount: 3 },
      hoursCost: 1.5,
      skillTag: "cooking",
      desc: "Rub meat down with salt to hold a few extra weeks.",
      icon: "SL",
    },
    {
      id: "make_jerky",
      name: "Cut trail jerky",
      pattern: "101001101",
      inputs: [
        { key: "fresh_meat", amount: 2.5 },
        { key: "fuel", amount: 0.5 },
        { key: "salt_soda", amount: 0.4 },
      ],
      output: { key: "trail_jerky", amount: 2.2 },
      hoursCost: 2.5,
      skillTag: "cooking",
      desc: "Slow-dry strips into chewy jerky.",
      icon: "JK",
    },
    {
      id: "repaired_shoes",
      name: "Repair shoes",
      pattern: "010111010",
      inputs: [
        { key: "leather", amount: 1 },
        { key: "needle", amount: 1 },
      ],
      output: { key: "boot_durability", amount: 5 },
      hoursCost: 1.5,
      skillTag: "crafting",
      desc: "Patch soles and reduce future foot injuries.",
      icon: "RS",
    },
    {
      id: "patched_cover",
      name: "Patch wagon cover",
      pattern: "111111000",
      inputs: [
        { key: "cloth", amount: 2 },
        { key: "pitch", amount: 1 },
      ],
      output: { key: "wagonCondition", amount: 6 },
      hoursCost: 1.5,
      skillTag: "crafting",
      desc: "Seal tears to keep stores dry.",
      icon: "WC",
    },
    {
      id: "extra_ammo",
      name: "Hand-load ammo",
      pattern: "100010100",
      inputs: [
        { key: "lead", amount: 2 },
        { key: "powder", amount: 1 },
      ],
      output: { key: "ammo", amount: 4 },
      hoursCost: 1.5,
      skillTag: "crafting",
      desc: "Cast bullets and paper cartridges.",
      icon: "AM",
    },
    {
      id: "herbal_tonic",
      name: "Herbal tonic",
      pattern: "001111000",
      inputs: [
        { key: "water", amount: 1 },
        { key: "herbs", amount: 1 },
      ],
      output: { key: "medicine", amount: 1 },
      hoursCost: 1,
      skillTag: "doctoring",
      desc: "Brew a mild fever tonic.",
      icon: "HT",
    },
  ];

  const REGIONAL_RECIPES = [
    {
      id: "beans_bacon",
      name: "Beans & bacon pot",
      regionTags: ["plains", "great_plains"],
      inputs: { beans_rice: 2, bacon: 1, salt_soda: 0.2 },
      outputMeals: 3,
      morale: 2,
      skill: "cooking",
      difficulty: 1,
    },
    {
      id: "cornmeal_mush",
      name: "Cornmeal mush",
      regionTags: ["plains", "great_plains", "columbia"],
      inputs: { flour: 1.2, sugar: 0.2 },
      outputMeals: 2,
      morale: 1,
      skill: "cooking",
      difficulty: 0,
    },
    {
      id: "salmon_stew",
      name: "Salmon stew",
      regionTags: ["columbia", "snake_plain"],
      inputs: { fresh_meat: 2, salt_soda: 0.2 },
      outputMeals: 3,
      morale: 3,
      skill: "cooking",
      difficulty: 2,
    },
    {
      id: "mountain_stew",
      name: "Mountain barley stew",
      regionTags: ["rockies", "blue_mountains"],
      inputs: { beans_rice: 1.5, dried_fruit: 0.5, bacon: 0.5 },
      outputMeals: 3,
      morale: 3,
      skill: "cooking",
      difficulty: 2,
    },
    {
      id: "trail_hardtack_hash",
      name: "Hardtack hash",
      regionTags: ["plains", "columbia", "great_plains"],
      inputs: { hardtack: 1, bacon: 0.5 },
      outputMeals: 2,
      morale: 0,
      skill: "cooking",
      difficulty: 0,
    },
    {
      id: "platte_pickled_stew",
      name: "Platte pickled stew",
      regionTags: ["plains", "central_plains"],
      inputs: { pickled_veg: 1, salted_meat: 1.2, beans_rice: 0.6 },
      outputMeals: 3,
      morale: 3,
      skill: "cooking",
      difficulty: 2,
      note: "Brined vegetables stretch scarce fresh forage on the Platte.",
    },
    {
      id: "snake_fish_jerky",
      name: "Snake River jerky pot",
      regionTags: ["snake_plain", "columbia"],
      inputs: { trail_jerky: 1.4, beans_rice: 0.8, dried_fruit: 0.4 },
      outputMeals: 3,
      morale: 2,
      skill: "cooking",
      difficulty: 2,
      note: "Smoky strips simmered soft with beans.",
    },
    {
      id: "willamette_harvest_feast",
      name: "Willamette harvest pot",
      regionTags: ["willamette", "columbia"],
      inputs: { pickled_veg: 1.2, bacon: 0.5, flour: 0.5 },
      outputMeals: 4,
      morale: 4,
      skill: "cooking",
      difficulty: 2,
      note: "Late trail vegetables and smoked pork for a morale bump near the end.",
    },
  ];

  /* ========= STATE ========================================================= */

  const dom = {};

  let PERSON_ID_COUNTER = 1;
  let isAdvancingTime = false;
  let encounterActive = false;
  let encounterResolver = null;
  let encounterDefaultOption = null;
  let encounterAllowEscape = false;
  let lastFocusedBeforeEncounter = null;
  let encounterOptionsEls = [];
  let pendingEncounterId = null;
  let encounterKeyHandler = null;

  const gameState = {
    phase: "start",
    leader: null,
    actingLeaderId: null,
    companions: [],
    selectedIndex: 0, // 0 = leader
    supplies: {},
    money: 0,
    startingMoney: 0,
    date: new Date(1848, 3, 15, 16, 0, 0),
    milesTraveled: 0,
    targetMiles: 2050,
    pace: "steady",
    rations: "filling",
    mode: "camp", // "travel" or "camp"
    weather: "Mild",
    weatherState: null,
    weatherSeed: null,
    weatherSystem: null,
    weatherHistory: [],
    recentRainHours: 0,
    locationName: "Independence",
    region: "plains",
    wagonCondition: 100,
    guardLevel: 0,
    log: [],
    lastHourMiles: 0,
    seasonStart: "late_april",
    startProfileId: "late_april",
    startProfile: null,
    mythicEnabled: true,
    partyDraft: null,
    startingPoint: "independence",
    startDayOfYear: null,
    highRiverRisk: false,
    partyId: null,
    mapListVisible: false,
    mapOpen: false,
    dayRhythm: null,
    lastDayRhythmBonus: 0,
    nutritionHistory: [],
    currentNutrition: null,
    nutritionStatus: null,
    travelView: "journal",
    explorer: { x: 6, y: 20, hourBuffer: 0 },
    explorerView: { camX: 0, camY: 0, zoom: 1, follow: true },
    hexMap: null,
    traillines: {
      visualMiles: 0,
      laneOffset: 0,
      fogMaxMile: 0,
      lastFrameTime: null,
    },
    ui: { trade: { open: false, tab: "buy", vendorKey: "forts", poiId: null } },
    storyState: null,
    storytellerPresetId: "classic",
    waterQuality: "safe",
    lastWaterSourceType: "well",
    lastWaterBoiled: true,
    waterPlan: null,
    cascadeEvents: [],
    tensionDebug: false,
    showStorytellerDebug: false,
    spoilage: null,
    campPlan: null,
    thoughtHistory: null,
    socialHistory: null,
    routeChoices: null,
    reputation: 0,
    reputationFlags: {},
    lastCampfireMomentKey: null,
    logVerbosityThreshold: 1,
  };

  function defaultTraillinesState() {
    return {
      visualMiles: gameState.milesTraveled || 0,
      laneOffset: 0,
      fogMaxMile: gameState.milesTraveled || 0,
      lastFrameTime: null,
    };
  }

  function getCurrentTrailHour(state) {
    const gs = state || gameState || {};
    const date = gs.date instanceof Date ? gs.date : new Date();
    const startDay =
      typeof gs.startDayOfYear === "number" ? gs.startDayOfYear : getDayOfYear(date);
    const doy = getDayOfYear(date);
    const hour = date.getHours();
    return Math.max(0, (doy - startDay) * 24 + hour);
  }

  function getSeasonTagForDate(date) {
    const d = date || new Date();
    const m = d.getMonth();
    if (m <= 1) return "winter";
    if (m <= 4) return "spring";
    if (m <= 7) return "summer";
    if (m <= 9) return "fall";
    return "late_fall";
  }

  function ensureSpoilageState() {
    const ss = ensureStoryState();
    if (!ss.spoilage) ss.spoilage = { batches: [], nextBatchId: 1, migratedLegacy: false };
    if (!Array.isArray(ss.spoilage.batches)) ss.spoilage.batches = [];
    if (typeof ss.spoilage.nextBatchId !== "number") ss.spoilage.nextBatchId = 1;
    if (typeof ss.spoilage.migratedLegacy !== "boolean") ss.spoilage.migratedLegacy = false;

    if (
      gameState.spoilage &&
      gameState.spoilage.perishables &&
      !ss.spoilage.migratedLegacy
    ) {
      const legacy = gameState.spoilage.perishables;
      const nowHour = getCurrentTrailHour(gameState);
      [
        { key: "freshMeat", supplyId: "fresh_meat", method: "raw" },
        { key: "cookedStew", supplyId: "meal_hearty", method: "cooked" },
      ].forEach(function (entry) {
        const rec = legacy[entry.key];
        if (!rec || !rec.quantity || rec.quantity <= 0) return;
        registerFoodBatch(entry.supplyId, rec.quantity, entry.method, {
          acquiredHour: Math.max(0, nowHour - (rec.ageHours || 0)),
          note: "legacy",
        });
      });
      ss.spoilage.migratedLegacy = true;
    }

    return ss.spoilage;
  }

  function getSpoilageRateMultiplierForClimate(region, seasonTag, weatherState) {
    const r = region || "plains";
    const s = seasonTag || getSeasonTagForDate(gameState.date);
    const w = weatherState || {};
    let mult = 1;
    if (w.tempC >= 30) mult += 0.25;
    if (w.tempC >= 20 && (w.precip === "rain" || w.precip === "storm")) mult += 0.15;
    if (w.tempC <= 2) mult -= 0.12;
    if (r === "mountains" || r === "blue_mountains") mult -= 0.08;
    if (r === "snake_plain" && s === "summer") mult += 0.18;
    if (r === "columbia" && s === "late_fall") mult -= 0.05;
    return Math.max(0.55, mult);
  }

  function computeShelfLifeHours(supplyId, method) {
    const w = gameState.weatherState || {};
    const region = gameState.region || "plains";
    const climateMult = getSpoilageRateMultiplierForClimate(region, getSeasonTagForDate(gameState.date), w);
    let base = 26;
    if (supplyId === "fresh_meat" || method === "raw") {
      base = 22;
      if (w.tempC >= 28) base -= 8;
      else if (w.tempC >= 22) base -= 4;
      if (w.tempC <= 0) base += 8;
      if (region === "mountains" || region === "blue_mountains") base += 6;
      if (region === "snake_plain") base -= 4;
    } else if (supplyId.indexOf("meal_") === 0 || method === "cooked") {
      base = 28;
      if (w.storm || w.precip === "rain") base -= 4;
      if (w.tempC >= 27) base -= 6;
      if (w.tempC <= 0) base += 5;
    } else if (method === "pickled") {
      base = 160;
      if (w.tempC >= 28) base -= 12;
    } else if (method === "salted") {
      base = 96;
      if (w.tempC >= 28) base -= 10;
    }
    if (method === "smoked" || method === "dried") {
      base = 120;
      if (w.tempC <= 5 && w.precip === "none") base += 16;
      if (region === "snake_plain") base -= 10;
      if (region === "blue_mountains" || region === "willamette") base += 6;
    }
    if (supplyId === "dried_fruit" || supplyId === "trail_jerky") base = 140;
    base = base / climateMult;
    const warnLead = Math.max(6, base * 0.55);
    const shelf = Math.max(10, base);
    return { warn: warnLead, spoil: shelf };
  }

  function isPerishableSupply(id) {
    const item = SUPPLY_ITEMS.find(function (s) {
      return s.id === id;
    });
    if (item && typeof item.perishable === "boolean") return item.perishable;
    return ["fresh_meat", "meal_simple", "meal_hearty", "meal_feast", "cooked_meals", "pickled_veg", "salted_meat", "trail_jerky"]
      .indexOf(id) >= 0;
  }

  function registerSpoilageForPerishables(currentSupplies, itemsDelta, options) {
    const delta = itemsDelta || {};
    Object.keys(delta).forEach(function (id) {
      const qty = delta[id];
      if (!qty || qty <= 0 || !isPerishableSupply(id)) return;
      const item = SUPPLY_ITEMS.find(function (s) {
        return s.id === id;
      });
      const method =
        (options && options.methodMap && options.methodMap[id]) ||
        (item && item.defaultMethod) ||
        (options && options.method) ||
        "cooked";
      registerFoodBatch(id, qty, method, {
        acquiredHour:
          options && options.acquiredHour != null
            ? options.acquiredHour
            : getCurrentTrailHour(gameState),
        note: options && options.note,
      });
    });
  }

  function registerFoodBatch(supplyId, qty, method, context) {
    if (!supplyId || !qty || qty <= 0) return null;
    const spoilage = ensureSpoilageState();
    const nowHour =
      context && context.acquiredHour != null
        ? context.acquiredHour
        : getCurrentTrailHour(gameState);
    const timing = computeShelfLifeHours(supplyId, method);
    const warnHour = nowHour + timing.warn;
    const spoilHour = nowHour + timing.spoil;

    const merge = spoilage.batches.find(function (b) {
      return (
        b &&
        b.supplyId === supplyId &&
        b.method === method &&
        Math.abs((b.acquiredHour || 0) - nowHour) <= 3 &&
        b.status !== "spoiled"
      );
    });
    if (merge) {
      merge.qty += qty;
      merge.warnHour = Math.min(merge.warnHour, warnHour);
      merge.spoilHour = Math.min(merge.spoilHour, spoilHour);
      return merge;
    }

    const batch = {
      id: spoilage.nextBatchId++,
      supplyId: supplyId,
      qty: qty,
      method: method || "cooked",
      acquiredHour: nowHour,
      warnHour: warnHour,
      spoilHour: spoilHour,
      regionAtAcquire: gameState.region,
      note: context && context.note ? context.note : context && context.recipeId,
      status: "fresh",
    };
    spoilage.batches.push(batch);
    return batch;
  }

  function consumeFromBatches(supplyId, units) {
    if (!supplyId || !units || units <= 0) return;
    const spoilage = ensureSpoilageState();
    const relevant = spoilage.batches
      .filter(function (b) {
        return b && b.supplyId === supplyId && b.qty > 0;
      })
      .sort(function (a, b) {
        return a.spoilHour - b.spoilHour;
      });
    let remaining = units;
    for (let i = 0; i < relevant.length && remaining > 0; i++) {
      const batch = relevant[i];
      const take = Math.min(batch.qty, remaining);
      batch.qty -= take;
      remaining -= take;
      if (batch.qty <= 0) batch.status = batch.status === "spoiled" ? "spoiled" : "used";
    }
    cleanupEmptyBatches(spoilage, getCurrentTrailHour(gameState));
  }

  function cleanupEmptyBatches(spoilageState, nowHour) {
    if (!spoilageState) return;
    spoilageState.batches = spoilageState.batches.filter(function (b) {
      if (!b) return false;
      if (b.qty > 0) return true;
      if (b.status === "spoiled" && nowHour - (b.spoilHour || 0) > 48) return false;
      return b.status !== "used";
    });
  }

  function updateSpoilageForHour() {
    const ss = ensureStoryState();
    const spoilage = ensureSpoilageState();
    const nowHour = getCurrentTrailHour(gameState);
    const turning = new Set();
    const spoiledLoss = {};
    spoilage.batches.forEach(function (batch) {
      if (!batch || batch.qty <= 0) return;
      if (batch.status === "fresh" && nowHour >= batch.warnHour) {
        batch.status = "turning";
        turning.add(batch.supplyId);
      }
      if (batch.status !== "spoiled" && nowHour >= batch.spoilHour) {
        batch.status = "spoiled";
        spoiledLoss[batch.supplyId] = (spoiledLoss[batch.supplyId] || 0) + batch.qty;
        gameState.supplies[batch.supplyId] = Math.max(
          0,
          (gameState.supplies[batch.supplyId] || 0) - batch.qty
        );
        batch.qty = 0;
      }
    });
    cleanupEmptyBatches(spoilage, nowHour);

    if (turning.size > 0) {
      const names = Array.from(turning)
        .map(function (id) {
          const item = SUPPLY_ITEMS.find(function (s) {
            return s.id === id;
          });
          return item ? item.name.toLowerCase() : id;
        })
        .join(", ");
      addLog("Some food stores are beginning to turn (" + names + ").", { tone: "warning" });
    }
    const spoiledKeys = Object.keys(spoiledLoss);
    if (spoiledKeys.length) {
      const parts = spoiledKeys.map(function (id) {
        const item = SUPPLY_ITEMS.find(function (s) {
          return s.id === id;
        });
        const label = item ? item.name.toLowerCase() : id;
        return Math.round(spoiledLoss[id]) + " " + (item ? item.unit : "units") + " " + label;
      });
      addLog(
        "Spoilage spoils part of your stores: " +
          parts.join(", ") +
          ". The heat and handling aren't kind to provisions.",
        { tone: "warning" }
      );
      ss.risk.bad_food = true;
    }
  }

  function summarizeFreshness(supplyId) {
    const spoilage = ensureSpoilageState();
    const summary = { fresh: 0, turning: 0, spoiled: 0, total: 0 };
    spoilage.batches.forEach(function (b) {
      if (!b || b.supplyId !== supplyId) return;
      if (b.status === "spoiled") summary.spoiled += b.qty;
      else if (b.status === "turning") summary.turning += b.qty;
      else summary.fresh += b.qty;
      summary.total += b.qty;
    });
    return summary;
  }

  function freshnessHintForSupply(supplyId) {
    const summary = summarizeFreshness(supplyId);
    if (!summary || summary.total <= 0) return null;
    const turningShare = summary.turning / summary.total;
    const spoiledShare = summary.spoiled / summary.total;
    if (spoiledShare > 0.4) return "mostly spoiled";
    if (spoiledShare > 0.1) return "some spoiled";
    if (turningShare > 0.35) return "turning soon";
    if (turningShare > 0.15) return "a few portions turning";
    return "fresh";
  }

  function ensureTraillinesState() {
    if (!gameState.travelView) {
      gameState.travelView = "journal";
    }
    if (!gameState.traillines) {
      gameState.traillines = defaultTraillinesState();
    } else {
      gameState.traillines.visualMiles =
        typeof gameState.traillines.visualMiles === "number"
          ? gameState.traillines.visualMiles
          : gameState.milesTraveled || 0;
      if (typeof gameState.traillines.laneOffset !== "number") {
        gameState.traillines.laneOffset = 0;
      }
      if (typeof gameState.traillines.fogMaxMile !== "number") {
        gameState.traillines.fogMaxMile = gameState.milesTraveled || 0;
      }
      if (!gameState.traillines.lastFrameTime) {
        gameState.traillines.lastFrameTime = null;
      }
    }
  }

  function ensureExplorerState(gs) {
    const state = gs || gameState;
    if (!state.explorer) {
      state.explorer = { x: 6, y: 20, hourBuffer: 0 };
    }

    const ex = state.explorer;
    if (typeof ex.x !== "number") ex.x = 6;
    if (typeof ex.y !== "number") ex.y = 20;
    if (typeof ex.hourBuffer !== "number") ex.hourBuffer = 0;

    const progress = clamp(
      (state.milesTraveled || 0) / Math.max(state.targetMiles || 1, 1),
      0,
      1
    );
    if (!state.explorer.initializedFromProgress) {
      const idx = Math.floor(progress * (EXPLORER_WORLD.path.length - 1));
      const p = EXPLORER_WORLD.path[idx] || EXPLORER_WORLD.path[0];
      state.explorer.x = p.x;
      state.explorer.y = p.y;
      state.explorer.initializedFromProgress = true;
    }

    // Clamp to map bounds in case older saves stored out-of-bounds coords
    state.explorer.x = clamp(state.explorer.x, 0, EXPLORER_WORLD.width - 1);
    state.explorer.y = clamp(state.explorer.y, 0, EXPLORER_WORLD.height - 1);

    return state.explorer;
  }

  function ensureStoryState() {
    if (!gameState.storyState) {
      gameState.storyState = {
        tension: 12,
        hoursSinceMajorEvent: 0,
        hoursSinceMinorEvent: 0,
        eventFlags: {},
        risk: {},
        riskDurations: {},
        cascadeLog: [],
        socialArcs: {},
        lastRiskSnapshot: {},
        recentEvents: [],
        presetId: gameState.storytellerPresetId || "classic",
        mythicEnabled: gameState.mythicEnabled !== false,
        presetSwapsTotal: 0,
        presetSwapsThisWeek: 0,
        lastPresetSwapDayKey: null,
        lastHourCampTasks: {},
        lastHourTaskFailures: {},
        lastSocialDay: null,
        lastCrisisLogHour: null,
        spoilage: { batches: [], nextBatchId: 1, migratedLegacy: false },
        mythicCurios: { owned: [], slots: [null, null], upkeepState: {} },
        factionRep: { caravans: 0, forts: 0, open_eye: 0, men_in_gray: 0 },
        mythicRumor: 0,
        tradeLedger: [],
        tradeVendors: {},
        tradeHaggling: {},
        factionRepLog: [],
        factionRepLast: {},
      };
    }
    const ss = gameState.storyState;
    if (typeof ss.tension !== "number") ss.tension = 12;
    if (typeof ss.hoursSinceMajorEvent !== "number") ss.hoursSinceMajorEvent = 0;
    if (typeof ss.hoursSinceMinorEvent !== "number") ss.hoursSinceMinorEvent = 0;
    if (!ss.eventFlags) ss.eventFlags = {};
    if (!ss.risk) ss.risk = {};
    if (!ss.riskDurations) ss.riskDurations = {};
    if (!Array.isArray(ss.cascadeLog)) ss.cascadeLog = [];
    if (!ss.personCascade) ss.personCascade = {};
    if (!ss.socialArcs) ss.socialArcs = {};
    if (!ss.leadershipDisputeState)
      ss.leadershipDisputeState = {
        active: false,
        heat: 0,
        challengerId: null,
        leaderId: null,
        lastHour: null,
      };
    if (!ss.lastRiskSnapshot) ss.lastRiskSnapshot = {};
    if (!Array.isArray(ss.recentEvents)) ss.recentEvents = [];
    if (!ss.presetId) ss.presetId = gameState.storytellerPresetId || "classic";
    if (typeof ss.mythicEnabled !== "boolean") ss.mythicEnabled = gameState.mythicEnabled !== false;
    gameState.mythicEnabled = ss.mythicEnabled !== false;
    if (typeof ss.presetSwapsTotal !== "number") ss.presetSwapsTotal = 0;
    if (typeof ss.presetSwapsThisWeek !== "number") ss.presetSwapsThisWeek = 0;
    if (!ss.lastPresetSwapDayKey) ss.lastPresetSwapDayKey = null;
    if (!ss.lastHourCampTasks) ss.lastHourCampTasks = {};
    if (!ss.lastHourTaskFailures) ss.lastHourTaskFailures = {};
    if (ss.lastSocialDay == null) ss.lastSocialDay = null;
    if (ss.lastCrisisLogHour == null) ss.lastCrisisLogHour = null;
    if (!ss.spoilage) ss.spoilage = { batches: [], nextBatchId: 1, migratedLegacy: false };
    if (!Array.isArray(ss.spoilage.batches)) ss.spoilage.batches = [];
    if (typeof ss.spoilage.nextBatchId !== "number") ss.spoilage.nextBatchId = 1;
    if (typeof ss.spoilage.migratedLegacy !== "boolean") ss.spoilage.migratedLegacy = false;
    if (!ss.mythicCurios)
      ss.mythicCurios = { owned: [], slots: [null, null], upkeepState: {} };
    if (!Array.isArray(ss.mythicCurios.owned)) ss.mythicCurios.owned = [];
    if (!Array.isArray(ss.mythicCurios.slots)) ss.mythicCurios.slots = [null, null];
    if (!ss.mythicCurios.upkeepState) ss.mythicCurios.upkeepState = {};
    if (!ss.factionRep) ss.factionRep = { caravans: 0, forts: 0, open_eye: 0, men_in_gray: 0 };
    if (typeof ss.factionRep.caravans !== "number") ss.factionRep.caravans = 0;
    if (typeof ss.factionRep.forts !== "number") ss.factionRep.forts = 0;
    if (typeof ss.factionRep.open_eye !== "number") ss.factionRep.open_eye = 0;
    if (typeof ss.factionRep.men_in_gray !== "number") ss.factionRep.men_in_gray = 0;
    if (typeof ss.mythicRumor !== "number") ss.mythicRumor = 0;
    if (!Array.isArray(ss.tradeLedger)) ss.tradeLedger = [];
    if (!ss.tradeVendors) ss.tradeVendors = {};
    if (!ss.tradeHaggling) ss.tradeHaggling = {};
    if (!Array.isArray(ss.factionRepLog)) ss.factionRepLog = [];
    if (!ss.factionRepLast) ss.factionRepLast = {};
    return ss;
  }

  const STORYTELLER_PRESETS = {
    gentle: {
      id: "gentle",
      label: "Calm Narrator",
      iconKey: "quill",
      tagline: "Steady hardships, few surprises",
      description:
        "Emphasizes breathers and lifelines; brutal cascades are rarer and shorter.",
      hint: "Gentler swings, more hope.",
      examples: [
        "Expect a forgiving pace with lifelines after scares — a wagon that stumbles often finds a way back on its feet.",
        "Slow-burn tension that eases off when morale dips.",
      ],
      personality: "Soft curves, leans on breathers and lifelines.",
      // Softer drift and risk scaling for mellow curves
      tensionBaseDrift: 0.035,
      tensionRiskScale: 0.22,
      tensionMin: 5,
      tensionMax: 82,
      tensionAfterMajorDrop: 32,
      tensionAfterMinorDrop: 16,
      minHoursBetweenMajor: 32,
      minHoursBetweenMinor: 7,
      breatherBias: 1.45,
      lifelineBias: 1.35,
      pacingSummary: "Plains: calm · Rockies: gentle slopes · Columbia: careful finish",
      regionCurves: {
        plains: {
          tensionRiskScale: 0.18,
          baseDrift: -0.02,
          minClamp: 5,
          maxClamp: 55,
          label: "quiet early miles",
          seasons: {
            spring: { baseDrift: -0.03 },
            summer: { baseDrift: 0.04, maxClamp: 60 },
          },
        },
        central_plains: {
          tensionRiskScale: 0.2,
          baseDrift: 0.01,
          minClamp: 6,
          maxClamp: 60,
          label: "long grasslands",
          seasons: { summer: { baseDrift: 0.05, tensionRiskScale: 0.22 } },
        },
        high_plains: { tensionRiskScale: 0.24, baseDrift: 0.06, minClamp: 10, maxClamp: 65, label: "windy heights" },
        mountains: {
          tensionRiskScale: 0.3,
          baseDrift: 0.12,
          minClamp: 22,
          maxClamp: 75,
          label: "gentle mountain danger",
          seasons: { fall: { baseDrift: 0.18, minClamp: 28 } },
        },
        snake_plain: { tensionRiskScale: 0.3, baseDrift: 0.1, minClamp: 20, maxClamp: 78, label: "dry and watchful" },
        blue_mountains: { tensionRiskScale: 0.32, baseDrift: 0.14, minClamp: 22, maxClamp: 80, label: "hilly grind" },
        columbia: {
          tensionRiskScale: 0.34,
          baseDrift: 0.18,
          minClamp: 28,
          maxClamp: 85,
          label: "careful finish",
          seasons: { late_fall: { baseDrift: 0.22, minClamp: 32 } },
        },
      },
    },
    classic: {
      id: "classic",
      label: "Classic Trail",
      iconKey: "balanced",
      tagline: "Balanced hardships and rests",
      description:
        "Balanced hardships and breathers with the familiar Oregon Trail rhythm.",
      hint: "Balanced tension and drama.",
      examples: [
        "Moments of calm give way to weather scares, illnesses, and tough river calls — but rarely all at once.",
        "A steady journal-style cadence with the occasional surprise river debate.",
      ],
      personality: "Even pacing with occasional spikes.",
      // Middle-of-the-road drift with modest spikes when risk flags stack up
      tensionBaseDrift: 0.065,
      tensionRiskScale: 0.27,
      tensionMin: 9,
      tensionMax: 95,
      tensionAfterMajorDrop: 36,
      tensionAfterMinorDrop: 18,
      minHoursBetweenMajor: 23,
      minHoursBetweenMinor: 4,
      breatherBias: 1.0,
      lifelineBias: 1.0,
      pacingSummary: "Plains: steady · Rockies: spikes · Columbia: hard push",
      regionCurves: {
        plains: { tensionRiskScale: 0.22, baseDrift: 0.02, minClamp: 9, maxClamp: 70, label: "broad calm", seasons: { spring: { baseDrift: 0 }, summer: { baseDrift: 0.06 } } },
        central_plains: { tensionRiskScale: 0.25, baseDrift: 0.05, minClamp: 10, maxClamp: 78, label: "river watches", seasons: { summer: { tensionRiskScale: 0.28 } } },
        high_plains: { tensionRiskScale: 0.3, baseDrift: 0.12, minClamp: 18, maxClamp: 85, label: "storms & wind" },
        mountains: { tensionRiskScale: 0.34, baseDrift: 0.16, minClamp: 22, maxClamp: 92, label: "steeper risks", seasons: { fall: { baseDrift: 0.22, minClamp: 28 } } },
        snake_plain: { tensionRiskScale: 0.33, baseDrift: 0.14, minClamp: 20, maxClamp: 90, label: "dry stretches" },
        blue_mountains: { tensionRiskScale: 0.35, baseDrift: 0.18, minClamp: 24, maxClamp: 94, label: "grinding passes" },
        columbia: { tensionRiskScale: 0.38, baseDrift: 0.2, minClamp: 28, maxClamp: 100, label: "river cliffs", seasons: { late_fall: { baseDrift: 0.26 } } },
      },
    },
    harsh: {
      id: "harsh",
      label: "Harsh Frontier",
      iconKey: "skull",
      tagline: "Harsh cascades and sharp spikes",
      description:
        "Pushes risk flags harder with shorter breathers and sharper cascades.",
      hint: "Unforgiving, for experienced players.",
      examples: [
        "Long dry stretches can suddenly tip into illness, wagon failures, and morale spirals that demand fast decisions.",
        "Spare breathers; expects you to plan ahead.",
      ],
      personality: "Sharper highs and lows; drama-forward pacing.",
      // Higher drift + risk scaling, allows faster spikes
      tensionBaseDrift: 0.11,
      tensionRiskScale: 0.42,
      tensionMin: 12,
      tensionMax: 100,
      tensionAfterMajorDrop: 46,
      tensionAfterMinorDrop: 23,
      minHoursBetweenMajor: 18,
      minHoursBetweenMinor: 3,
      breatherBias: 0.62,
      lifelineBias: 0.74,
      pacingSummary: "Plains: uneasy · Rockies: spikes · Columbia: knife-edge",
      regionCurves: {
        plains: { tensionRiskScale: 0.32, baseDrift: 0.08, minClamp: 14, maxClamp: 90, label: "rough start", seasons: { spring: { baseDrift: 0.04 }, summer: { baseDrift: 0.12 } } },
        central_plains: { tensionRiskScale: 0.36, baseDrift: 0.12, minClamp: 16, maxClamp: 95, label: "storms and mud", seasons: { summer: { tensionRiskScale: 0.4 } } },
        high_plains: { tensionRiskScale: 0.42, baseDrift: 0.2, minClamp: 22, maxClamp: 100, label: "wind and rattles" },
        mountains: { tensionRiskScale: 0.48, baseDrift: 0.26, minClamp: 30, maxClamp: 100, label: "spiky mountain danger", seasons: { fall: { baseDrift: 0.32 } } },
        snake_plain: { tensionRiskScale: 0.46, baseDrift: 0.24, minClamp: 28, maxClamp: 100, label: "harsh dry crossings" },
        blue_mountains: { tensionRiskScale: 0.5, baseDrift: 0.3, minClamp: 32, maxClamp: 100, label: "thin patience" },
        columbia: { tensionRiskScale: 0.54, baseDrift: 0.34, minClamp: 36, maxClamp: 100, label: "knife-edge finale", seasons: { late_fall: { baseDrift: 0.38, minClamp: 40 } } },
      },
    },
  };

  /* ========= UTILITIES ===================================================== */

  function clamp(v, min, max) {
    return v < min ? min : v > max ? max : v;
  }

  function randFloat(min, max) {
    return min + Math.random() * (max - min);
  }

  function randInt(min, max) {
    return Math.floor(randFloat(min, max + 1));
  }

  function adjustPersonStat(person, key, delta) {
    if (!person || typeof delta !== "number") return;
    const current = typeof person[key] === "number" ? person[key] : 0;
    person[key] = clamp(current + delta, 0, 100);
  }

  function choice(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function ensureAfflictions(person) {
    if (!person.afflictions) person.afflictions = [];
    return person.afflictions;
  }

  function getTraitDef(id) {
    return TRAIT_DEFS.find(function (t) {
      return t.id === id || t.label === id;
    });
  }

  function getBackstoryDef(id) {
    return BACKSTORY_DEFS.find(function (b) {
      return b.id === id || b.label === id;
    });
  }

  const BACKSTORY_GENDER_ALIASES = {
    frontier_midwife: {
      label: "Frontier medic",
      summary: "Calm in panic, steady with poultices and splints.",
    },
  };

  function warnPersonIntegrity(person) {
    if (!person) return;
    const issues = [];
    const back = person.backstoryId ? getBackstoryDef(person.backstoryId) : null;
    if (person.backstoryId && !back) issues.push("missing backstory def: " + person.backstoryId);
    const traitPool = (person.traits || []).concat(person.hiddenTraits || []);
    traitPool.forEach(function (tid) {
      if (!getTraitDef(tid)) issues.push("missing trait def: " + tid);
    });
    if (back && back.allowedGenders && back.allowedGenders.length) {
      if (back.allowedGenders.indexOf(person.genderHint || "unknown") < 0) {
        issues.push("backstory gender mismatch");
      }
    }
    if (issues.length) {
      console.warn("[ot] person integrity", person.name, issues.join("; "));
    }
  }

  function getAllTraitIds(person, opts) {
    const includeHidden = (opts && opts.includeHidden) || false;
    const visible = (person && person.traits) || [];
    const hidden = includeHidden && person && person.hiddenTraits ? person.hiddenTraits : [];
    return visible.concat(hidden || []);
  }

  function hasTrait(person, traitId, opts) {
    if (!person || !traitId) return false;
    const pool = getAllTraitIds(person, opts);
    return pool.indexOf(traitId) >= 0;
  }

  function ensureAppliedTraitState(person) {
    if (!person.appliedTraitIds) {
      const alreadyApplied = person._traitApplied ? getAllTraitIds(person, { includeHidden: true }) : [];
      person.appliedTraitIds = alreadyApplied.slice();
    }
    return person.appliedTraitIds;
  }

  function applyTraitStats(person) {
    if (!person) return;
    const applied = ensureAppliedTraitState(person);
    const traits = getAllTraitIds(person, { includeHidden: true });
    traits.forEach(function (tid) {
      if (applied.indexOf(tid) >= 0) return;
      const def = getTraitDef(tid);
      if (!def) return;
      Object.keys(def.skillMods || {}).forEach(function (k) {
        person.skills[k] = clamp((person.skills[k] || 0) + def.skillMods[k], 0, 6);
      });
      if (def.moraleBias) {
        person.morale = clamp((person.morale || 60) + def.moraleBias, 0, 100);
      }
      if (def.guardBonus) person.skills.guard = clamp((person.skills.guard || 0) + def.guardBonus, 0, 6);
      if (def.guardPenalty) person.skills.guard = clamp((person.skills.guard || 0) - def.guardPenalty, 0, 6);
      applied.push(tid);
    });
    person._traitApplied = true;
  }

  function suspectSecret(personId, amount, hintText, ctx) {
    const p = getAllPeople().find(function (per) {
      return per && per.id === personId;
    });
    if (!p || !Array.isArray(p.hiddenTraits) || !p.hiddenTraits.length) return;
    ensurePersonStoryFields(p);
    const before = p.secret.suspicion || 0;
    p.secret.suspicion = clamp(before + (amount || 0), 0, 100);
    const crossed = before < 35 && p.secret.suspicion >= 35;
    if (crossed && !p.secret.hinted) {
      p.secret.hinted = true;
      const text = hintText || `${p.name} keeps glancing over their shoulder as if hiding something.`;
      addLog(text, { tone: "social", characters: [p.id], location: ctx && ctx.location });
      recordStoryBeat("social", "secret_hint", text, { personId: p.id });
    }
  }

  function revealHiddenTrait(personId, opts) {
    const p = getAllPeople().find(function (per) {
      return per && per.id === personId;
    });
    if (!p) return null;
    ensurePersonStoryFields(p);
    const hidden = p.hiddenTraits || [];
    if (!hidden.length && !(opts && opts.force && opts.traitId)) return null;
    let tid = opts && opts.traitId ? opts.traitId : null;
    if (!tid) tid = hidden[Math.floor(Math.random() * hidden.length)];
    if (!tid) return null;
    p.hiddenTraits = hidden.filter(function (t) {
      return t !== tid;
    });
    if (p.traits.indexOf(tid) < 0) p.traits.push(tid);
    applyTraitStats(p);
    if (p.secret && p.secret.revealed.indexOf(tid) < 0) {
      p.secret.revealed.push(tid);
    }
    const def = getTraitDef(tid);
    const text =
      p.name +
      " finally admits to being " +
      (def ? def.label.toLowerCase() : tid) +
      (opts && opts.reason ? " — " + opts.reason : "");
    addLog(text, { tone: "event", characters: [p.id], location: opts && opts.ctx && opts.ctx.location });
    recordStoryBeat("social", "secret_revealed", text, { personId: p.id, traitId: tid });
    return tid;
  }

  function maybeSecretDrift(ctx) {
    const ss = ensureStoryState();
    if (!ss.eventFlags) ss.eventFlags = {};
    const hourStamp = Math.floor(gameState.date.getTime() / (60 * 60 * 1000));
    if (ss.eventFlags.lastSecretHour === hourStamp) return;
    ss.eventFlags.lastSecretHour = hourStamp;
    const candidates = getAllPeople().filter(function (p) {
      return p && p.alive && p.hiddenTraits && p.hiddenTraits.length > (p.secret && p.secret.revealed ? p.secret.revealed.length : 0);
    });
    if (!candidates.length) return;
    const hour = gameState.date.getHours();
    const campWindow = gameState.mode === "camp" || (hour >= 19 || hour <= 6);
    const chance = campWindow ? 0.28 : 0.12;
    if (Math.random() < chance) {
      const p = choice(candidates);
      suspectSecret(p.id, campWindow ? 8 : 4, null, ctx);
      if (p.secret && p.secret.suspicion >= 75 && Math.random() < 0.35) {
        revealHiddenTrait(p.id, { reason: "trust breaks during a tense night", ctx: ctx });
      }
    }
  }

  function ensurePersonStoryFields(person) {
    if (!person) return person;
    if (!person.id) {
      person.id = "p" + PERSON_ID_COUNTER++;
    } else {
      const numeric = parseInt(String(person.id).replace(/\D/g, ""), 10);
      if (!isNaN(numeric)) {
        PERSON_ID_COUNTER = Math.max(PERSON_ID_COUNTER, numeric + 1);
      }
    }
    if (!Array.isArray(person.thoughts)) person.thoughts = [];
    if (!person.moodState) person.moodState = "Upbeat";
    if (typeof person.optimism !== "number") person.optimism = 55;
    if (typeof person.lowMoraleHours !== "number") person.lowMoraleHours = 0;
    if (!person.relationships) person.relationships = {};
    if (!person.traits) person.traits = [];
    if (person.age == null) person.age = 18 + Math.floor(Math.random() * 25);
    if (!person.origin) person.origin = "Frontier settler";
    if (!person.backstoryId) person.backstoryId = null;
    if (!person.backstoryLabel) person.backstoryLabel = "";
    if (!person.backstorySummary) person.backstorySummary = "";
    if (!person.genderHint) person.genderHint = deriveGenderHint(person.name);
    if (!Array.isArray(person.hiddenTraits)) person.hiddenTraits = [];
    if (!person.secret)
      person.secret = { suspicion: 0, hinted: false, revealed: [] };
    if (!Array.isArray(person.secret.revealed)) person.secret.revealed = [];
    if (typeof person.morale !== "number") person.morale = 60;
    if (typeof person.lastBreakHour !== "number") person.lastBreakHour = 0;
    if (!person.activeBreak) person.activeBreak = null;
    if (!person.taskHistory)
      person.taskHistory = { recent: [], totals: {} };
    if (!Array.isArray(person.cascadeHistory)) person.cascadeHistory = [];
    const back = person.backstoryId ? getBackstoryDef(person.backstoryId) : null;
    if (
      back &&
      back.allowedGenders &&
      back.allowedGenders.length &&
      back.allowedGenders.indexOf(person.genderHint || "unknown") < 0
    ) {
      const alias = BACKSTORY_GENDER_ALIASES[back.id];
      if (alias && alias.label) person.backstoryLabel = alias.label;
      if (alias && alias.summary) person.backstorySummary = alias.summary;
    }
    ensureAppliedTraitState(person);
    applyTraitStats(person);
    warnPersonIntegrity(person);
    return person;
  }

  function hasAffliction(person, id) {
    if (!person || !person.afflictions) return false;
    return person.afflictions.some(function (a) {
      return a && a.id === id && !a.resolved;
    });
  }

  function hashToInt(str) {
    let h = 1779033703 ^ str.length;
    for (let i = 0; i < str.length; i++) {
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = (h << 13) | (h >>> 19);
    }
    return h >>> 0;
  }

  function mulberry32(a) {
    return function () {
      let t = (a += 0x6d2b79f5);
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function makeNoise3D(seed) {
    const rng = mulberry32(seed || 1);

    const gradients = {};
    function getGradient(ix, iy, iz) {
      const key = ix + "," + iy + "," + iz;
      if (!gradients[key]) {
        const theta = rng() * 2 * Math.PI;
        const phi = Math.acos(2 * rng() - 1);
        gradients[key] = [
          Math.sin(phi) * Math.cos(theta),
          Math.sin(phi) * Math.sin(theta),
          Math.cos(phi),
        ];
      }
      return gradients[key];
    }

    function fade(t) {
      return t * t * t * (t * (t * 6 - 15) + 10);
    }

    function dotGrid(ix, iy, iz, x, y, z) {
      const g = getGradient(ix, iy, iz);
      const dx = x - ix;
      const dy = y - iy;
      const dz = z - iz;
      return dx * g[0] + dy * g[1] + dz * g[2];
    }

    return function (x, y, z) {
      const x0 = Math.floor(x);
      const x1 = x0 + 1;
      const y0 = Math.floor(y);
      const y1 = y0 + 1;
      const z0 = Math.floor(z);
      const z1 = z0 + 1;

      const sx = fade(x - x0);
      const sy = fade(y - y0);
      const sz = fade(z - z0);

      const n000 = dotGrid(x0, y0, z0, x, y, z);
      const n100 = dotGrid(x1, y0, z0, x, y, z);
      const n010 = dotGrid(x0, y1, z0, x, y, z);
      const n110 = dotGrid(x1, y1, z0, x, y, z);
      const n001 = dotGrid(x0, y0, z1, x, y, z);
      const n101 = dotGrid(x1, y0, z1, x, y, z);
      const n011 = dotGrid(x0, y1, z1, x, y, z);
      const n111 = dotGrid(x1, y1, z1, x, y, z);

      const nx00 = lerp(n000, n100, sx);
      const nx10 = lerp(n010, n110, sx);
      const nx01 = lerp(n001, n101, sx);
      const nx11 = lerp(n011, n111, sx);

      const nxy0 = lerp(nx00, nx10, sy);
      const nxy1 = lerp(nx01, nx11, sy);

      const nxyz = lerp(nxy0, nxy1, sz);
      return nxyz; // roughly -1..1
    };
  }

  function formatMoney(n) {
    return "$" + n.toFixed(2);
  }

  function roundToCents(n) {
    return Math.round(n * 100) / 100;
  }

  function formatDateTime(d) {
    if (!(d instanceof Date)) {
      d = new Date(d);
    }
    if (isNaN(d.getTime())) return "";
    const months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ];
    const month = months[d.getMonth()];
    const day = d.getDate();
    const year = d.getFullYear();
    let hour = d.getHours();
    const mins = d.getMinutes();
    const ampm = hour >= 12 ? "PM" : "AM";
    hour = hour % 12;
    if (hour === 0) hour = 12;
    const mm = mins.toString().padStart(2, "0");
    return month + " " + day + ", " + year + " · " + hour + ":" + mm + " " + ampm;
  }

  function getMonthName(date) {
    if (!(date instanceof Date)) return "";
    const months = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December",
    ];
    return months[date.getMonth()];
  }

  function isNight(date) {
    const h = date.getHours();
    return h < 5 || h >= 21;
  }

  function getScheduleBlock(date) {
    const h = date.getHours();
    if (h >= 5 && h < 11) return "morning";
    if (h >= 11 && h < 15) return "noon";
    if (h >= 15 && h < 21) return "evening";
    return "night";
  }

  function getDayOfYear(date) {
    const start = new Date(date.getFullYear(), 0, 0);
    const diff = date - start;
    const oneDay = 1000 * 60 * 60 * 24;
    return Math.floor(diff / oneDay);
  }

  function getDayKey(date) {
    return (
      date.getFullYear() +
      "-" +
      (date.getMonth() + 1) +
      "-" +
      date.getDate()
    );
  }

  function getWeekKey(date) {
    const start = gameState.startDayOfYear || getDayOfYear(date);
    const dayIndex = Math.max(0, getDayOfYear(date) - start);
    const week = Math.floor(dayIndex / 7);
    return date.getFullYear() + "-w" + week;
  }

  function ensureDayRhythmForDate(date) {
    const key = getDayKey(date);
    if (!gameState.dayRhythm || gameState.dayRhythm.dayKey !== key) {
      // Close out yesterday before starting a new day
      if (gameState.dayRhythm && gameState.dayRhythm.dayKey) {
        finalizeDayRhythm(gameState.dayRhythm);
      }
      gameState.dayRhythm = {
        dayKey: key,
        morningTravelHours: 0,
        noonCampHours: 0,
        noonEventTriggered: false,
        eveningCampChoice: null,
        nightTravelHours: 0,
        nightGuardHours: 0,
        morningSuggestionShown: false,
        noonSuggestionShown: false,
        eveningSuggestionShown: false,
      };
    }
    return gameState.dayRhythm;
  }

  function finalizeDayRhythm(prev) {
    if (!prev) return;

    const m = prev.morningTravelHours || 0;
    const noonCamp = prev.noonCampHours || 0;
    const nightTravel = prev.nightTravelHours || 0;
    const nightGuard = prev.nightGuardHours || 0;
    const campQuality = prev.eveningCampChoice;

    let score = 0;

    // Morning: aiming for roughly 3–5 hours of travel (diary pattern).:contentReference[oaicite:0]{index=0}
    const morningTarget = 4;
    const morningScore =
      1 - Math.min(Math.abs(m - morningTarget) / morningTarget, 1);
    score += morningScore * 0.4;

    // Nooning: breaking at midday to rest and water stock.:contentReference[oaicite:1]{index=1}
    if (noonCamp >= 1) score += 0.2;
    else score -= 0.15;

    // Camp quality
    if (campQuality === "proper") score += 0.2;
    else if (campQuality === "rough") score -= 0.1;
    else score -= 0.05; // never explicitly made camp

    // Night travel
    if (nightTravel <= 1) score += 0.2;
    else score -= 0.15 * Math.min(nightTravel - 1, 2);

    // Night guard
    if (nightGuard >= 1) score += 0.1;
    else score -= 0.1;

    score = clamp(score, -0.6, 0.6);
    const bonus = clamp(score * 0.1, -0.06, 0.06); // ±6% speed effect next day
    gameState.lastDayRhythmBonus = bonus;

    if (score > 0.25) {
      gameState.wagonCondition = clamp(gameState.wagonCondition + 2, 0, 100);
      addLog(
        "Yesterday's routine was well-paced; your stock and wagon seem to travel a little easier today."
      );
    } else if (score < -0.2) {
      gameState.wagonCondition = clamp(gameState.wagonCondition - 3, 0, 100);
      addLog(
        "Yesterday you pushed hard without proper rests. The team starts today stiff and tired."
      );
    }
  }

    // --- Nutrition tracking over a rolling window --------------------------------

  function ensureNutritionForDate(date) {
    const key = getDayKey(date);
    if (!gameState.currentNutrition || gameState.currentNutrition.dayKey !== key) {
      // Close out the previous day, if any
      if (gameState.currentNutrition) {
        if (!gameState.nutritionHistory) gameState.nutritionHistory = [];
        gameState.nutritionHistory.push(gameState.currentNutrition);
        if (gameState.nutritionHistory.length > 30) {
          gameState.nutritionHistory.splice(
            0,
            gameState.nutritionHistory.length - 30
          );
        }
        applyNutritionPenalties();
      }

      gameState.currentNutrition = {
        dayKey: key,
        staples: 0,
        meatFat: 0,
        fruitVeg: 0,
        coffeeTea: 0,
      };
    }
    return gameState.currentNutrition;
  }

  function recordNutrition(group, points) {
    if (!points || points <= 0) return;
    const entry = ensureNutritionForDate(gameState.date);
    if (typeof entry[group] !== "number") entry[group] = 0;
    entry[group] += points;
  }

  function applyNutritionFromFood(itemId, lbsUsed) {
    if (!lbsUsed || lbsUsed <= 0) return;
    const tags = NUTRITION_TAGS[itemId];
    if (!tags) return;
    const entry = ensureNutritionForDate(gameState.date);
    Object.keys(tags).forEach(function (group) {
      const factor = tags[group];
      if (!factor) return;
      if (typeof entry[group] !== "number") entry[group] = 0;
      entry[group] += lbsUsed * factor;
    });
  }

  function applyNutritionPenalties() {
    const hist = gameState.nutritionHistory || [];
    const window = hist.slice(-14); // last ~2 weeks
    const days = window.length;
    if (!days) return;

    const sums = { staples: 0, meatFat: 0, fruitVeg: 0, coffeeTea: 0 };
    window.forEach(function (d) {
      if (!d) return;
      sums.staples += d.staples || 0;
      sums.meatFat += d.meatFat || 0;
      sums.fruitVeg += d.fruitVeg || 0;
      sums.coffeeTea += d.coffeeTea || 0;
    });

    const mouths = Math.max(1, mouthsCount());
    const avgStaples = sums.staples / days / mouths;
    const avgMeat   = sums.meatFat  / days / mouths;
    const avgFruit  = sums.fruitVeg / days / mouths;
    const avgCoffee = sums.coffeeTea / days / mouths;

    gameState.nutritionStatus = {
      avgStaples: avgStaples,
      avgMeat: avgMeat,
      avgFruit: avgFruit,
      avgCoffee: avgCoffee,
    };

    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    if (!people.length) return;

    // Fruit/veg deficiency → camp scurvy over time
    if (typeof gameState.scurvyRiskHours !== "number") {
      gameState.scurvyRiskHours = 0;
    }
    if (avgFruit < 0.4) {
      gameState.scurvyRiskHours += 6;
      if (Math.random() < 0.25) {
        addLog(
          "Lack of fresh greens or fruit is showing: gums are tender and cuts heal slowly."
        );
      }
    } else {
      gameState.scurvyRiskHours = Math.max(0, gameState.scurvyRiskHours - 8);
    }
    if (avgFruit > 0.8) {
      gameState.scurvyRiskHours = Math.max(0, gameState.scurvyRiskHours - 18);
      people.forEach(function (p) {
        const aff = p.afflictions && p.afflictions.find(function (a) {
          return a && a.id === "camp_scurvy" && !a.resolved;
        });
        if (aff) {
          aff.reliefHours = (aff.reliefHours || 0) + 2;
        }
      });
      if (Math.random() < 0.35) {
        addLog("Fresh greens and berries lift spirits and keep scurvy at bay.");
      }
    }
    if (gameState.scurvyRiskHours > 120) {
      const untreated = people.find(function (p) {
        return p && !hasAffliction(p, "camp_scurvy");
      });
      if (untreated) {
        addAffliction(untreated, "camp_scurvy", { severity: avgFruit < 0.2 ? 2 : 1 });
        gameState.scurvyRiskHours = 60;
      }
    }

    // Low meat/fat → chronic fatigue
    if (avgMeat < 0.35) {
      people.forEach(function (p) {
        p.energy = clamp(p.energy - 2, 0, 100);
      });
      if (Math.random() < 0.25) {
        addLog(
          "With little meat or fat, everyone feels hollow and slow to regain their strength."
        );
      }
    }

    // Little coffee/tea → morale sag
    if (avgCoffee < 0.25) {
      people.forEach(function (p) {
        p.morale = clamp(p.morale - 1, 0, 100);
      });
      if (Math.random() < 0.2) {
        addLog(
          "There has been no coffee or tea for days; nerves fray and tempers are short around the fire."
        );
      }
    }
  }


  function triggerNoonRestEvent() {
    const people = getAllPeople();
    if (!people.length) return;
    people.forEach(function (p) {
      if (!p || !p.alive) return;
      p.energy = clamp(p.energy + 3, 0, 110);
      p.morale = clamp(p.morale + 1, 0, 100);
    });
    gameState.wagonCondition = clamp(gameState.wagonCondition + 1, 0, 100);
    addLog(
      "You make a noon halt: animals are watered and graze while everyone eats cold fare and tightens yokes and harness."
    );
  }

  function updateDayRhythmForCurrentHour(milesThisHour) {
    const dr = gameState.dayRhythm;
    if (!dr) return;

    const block = getScheduleBlock(gameState.date);
    const hour = gameState.date.getHours();

    // Morning suggestion: get moving in the cool hours.
    if (
      block === "morning" &&
      !dr.morningSuggestionShown &&
      hour >= 5 &&
      hour < 9
    ) {
      addLog(
        "At first light the camp stirs—stock rounded up and yokes checked. Most trains try to make several miles in the cool morning hours."
      );
      dr.morningSuggestionShown = true;
    }

    if (
      block === "morning" &&
      milesThisHour > 0.01 &&
      gameState.mode === "travel"
    ) {
      dr.morningTravelHours += 1;
    }

    // Nooning: bonus if you actually stop at midday.
    if (block === "noon") {
      if (gameState.mode === "camp") {
        dr.noonCampHours += 1;
        if (!dr.noonEventTriggered) {
          triggerNoonRestEvent();
          dr.noonEventTriggered = true;
        }
      } else if (!dr.noonSuggestionShown) {
        addLog(
          "Midday heat builds. Most trains halt to 'noon'—rest the stock, eat a cold lunch, and check the wagons."
        );
        dr.noonSuggestionShown = true;
      }
    }

    // Evening suggestion: look for camp.
    if (block === "evening" && !dr.eveningSuggestionShown) {
      if (gameState.mode === "travel") {
        addLog(
          "Evening comes on. This is when most emigrants look for grass, water, and fuel and make a careful camp for the night."
        );
      }
      dr.eveningSuggestionShown = true;
    }

    // Night travel & guard tracking
    if (block === "night") {
      if (milesThisHour > 0.01 && gameState.mode === "travel") {
        dr.nightTravelHours += 1;
      }
      if (gameState.mode === "camp" && gameState.guardLevel >= 1) {
        dr.nightGuardHours += 1;
      }
    }
  }

  function applyCampQualityEffects(context) {
    if (!context || !context.campQuality) return;
    const quality = context.campQuality;
    const block = getScheduleBlock(gameState.date);
    if (gameState.mode !== "camp") return;
    if (block !== "evening" && block !== "night") return;

    const people = getAllPeople();
    const ss = ensureStoryState();
    if (quality === "proper") {
      // Proper camp: small comfort & rest boost
      people.forEach(function (p) {
        if (!p || !p.alive) return;
        p.energy = clamp(p.energy + 1.2, 0, 110);
        p.morale = clamp(p.morale + 1.2, 0, 100);
        p.warmth = clamp(p.warmth + 0.8, 0, 100);
        addThought(p, {
          id: "camp_rest",
          label: "Rested by the fire",
          value: 5,
          hoursLeft: 12,
          source: "camp",
        });
      });
      ss.eventFlags.rushedCampChain = 0;
    } else if (quality === "rough") {
      // Rushed camp: more ragged
      people.forEach(function (p) {
        if (!p || !p.alive) return;
        p.energy = clamp(p.energy - 0.8, 0, 100);
        p.warmth = clamp(p.warmth - 0.8, 0, 100);
      });
      ss.eventFlags.rushedCampChain = (ss.eventFlags.rushedCampChain || 0) + 1;
      if (ss.eventFlags.rushedCampChain > 1) {
        people.forEach(function (p) {
          addThought(p, {
            id: "rough_camp_chain",
            label: "Rushed camps",
            value: -3,
            hoursLeft: 8,
            source: "camp",
          });
        });
      }
    }
  }

  function tempCtoF(c) {
    return Math.round((c * 9) / 5 + 32);
  }

  function regionAltitude(region) {
    switch (region) {
      case "plains":
      case "GreatPlains":
        return 300;
      case "central_plains":
        return 500;
      case "high_plains":
      case "HighPlains":
        return 1200;
      case "mountains":
      case "Rockies":
        return 2100;
      case "great_basin":
        return 1400;
      case "snake_plain":
      case "SnakePlain":
        return 1500;
      case "blue_mountains":
        return 1700;
      case "columbia":
      case "Columbia":
        return 400;
      case "willamette":
        return 150;
      default:
        return 400;
    }
  }

  function describeWeatherLabel(tempC, precip, storm, clouds) {
    let label = "";
    if (precip === "snow") {
      if (storm) label = "Snowstorm";
      else if (tempC <= -10) label = "Bitter snow";
      else label = "Light snow";
    } else if (precip === "rain") {
      if (storm) label = "Thunderstorms";
      else if (clouds > 0.7) label = "Steady rain";
      else label = "Showers";
    } else {
      if (tempC <= -5) label = "Bitter cold";
      else if (tempC <= 0) label = "Frosty";
      else if (tempC < 8) label = "Chilly";
      else if (tempC < 16) label = "Cool";
      else if (tempC < 24) label = "Mild";
      else if (tempC < 30) label = "Warm";
      else label = "Scorching heat";

      if (precip === "none") {
        if (clouds > 0.7) label = "Overcast " + label.toLowerCase();
        else if (clouds < 0.25) label = "Clear " + label.toLowerCase();
      }
    }
    return label;
  }

  function formatWeatherSummary(w) {
    if (!w) return "Unknown";
    const parts = [];
    if (typeof w.tempC === "number") parts.push(tempCtoF(w.tempC) + "°F");
    if (w.precip && w.precip !== "none") parts.push(w.precip === "snow" ? "snow" : "rain");
    else parts.push("dry");
    if (w.storm) parts.push("storm");
    if (typeof w.windKph === "number") parts.push("wind " + w.windKph + " km/h");
    return parts.join(", ");
  }

  function describeWeatherFlavor(region, weather) {
    if (!weather) return "";
    const hot = weather.tempC >= 30;
    const cold = weather.tempC <= -2;
    const cloudy = weather.clouds >= 0.6;
    if (weather.storm && region === "GreatPlains") {
      return "Black anvil clouds boil over the prairie; lightning flickers on the horizon.";
    }
    if (weather.storm && region === "SnakePlain") {
      return "Heat lightning pulses above distant buttes while dust devils tear across the plain.";
    }
    if (hot && region === "SnakePlain") {
      return "Heat shimmer and dust haze blur the Snake River plain.";
    }
    if (cold && region === "Rockies") {
      return "Thin mountain air bites at fingers and cheeks; snow lingers in the shadows.";
    }
    if (cloudy && region === "Columbia") {
      return "Low gray clouds hang over the gorge, the air damp with river spray.";
    }
    if (cloudy) {
      return "High clouds veil the sun, softening the light on the trail ahead.";
    }
    return "The sky feels vast and clear, wagon tracks stretching toward the horizon.";
  }

  function describeSeasonRisk(region, date, profile) {
    if (!date) return "";
    const month = date.getMonth();
    const lateSeason = month >= 8; // September or later
    if (!profile) {
      profile = START_PROFILES[gameState.startProfileId];
    }
    if (
      profile &&
      profile.riverHazard === "high" &&
      (region === "GreatPlains" || region === "HighPlains") &&
      gameState.highRiverRisk
    ) {
      return "High water from spring runoff makes crossings treacherous.";
    }
    if (
      profile &&
      profile.heatHazard === "high" &&
      (region === "GreatPlains" || region === "SnakePlain") &&
      month >= 5 &&
      month <= 7
    ) {
      return "Heat and dust grind at the stock; keep water and rest in mind.";
    }
    if (
      profile &&
      profile.lateSeasonRisk === "high" &&
      lateSeason &&
      (region === "Rockies" || region === "Columbia")
    ) {
      return "Snow threatens early on the passes; you are running late for the season.";
    }
    return "";
  }

  function getAllPeople() {
    const arr = [];
    if (gameState.leader) {
      ensurePersonStoryFields(gameState.leader);
      arr.push(gameState.leader);
    }
    if (gameState.companions && gameState.companions.length) {
      gameState.companions.forEach(function (p) {
        if (p) {
          ensurePersonStoryFields(p);
          arr.push(p);
        }
      });
    }
    return arr;
  }

  function getActiveLeader() {
    if (gameState.actingLeaderId) {
      const acting = getAllPeople().find(function (p) {
        return p && p.id === gameState.actingLeaderId && p.alive;
      });
      if (acting) return acting;
    }
    return gameState.leader;
  }

  function addAffliction(person, afflictionId, opts) {
    const def = AFFLICTION_DEFS[afflictionId];
    if (!person || !def) return null;
    ensureAfflictions(person);

    const existing = person.afflictions.find(function (a) {
      return a.id === afflictionId && !a.resolved;
    });
    if (existing) {
      existing.severity = Math.max(
        existing.severity || 1,
        (opts && typeof opts.severity === "number" ? opts.severity : 1) || 1
      );
      return existing;
    }

    const rng =
      (gameState.weatherSystem && gameState.weatherSystem.rng) || Math.random;
    function pickRange(range) {
      const min = range[0];
      const max = range[1];
      return min + (max - min) * rng();
    }

    const severity =
      opts && typeof opts.severity === "number"
        ? opts.severity
        : Math.round(pickRange(def.severityRange));

    const incubation = pickRange(def.baseHoursIncubation);
    const acute = pickRange(def.baseHoursAcute);
    const recoveryWindow = def.baseHoursRecovery
      ? pickRange(def.baseHoursRecovery)
      : 24 + severity * 12 + rng() * 18;

    const aff = {
      id: def.id,
      label: def.label,
      type: def.type,
      stage: "incubation",
      severity: severity,
      hoursActive: 0,
      hoursIncubation: incubation,
      hoursAcute: acute,
      recoveryBuffer: recoveryWindow,
      cause: def.cause,
      tags: def.tags || [],
      crisisThreshold: def.crisisThreshold || 20,
      startedAt: new Date(gameState.date.getTime()),
      resolved: false,
      reliefHours: 0,
      lastNotified: 0,
      tendedThisHour: false,
    };

    person.afflictions.push(aff);

    let onsetText =
      def.id === "sprain"
        ? person.name +
          " favors an injured ankle and knows it will be painful to walk for a while."
        : person.name + " doesn’t feel quite right: aches and unease set in.";
    if (aff.id === "cholera") {
      onsetText =
        person.name +
        " reels with stomach cramps and watery sickness after a dubious draw of water.";
    } else if (aff.id === "camp_scurvy") {
      onsetText =
        person.name +
        " complains of sore joints and bleeding gums after too many days without greens.";
    } else if (aff.id === "snakebite") {
      onsetText =
        person.name +
        " yells—a rattler’s bite leaves a pair of punctures and swelling already climbing.";
    } else if (aff.id === "broken_bone") {
      onsetText =
        person.name +
        " goes down hard. A limb hangs wrong; splints and long rest will be needed.";
    }
    logAfflictionStageChange(person, aff, "none");
    return aff;
  }

  function getBestDoctor() {
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    if (!people.length) return null;
    return people.reduce(function (best, p) {
      const skill = p.skills && p.skills.doctoring ? p.skills.doctoring : 0;
      if (!best) return p;
      const bestSkill =
        best.skills && best.skills.doctoring ? best.skills.doctoring : 0;
      return skill > bestSkill ? p : best;
    }, null);
  }

  function activeAfflictions(person) {
    if (!person || !person.afflictions) return [];
    return person.afflictions.filter(function (a) {
      return a && !a.resolved;
    });
  }

  function ensurePersonDelegationFields(person) {
    if (!person) return;
    if (!person.priorities) {
      person.priorities = {};
    }
    if (!person.skillXP) {
      person.skillXP = {
        travel: 0,
        hunting: 0,
        cooking: 0,
        woodcutting: 0,
        doctoring: 0,
        repair: 0,
        guard: 0,
        craft: 0,
        foraging: 0,
      };
    }
    [
      "travel",
      "hunting",
      "cooking",
      "woodcutting",
      "doctoring",
      "repair",
      "guard",
      "craft",
      "foraging",
    ].forEach(function (k) {
      if (typeof person.skillXP[k] !== "number") {
        person.skillXP[k] = 0;
      }
      if (!person.skills) person.skills = {};
      if (typeof person.skills[k] !== "number") person.skills[k] = 1;
    });
  }

  function skillIdLabel(id) {
    if (id === "travel") return "trailcraft";
    if (id === "hunting") return "hunting";
    if (id === "cooking") return "cooking";
    if (id === "woodcutting") return "woodcraft";
    if (id === "doctoring") return "doctoring";
    if (id === "repair") return "repair";
    if (id === "guard") return "guard duty";
    if (id === "craft") return "crafting";
    if (id === "foraging") return "foraging";
    return id;
  }

  function gainSkillXP(person, skillId, amount) {
    if (!person || !skillId) return;
    ensurePersonDelegationFields(person);
    const skills = person.skills || {};
    let level = typeof skills[skillId] === "number" ? skills[skillId] : 0;
    let xp = person.skillXP[skillId] || 0;
    xp += amount || 1;
    let leveled = false;
    while (level < 5) {
      const needed = 12 + level * 10;
      if (xp < needed) break;
      xp -= needed;
      level += 1;
      leveled = true;
      addLog(
        person.name +
          "'s " +
          skillIdLabel(skillId) +
          " improves from hard use."
      );
    }
    person.skillXP[skillId] = xp;
    skills[skillId] = level;
    person.skills = skills;
  }

  function initializePartyPriorities() {
    const people = getAllPeople();
    if (!people.length) return;
    JOB_DEFS.forEach(function (job) {
      const skillId = job.relatedSkill;
      const sorted = people
        .map(function (p) {
          const skills = p.skills || {};
          return {
            person: p,
            skill: typeof skills[skillId] === "number" ? skills[skillId] : 0,
          };
        })
        .sort(function (a, b) {
          return b.skill - a.skill;
        });
      sorted.forEach(function (entry, idx) {
        const p = entry.person;
        ensurePersonDelegationFields(p);
        if (!p.priorities) p.priorities = {};
        let prio = 0;
        const s = entry.skill;
        if (s <= 0) {
          prio = 0;
        } else if (idx === 0) {
          prio = 1;
        } else if (idx === 1) {
          prio = 2;
        } else if (idx === 2) {
          prio = 3;
        } else {
          prio = 4;
        }
        if (job.id === "travel" && p.isLeader) {
          prio = 1;
        }
        p.priorities[job.id] = prio;
      });
    });
  }

  function ensureDelegationState() {
    const people = getAllPeople();
    if (!gameState.companions) gameState.companions = [];
    people.forEach(ensurePersonDelegationFields);
    let hasAny = false;
    people.forEach(function (p) {
      if (!p || !p.priorities) return;
      for (const k in p.priorities) {
        if (p.priorities[k] > 0) {
          hasAny = true;
          break;
        }
      }
    });
    if (!hasAny && people.length) {
      initializePartyPriorities();
    }
  }

  function jobToTaskId(jobId) {
    const def = JOB_DEFS.find(function (j) {
      return j.id === jobId;
    });
    return def ? def.taskId : jobId;
  }

  function traitTaskBias(person, jobId) {
    let bias = 0;
    (person.traits || []).forEach(function (tid) {
      const def = getTraitDef(tid);
      if (!def) return;
      if (jobId === "guard" && def.guardBonus) bias += def.guardBonus * 0.5;
      if (jobId === "guard" && def.guardPenalty) bias -= def.guardPenalty * 0.5;
      if (def.taskPenalty) bias -= def.taskPenalty * 0.5;
      if (def.socialBonus && jobId === "cook") bias += 0.2;
    });
    return bias;
  }

  function detectCrisisNeeds() {
    const ss = ensureStoryState();
    const needs = [];
    if (ss.risk.water_shortage || ss.risk.extended_water_shortage) needs.push("fetch_water");
    if (ss.risk.starvation || ss.risk.extended_starvation) needs.push("cook");
    if (ss.risk.cold_exposure || ss.risk.extended_cold_exposure) needs.push("gather_wood");
    if (gameState.wagonCondition < 45) needs.push("repair");
    if (getScheduleBlock(gameState.date) === "night" && gameState.mode === "camp" && gameState.guardLevel < 1)
      needs.push("guard");
    if (ss.risk.low_morale) needs.push("cook");
    return needs;
  }

  function resolveTasksForHour() {
    const people = getAllPeople();
    const resolved = [];
    const autoIndices = [];
    const date = gameState.date;
    const block = getScheduleBlock(date);
    const mode = gameState.mode;
    const nightNow = isNight(date);

    const s = gameState.supplies || {};
    const mouths = mouthsCount();
    const waterGal = s.water || 0;
    const cookedMeals =
      (s.meal_simple || 0) +
      (s.meal_hearty || 0) +
      (s.meal_feast || 0) +
      (s.cooked_meals || 0);
    const fuelUnits = (s.firewood || 0) + (s.buffalo_chips || 0);
    const wagonHurt = gameState.wagonCondition < 70;
    const seriousAfflictions = getAllPeople().some(function (p) {
      return (
        p &&
        p.afflictions &&
        p.afflictions.some(function (a) {
          return a && !a.resolved && (a.stage === "acute" || a.severity >= 2);
        })
      );
    });

    const lowWater = waterGal < mouths * 0.4;
    const fewMeals = cookedMeals < mouths * 1.5;
    const essentialJobs = {};

    if (mode === "camp" && nightNow) {
      essentialJobs.guard = true;
    }
    if (mode === "camp" && !nightNow && lowWater) {
      essentialJobs.fetch_water = true;
    }
    if (mode === "camp" && seriousAfflictions) {
      essentialJobs.doctor = true;
    }
    if (mode === "camp" && block === "evening" && fewMeals && fuelUnits > 0.1) {
      essentialJobs.cook = true;
    }
    if (wagonHurt && mode === "camp") {
      essentialJobs.repair = true;
    }
    if (mode === "travel") {
      essentialJobs.travel = true;
    }

    people.forEach(function (p, idx) {
      if (!p || !p.alive) {
        resolved[idx] = null;
        return;
      }
      const t = p.task || "travel";
      if (t !== "auto") {
        resolved[idx] = t;
      } else {
        autoIndices.push(idx);
      }
    });

    function assignEssential(jobId) {
      if (!essentialJobs[jobId]) return;
      const taskId = jobToTaskId(jobId);
      for (let i = 0; i < resolved.length; i++) {
        if (resolved[i] === taskId) return;
      }
      let bestIdx = null;
      let bestScore = null;
      autoIndices.forEach(function (idx) {
        const p = people[idx];
        if (!p) return;
        ensurePersonDelegationFields(p);
        const priorities = p.priorities || {};
        const prioVal = typeof priorities[jobId] === "number" ? priorities[jobId] : 0;
        if (prioVal <= 0) return;
        const def = JOB_DEFS.find(function (j) {
          return j.id === jobId;
        });
        const skills = p.skills || {};
        const sVal = def && def.relatedSkill ? (skills[def.relatedSkill] || 0) : 0;
        const score = prioVal * 10 - sVal;
        if (bestIdx === null || score < bestScore) {
          bestIdx = idx;
          bestScore = score;
        }
      });
      if (bestIdx != null) {
        resolved[bestIdx] = taskId;
        const pos = autoIndices.indexOf(bestIdx);
        if (pos >= 0) autoIndices.splice(pos, 1);
      }
    }

    ["guard", "cook", "fetch_water", "repair", "travel"].forEach(assignEssential);

    const crisisJobs = detectCrisisNeeds();
    function assignCrisis(jobId) {
      const taskId = jobToTaskId(jobId);
      let bestIdx = null;
      let bestScore = -999;
      autoIndices.forEach(function (idx) {
        const p = people[idx];
        if (!p) return;
        const def = JOB_DEFS.find(function (j) {
          return j.id === jobId;
        });
        const skills = p.skills || {};
        const sVal = def && def.relatedSkill ? (skills[def.relatedSkill] || 0) : 0;
        const prios = p.priorities || {};
        const prioVal = typeof prios[jobId] === "number" ? prios[jobId] : 0;
        const score = sVal + prioVal + traitTaskBias(p, jobId);
        if (score > bestScore) {
          bestScore = score;
          bestIdx = idx;
        }
      });
      if (bestIdx != null) {
        resolved[bestIdx] = taskId;
        const pos = autoIndices.indexOf(bestIdx);
        if (pos >= 0) autoIndices.splice(pos, 1);
        const ss = ensureStoryState();
        const nowHour = getCurrentTrailHour(gameState);
        if (!ss.lastCrisisLogHour || nowHour - ss.lastCrisisLogHour > 2) {
          addLog(
            "Auto-order: " +
              (people[bestIdx].name || "Someone") +
              " pivots to " +
              jobId +
              " to blunt a brewing risk.",
            {
              tone: "warning",
            }
          );
          ss.lastCrisisLogHour = nowHour;
        }
      }
    }
    crisisJobs.forEach(assignCrisis);

    function chooseScheduledJob(person, jobListPrimary) {
      ensurePersonDelegationFields(person);
      const priorities = person.priorities || {};
      let bestJob = null;
      let bestScore = null;
      function consider(jobId) {
        const prioVal = typeof priorities[jobId] === "number" ? priorities[jobId] : 0;
        if (prioVal <= 0) return;
        const def = JOB_DEFS.find(function (j) {
          return j.id === jobId;
        });
        const skills = person.skills || {};
        const sVal = def && def.relatedSkill ? (skills[def.relatedSkill] || 0) : 0;
        const score = prioVal * 10 - sVal;
        if (bestJob === null || score < bestScore) {
          bestJob = jobId;
          bestScore = score;
        }
      }
      jobListPrimary.forEach(consider);
      if (!bestJob) {
        JOB_DEFS.forEach(function (j) {
          consider(j.id);
        });
      }
      return bestJob ? jobToTaskId(bestJob) : null;
    }

    autoIndices.forEach(function (idx) {
      const p = people[idx];
      if (!p || !p.alive) return;
      let jobList = [];
      if (mode === "travel") {
        if (block === "night") {
          jobList = ["guard", "sleep", "rest"];
        } else {
          jobList = ["travel", "hunt", "scout", "fetch_water", "gather_wood"];
        }
      } else {
        if (block === "morning") {
          jobList = ["cook", "gather_wood", "fetch_water", "repair", "travel"];
        } else if (block === "noon") {
          jobList = ["rest", "cook", "repair", "gather_wood"];
        } else if (block === "evening") {
          jobList = ["cook", "gather_wood", "repair", "guard"];
        } else {
          jobList = ["guard", "sleep", "rest", "cook"];
        }
      }
      const primaryJobs = jobList.filter(function (j) {
        return j !== "rest" && j !== "sleep";
      });
      let taskId = null;
      if (primaryJobs.length) {
        taskId = chooseScheduledJob(p, primaryJobs);
      }
      if (!taskId) {
        if (nightNow && mode !== "travel") taskId = "sleep";
        else taskId = "rest";
      }
      resolved[idx] = taskId || "rest";
    });

    return resolved;
  }

  /* ========= GAME INITIALIZATION ========================================== */

  function initDom() {
    dom.root = document.getElementById("oldtrail-root");
    dom.screens = {
      start: document.getElementById("ot-screen-start"),
      outfit: document.getElementById("ot-screen-outfit"),
      travel: document.getElementById("ot-screen-travel"),
    };
    dom.leaderPill = document.getElementById("ot-leader-pill");
    dom.btnReset = document.getElementById("ot-btn-reset");

    dom.leaderName = document.getElementById("ot-leader-name");
    dom.leaderCallingPreview = document.getElementById("ot-leader-calling");
    dom.leaderFundsPreview = document.getElementById("ot-leader-starting-funds");
    dom.departureSelect = document.getElementById("ot-departure");
    dom.departureSeason = document.getElementById("ot-departure-season");
    dom.departureSeasonDesc = document.getElementById(
      "ot-departure-season-desc"
    );
    dom.storytellerPreset = document.getElementById("ot-storyteller-preset");
    dom.draftRows = document.getElementById("ot-draft-rows");
    dom.draftInfo = { leader: document.getElementById("ot-draft-info-leader") };
    dom.btnGenerateParty = document.getElementById("ot-btn-generate-party");
    dom.mythicToggle = document.getElementById("ot-mythic-toggle");
    buildDraftRows();
    dom.startArt = document.getElementById("ot-start-art");
    dom.btnBeginOutfit = document.getElementById("ot-btn-begin-outfit");

    dom.outfitIntro = document.getElementById("ot-outfit-intro");
    dom.outfitBody = document.getElementById("ot-outfit-body");
    dom.outfitTable = document.getElementById("ot-outfit-table");
    dom.outfitArt = document.getElementById("ot-outfit-art");
    dom.btnAddRecommended = document.getElementById("ot-btn-add-recommended");
    dom.btnBeginJourney = document.getElementById("ot-btn-begin-journey");
    dom.sumStarting = document.getElementById("ot-sum-starting");
    dom.sumMoney = document.getElementById("ot-sum-money");
    dom.sumLoad = document.getElementById("ot-sum-load");
    dom.sumDraft = document.getElementById("ot-sum-draft");
    dom.sumRatio = document.getElementById("ot-sum-ratio");

    dom.ontrailPace = document.getElementById("ot-ontrail-pace");
    dom.ontrailRations = document.getElementById("ot-ontrail-rations");
    dom.ontrailMode = document.getElementById("ot-ontrail-mode");
    dom.ontrailBlock = document.getElementById("ot-ontrail-block");
    dom.weatherSummary = document.getElementById("ot-weather-summary");
    dom.weatherNote = document.getElementById("ot-weather-note");
    dom.reputationChip = document.getElementById("ot-reputation-chip");
    dom.factionChips = {
      forts: document.getElementById("ot-faction-forts"),
      caravans: document.getElementById("ot-faction-caravans"),
      open_eye: document.getElementById("ot-faction-open-eye"),
      men_in_gray: document.getElementById("ot-faction-men-in-gray"),
    };
    dom.leaderStatus = document.getElementById("ot-leader-status");
    dom.partyManifest = document.getElementById("ot-party-manifest");
    dom.hourTasks = document.getElementById("ot-hour-tasks");
    dom.scene = document.getElementById("ot-scene");
    dom.sceneCaption = document.getElementById("ot-scene-caption");
    dom.afflictionAlerts = document.getElementById("ot-affliction-alerts");
    dom.trailCanvas = document.getElementById("ot-trail-canvas");
    dom.btnViewJournal = document.getElementById("ot-btn-view-journal");
    dom.btnViewExplorer = document.getElementById("ot-btn-view-explorer");
    dom.trailHeader = document.getElementById("ot-trail-header");
    dom.trailMap = document.getElementById("ot-trail-map");
    dom.mapViewport = document.getElementById("ot-map-viewport");
    dom.mapCanvas = null;
    dom.mapTooltip = document.getElementById("ot-map-tooltip");
    dom.btnOpenMap = document.getElementById("ot-btn-open-map");
    dom.btnCloseMap = document.getElementById("ot-btn-close-map");
    dom.mapModal = document.getElementById("ot-map-modal");
    dom.mapBackdrop = dom.mapModal
      ? dom.mapModal.querySelector(".ot-modal-backdrop")
      : null;
    dom.btnToggleMapList = document.getElementById("ot-btn-toggle-maplist");
    dom.btnTravel1h = document.getElementById("ot-btn-travel-1h");
    dom.btnTravel4h = document.getElementById("ot-btn-travel-4h");
    dom.btnAutoTravel = document.getElementById("ot-btn-auto-travel");
    dom.btnClearTarget = document.getElementById("ot-btn-clear-target");
    dom.targetMeta = document.getElementById("ot-target-meta");
    dom.localConditions = document.getElementById("ot-local-conditions");
    dom.toggleFog = document.getElementById("ot-toggle-fog");
    dom.toggleSilhouettes = document.getElementById("ot-toggle-silhouettes");
    dom.companionDetail = document.getElementById("ot-companion-detail");
    dom.trailLog = document.getElementById("old-trail-log-widget");
    dom.suppliesOverview = document.getElementById("ot-supplies-overview");
    dom.cascadePanel = document.getElementById("ot-cascade-panel");
    dom.cascadeSummary = document.getElementById("ot-cascade-summary");
    dom.cascadeHighlights = document.getElementById("ot-cascade-highlights");
    dom.cascadeTimeline = document.getElementById("ot-cascade-timeline");
    dom.cascadePeople = document.getElementById("ot-cascade-people");
    dom.footerStatus = document.getElementById("ot-footer-status");
    dom.btnAdvance1 = document.getElementById("ot-btn-advance-1");
    dom.btnAdvance4 = document.getElementById("ot-btn-advance-4");
    dom.btnToggleMode = document.getElementById("ot-btn-toggle-mode");
    dom.btnChangePace = document.getElementById("ot-btn-change-pace");
    dom.btnChangeRations = document.getElementById("ot-btn-change-rations");
    dom.btnOpenInventory = document.getElementById("ot-btn-open-inventory");
    dom.btnOpenTrade = document.getElementById("ot-btn-open-trade");
    dom.btnOpenCamp = document.getElementById("ot-btn-open-camp-tasks");
    dom.explorerChip = document.getElementById("ot-explorer-chip");
    dom.explorerTooltip = document.getElementById("ot-explorer-tooltip");
    dom.btnCampfireMoment = document.getElementById("ot-btn-campfire-moment");

    dom.encounterModal = document.getElementById("ot-encounter-modal");
    dom.encounterContent = dom.encounterModal
      ? dom.encounterModal.querySelector(".ot-encounter-content")
      : null;
    dom.encounterTitle = document.getElementById("ot-encounter-title");
    dom.encounterSubtitle = document.getElementById("ot-encounter-subtitle");
    dom.encounterBody = document.getElementById("ot-encounter-body");
    dom.encounterOptions = document.getElementById("ot-encounter-options");
    dom.encounterImage = document.getElementById("ot-encounter-image");
    dom.encounterCompanions = document.getElementById("ot-encounter-companions");

    dom.inventoryModal = document.getElementById("ot-inventory-modal");
    dom.modalBackdrop = dom.inventoryModal
      ? dom.inventoryModal.querySelector(".ot-modal-backdrop")
      : null;
    dom.inventorySub = document.getElementById("ot-inventory-sub");
    dom.inventoryBody = document.getElementById("ot-inventory-body");
    dom.btnCloseInventory = document.getElementById("ot-btn-close-inventory");

    dom.tradeModal = document.getElementById("ot-trade-modal");
    dom.tradeBackdrop = dom.tradeModal
      ? dom.tradeModal.querySelector(".ot-modal-backdrop")
      : null;
    dom.tradeTitle = document.getElementById("ot-trade-title");
    dom.tradeSub = document.getElementById("ot-trade-sub");
    dom.tradeSummary = document.getElementById("ot-trade-summary");
    dom.tradeBody = document.getElementById("ot-trade-body");
    dom.tradeMsg = document.getElementById("ot-trade-msg");
    dom.barterPanel = document.getElementById("ot-barter-panel");
    dom.tradeLedgerNotes = document.getElementById("ot-trade-ledger-notes");
    dom.tradeLedgerBody = document.getElementById("ot-trade-ledger-body");
    dom.btnTradeBuyTab = document.getElementById("ot-trade-tab-buy");
    dom.btnTradeSellTab = document.getElementById("ot-trade-tab-sell");
    dom.btnTradeBarterTab = document.getElementById("ot-trade-tab-barter");
    dom.btnCloseTrade = document.getElementById("ot-btn-close-trade");

    dom.btnOpenPriorities = document.getElementById("ot-btn-open-priorities");
    dom.prioritiesModal = document.getElementById("ot-priorities-modal");
    dom.prioritiesBackdrop = dom.prioritiesModal
      ? dom.prioritiesModal.querySelector(".ot-modal-backdrop")
      : null;
    dom.prioritiesHeadRow = document.getElementById("ot-priorities-head-row");
    dom.prioritiesBody = document.getElementById("ot-priorities-body");
    dom.prioritiesWarnings = document.getElementById("ot-priorities-warnings");
    dom.btnClosePriorities = document.getElementById("ot-btn-close-priorities");
    dom.socialModal = document.getElementById("ot-social-modal");
    dom.socialBackdrop = dom.socialModal
      ? dom.socialModal.querySelector(".ot-modal-backdrop")
      : null;
    dom.socialBody = document.getElementById("ot-social-body");
    dom.btnOpenSocial = document.getElementById("ot-btn-open-social");
    dom.btnEveningProperCamp = document.getElementById("ot-btn-evening-proper-camp");
    dom.btnEveningRushedCamp = document.getElementById("ot-btn-evening-rushed-camp");
    dom.campOverlay = document.getElementById("ot-camp-overlay");
    dom.btnCloseCamp = document.getElementById("ot-btn-close-camp");
    dom.btnCampConfirm = document.getElementById("ot-btn-camp-confirm");
    dom.btnCampAuto = document.getElementById("ot-btn-camp-auto");
    dom.campSummaryNote = document.getElementById("ot-camp-summary-note");
    dom.campRolesSummary = document.getElementById("ot-camp-roles-summary");
    dom.campChoreStrips = document.getElementById("ot-camp-chore-strips");
    dom.btnEditRoles = document.getElementById("ot-btn-edit-roles");
    dom.craftingWidget = document.getElementById("oldtrail-crafting-widget");
    dom.thoughtsBubble = document.getElementById("oldtrail-thoughts-bubble");

    dom.storytellerDesc = document.getElementById("ot-storyteller-desc");
    dom.storytellerMidrun = document.getElementById("ot-storyteller-midrun");
    dom.narratorLabel = document.getElementById("ot-narrator-label");
    dom.narratorPicker = document.getElementById("ot-narrator-picker");
    dom.narratorHint = document.getElementById("ot-narrator-hint");
    dom.narratorRules = document.getElementById("ot-narrator-rules");
    dom.btnToggleNarrator = document.getElementById("ot-btn-toggle-narrator");
    dom.storytellerCards = document.getElementById("ot-storyteller-cards");
    dom.storytellerExample = document.getElementById("ot-storyteller-example");
    dom.tensionDebug = document.getElementById("ot-tension-debug");
    dom.tensionReadout = document.getElementById("ot-tension-readout");

  }

  function showScreen(name) {
    Object.keys(dom.screens).forEach(function (key) {
      dom.screens[key].classList.remove("ot-screen-active");
    });
    if (dom.screens[name]) {
      dom.screens[name].classList.add("ot-screen-active");
    }
    gameState.phase = name;

    if (name === "travel") {
      setTravelView(gameState.travelView || "journal");
    }
  }

  function resetSupplies() {
    gameState.supplies = {};
    SUPPLY_ITEMS.forEach(function (item) {
      gameState.supplies[item.id] = 0;
    });
  }

  function createPerson(name, isLeader, bias, draft) {
    const base = 100;
    const person = {
      name: name || (isLeader ? "Leader" : "Companion"),
      isLeader: !!isLeader,
      genderHint: draft && draft.genderHint ? draft.genderHint : deriveGenderHint(name),
      condition: base,
      hunger: 100,
      thirst: 100,
      warmth: 85,
      energy: 95,
      morale: 85,
      moodState: "Upbeat",
      thoughts: [],
      optimism: 58,
      lowMoraleHours: 0,
      relationships: {},
      traits: [],
      id: "p" + PERSON_ID_COUNTER++,
      skills: {
        travel: 1,
        hunting: 1,
        cooking: 1,
        woodcutting: 1,
        doctoring: 1,
        repair: 1,
        guard: 1,
        craft: 1,
        foraging: 1,
      },
      task: "travel",
      alive: true,
      priorities: {},
      skillXP: {
        travel: 0,
        hunting: 0,
        cooking: 0,
        woodcutting: 0,
        doctoring: 0,
        repair: 0,
        guard: 0,
        craft: 0,
        foraging: 0,
      },
      afflictions: [],
      lastBreakHour: 0,
    };
    if (bias) {
      Object.keys(bias).forEach(function (k) {
        person.skills[k] = clamp(person.skills[k] + bias[k], 0, 5);
      });
    }
    if (draft) {
      if (draft.age) person.age = draft.age;
      if (draft.origin) person.origin = draft.origin;
      if (draft.backstoryId) person.backstoryId = draft.backstoryId;
      if (draft.backstoryLabel) person.backstoryLabel = draft.backstoryLabel;
      if (draft.backstorySummary) person.backstorySummary = draft.backstorySummary;
      if (draft.traits && draft.traits.length) person.traits = draft.traits.slice();
      if (draft.hiddenTraits) person.hiddenTraits = draft.hiddenTraits.slice();
      if (draft.skillBias) {
        Object.keys(draft.skillBias).forEach(function (k) {
          person.skills[k] = clamp((person.skills[k] || 0) + draft.skillBias[k], 0, 6);
        });
      }
    }
    applyTraitStats(person);
    return person;
  }

  function pickStartDateFromSeason() {
    const profileId = dom.departureSeason
      ? dom.departureSeason.value
      : "late_april";
    const profile = START_PROFILES[profileId] || START_PROFILES.late_april;
    gameState.seasonStart = profileId;
    gameState.startProfileId = profileId;
    gameState.startProfile = profile;
    const startDate = new Date(
      1848,
      profile.startMonth,
      profile.startDay,
      16,
      0,
      0
    );
    gameState.startDayOfYear = getDayOfYear(startDate);
    gameState.highRiverRisk = profile.riverHazard === "high";
    return startDate;
  }

  /* ========= PARTY DRAFTING ============================================= */

  function ensurePartyDraftState() {
    if (!gameState.partyDraft)
      gameState.partyDraft = {
        seed: Math.floor(Math.random() * 999999),
        people: {},
        locks: {},
        rerolls: {},
        mythicTraitUsed: false,
      };
    if (!gameState.partyDraft.people) gameState.partyDraft.people = {};
    if (!gameState.partyDraft.locks) gameState.partyDraft.locks = {};
    if (!gameState.partyDraft.rerolls) gameState.partyDraft.rerolls = {};
    if (typeof gameState.partyDraft.mythicTraitUsed !== "boolean")
      gameState.partyDraft.mythicTraitUsed = false;
    if (typeof gameState.partyDraft.seed !== "number") {
      gameState.partyDraft.seed = Math.floor(Math.random() * 999999);
    }
    return gameState.partyDraft;
  }

  function draftRng(slot) {
    const draft = ensurePartyDraftState();
    const bump = draft.rerolls[slot] || 0;
    return mulberry32(hashToInt(`${draft.seed}-${slot}-${bump}`));
  }

  function rollName(rng) {
    const first = PARTY_NAME_SETS.first[Math.floor(rng() * PARTY_NAME_SETS.first.length)] || "Unknown";
    const last = PARTY_NAME_SETS.last[Math.floor(rng() * PARTY_NAME_SETS.last.length)] || "Traveler";
    return first + " " + last;
  }

  function deriveGenderHint(name) {
    const first = (name || "").split(" ")[0] || "";
    if (FEMALE_NAME_HINTS.has(first)) return "female";
    if (first) return "male";
    return "unknown";
  }

  function pickBackstory(rng, person) {
    const gender = person && person.genderHint ? person.genderHint : "unknown";
    const pool = BACKSTORY_DEFS.filter(function (b) {
      if (!b.allowedGenders || !b.allowedGenders.length) return true;
      return b.allowedGenders.indexOf(gender) >= 0;
    });
    const source = pool.length ? pool : BACKSTORY_DEFS;
    return source[Math.floor(rng() * source.length)] || source[0];
  }

  function bucketForTrait(id) {
    if (!id) return "common";
    if (TRAIT_BUCKETS_V1.rare.indexOf(id) >= 0) return "rare";
    if (TRAIT_BUCKETS_V1.uncommon.indexOf(id) >= 0) return "uncommon";
    if (TRAIT_BUCKETS_V1.mythic.indexOf(id) >= 0) return "mythic";
    return "common";
  }

  function rollTraitBucket(rng, allowMythic) {
    const weights = Object.assign({}, TRAIT_BUCKET_WEIGHTS_V1);
    if (!allowMythic) weights.mythic = 0;
    const total = Object.keys(weights).reduce(function (sum, key) {
      return sum + (weights[key] || 0);
    }, 0);
    let pick = rng() * total;
    let chosen = "common";
    ["common", "uncommon", "rare", "mythic"].forEach(function (bucket) {
      if (pick < (weights[bucket] || 0) && chosen === "common") {
        chosen = bucket;
      }
      pick -= weights[bucket] || 0;
    });
    return chosen;
  }

  function pickTraitFromBucket(bucket, rng, picked, allowMythic) {
    const pool = TRAIT_BUCKETS_V1[bucket] || [];
    const candidates = pool.filter(function (id) {
      if (picked.indexOf(id) >= 0) return false;
      const def = getTraitDef(id);
      if (!def) return false;
      if (bucket === "mythic" && !allowMythic) return false;
      return true;
    });
    if (!candidates.length) return null;
    return candidates[Math.floor(rng() * candidates.length)];
  }

  function pickTraits(rng, count, existing) {
    const picked = existing ? existing.slice() : [];
    const draft = ensurePartyDraftState();
    let rareCount = picked.filter(function (id) {
      return bucketForTrait(id) === "rare";
    }).length;
    let mythicCount = picked.filter(function (id) {
      return bucketForTrait(id) === "mythic";
    }).length;
    while (picked.length < count) {
      const allowMythic = !!gameState.mythicEnabled && mythicCount < 1 && !draft.mythicTraitUsed;
      const bucket = rollTraitBucket(rng, allowMythic);
      if (bucket === "rare" && rareCount >= 1) continue;
      if (bucket === "mythic" && (!allowMythic || mythicCount >= 1)) continue;
      const id = pickTraitFromBucket(bucket, rng, picked, allowMythic);
      if (!id) continue;
      picked.push(id);
      if (bucket === "rare") rareCount += 1;
      if (bucket === "mythic") {
        mythicCount += 1;
        draft.mythicTraitUsed = true;
      }
    }
    return picked;
  }

  function blendSkillBias(base, extra) {
    const out = Object.assign({}, base || {});
    Object.keys(extra || {}).forEach(function (k) {
      out[k] = (out[k] || 0) + extra[k];
    });
    return out;
  }

  const SKILL_PREVIEW_ORDER = [
    "travel",
    "hunting",
    "cooking",
    "repair",
    "doctoring",
    "woodcutting",
    "guard",
    "foraging",
    "craft",
  ];

  const SKILL_LABELS = {
    travel: "Travel",
    hunting: "Hunting",
    cooking: "Cooking",
    repair: "Repair",
    doctoring: "Doctoring",
    woodcutting: "Woodcutting",
    guard: "Guard",
    foraging: "Foraging",
    craft: "Craft",
  };

  function previewSkillsFromDraft(draft) {
    const baseSkills = {
      travel: 1,
      hunting: 1,
      cooking: 1,
      woodcutting: 1,
      doctoring: 1,
      repair: 1,
      guard: 1,
      craft: 1,
      foraging: 1,
    };
    const out = {};
    SKILL_PREVIEW_ORDER.forEach(function (key) {
      const bias = (draft && draft.skillBias && draft.skillBias[key]) || 0;
      out[key] = clamp((baseSkills[key] || 0) + bias, 0, 6);
    });
    return out;
  }

  function computeLeaderStartProfile(leaderDraft) {
    const draft = leaderDraft || {};
    const callingLabel =
      draft.backstoryLabel || draft.backstoryId || "Trail organizer";
    const callingOrigin = draft.origin || draft.backstorySummary || "";
    const prosperous = {
      river_trader: true,
      riverboat_gambler: true,
      fur_buyer: true,
    };
    const skilled = {
      millwright: true,
      wheelwright: true,
      blacksmith: true,
      barrel_maker: true,
      scribe_clerk: true,
      bookish_student: true,
      city_apprentice: true,
      stage_driver: true,
      apprentice_doc: true,
      frontier_midwife: true,
    };
    const lean = {
      prairie_farmer: true,
      wagon_cook: true,
      ranch_hand: true,
      mountain_trapper: true,
      buffalo_hunter: true,
      herb_gatherer: true,
      shore_fisher: true,
      comet_witness: true,
      graveyard_caretaker: true,
      army_teamster: true,
    };

    const id = draft.backstoryId;
    let startingMoney = 900;
    if (id && prosperous[id]) startingMoney = 1125;
    else if (id && skilled[id]) startingMoney = 950;
    else if (id && lean[id]) startingMoney = 820;

    const traits = draft.traits || [];
    if (traits.indexOf("frugal") >= 0) startingMoney += 75;
    if (traits.indexOf("wasteful") >= 0) startingMoney -= 60;

    startingMoney = clamp(startingMoney, 600, 1250);

    return {
      callingLabel: callingLabel,
      callingOrigin: callingOrigin,
      startingMoney: startingMoney,
    };
  }

  function generateDraftForSlot(slot) {
    const draft = ensurePartyDraftState();
    if (draft.locks[slot]) return draft.people[slot];
    const rng = draftRng(slot);
    const name = rollName(rng);
    const genderHint = deriveGenderHint(name);
    const backstory = pickBackstory(rng, { genderHint: genderHint });
    const traits = pickTraits(rng, 3, []);
    const skillBias = blendSkillBias(backstory.skillBias, traits.reduce(function (acc, tid) {
      const def = getTraitDef(tid);
      Object.keys((def && def.skillMods) || {}).forEach(function (k) {
        acc[k] = (acc[k] || 0) + def.skillMods[k];
      });
      return acc;
    }, {}));
    draft.people[slot] = {
      name: name,
      genderHint: genderHint,
      age: 18 + Math.floor(rng() * 28),
      origin: backstory.origin,
      backstoryId: backstory.id,
      backstoryLabel: backstory.label,
      backstorySummary: backstory.summary,
      traits: traits,
      hiddenTraits: gameState.mythicEnabled !== false && rng() < 0.18 ? ["mythic_mark"] : [],
      skillBias: skillBias,
    };
    return draft.people[slot];
  }

  function renderDraftInfo(slot) {
    const draft = ensurePartyDraftState().people[slot];
    const btns = dom.draftButtons && dom.draftButtons[slot];
    if (btns && btns.lockBtn) {
      btns.lockBtn.textContent = ensurePartyDraftState().locks[slot] ? "Locked" : "Lock";
    }
    if (btns && btns.rerollBtn) {
      btns.rerollBtn.disabled = !!ensurePartyDraftState().locks[slot];
    }
    if (!btns || !btns.info) return;
    if (!draft) {
      btns.info.textContent = "";
      return;
    }
    const skillsPreview = previewSkillsFromDraft(draft);
    const skillsLine = SKILL_PREVIEW_ORDER.map(function (key) {
      return `${SKILL_LABELS[key]} ${skillsPreview[key] || 0}`;
    }).join(" · ");
    btns.info.innerHTML =
      `<div>${draft.age} yrs · ${draft.origin}</div>` +
      `<div>${draft.backstoryLabel}</div>` +
      (draft.backstorySummary ? `<div class="ot-text-muted">${draft.backstorySummary}</div>` : "") +
      `<div class="ot-draft-tags">${(draft.traits || [])
        .map(function (t) {
          const def = getTraitDef(t);
          return `<span class="ot-draft-tag">${def ? def.label : t}</span>`;
        })
        .join("")}</div>` +
      `<div class="ot-draft-skills ot-text-muted">Skills — ${skillsLine}</div>`;

    if (slot === "leader") {
      renderLeaderStartPreview();
    }
  }

  function renderAllDraftInfo() {
    Object.keys(dom.draftButtons || {}).forEach(renderDraftInfo);
  }

  function applyDraftToInputs() {
    const draft = ensurePartyDraftState();
    if (!dom.leaderName || !dom.companionInputs) return;
    const leaderDraft = draft.people.leader;
    if (leaderDraft && !draft.locks.leader) {
      dom.leaderName.value = leaderDraft.name;
    }
    dom.companionInputs.forEach(function (input, idx) {
      const slot = "companion-" + idx;
      const d = draft.people[slot];
      if (input && d && !draft.locks[slot]) {
        input.value = d.name;
      }
    });
  }

  function rerollDraft(slot) {
    const draft = ensurePartyDraftState();
    draft.rerolls[slot] = (draft.rerolls[slot] || 0) + 1;
    generateDraftForSlot(slot);
    applyDraftToInputs();
    renderDraftInfo(slot);
  }

  function toggleDraftLock(slot) {
    const draft = ensurePartyDraftState();
    draft.locks[slot] = !draft.locks[slot];
    renderDraftInfo(slot);
  }

  function generateFullDraft() {
    ensurePartyDraftState();
    ["leader", "companion-0", "companion-1", "companion-2", "companion-3"].forEach(
      function (slot) {
        if (!ensurePartyDraftState().locks[slot]) rerollDraft(slot);
      }
    );
  }

  function buildDraftRows() {
    if (!dom.draftRows) return;
    dom.draftButtons = dom.draftButtons || {};
    dom.draftRows.innerHTML = "";
    dom.companionInputs = [];
    for (let i = 0; i < 4; i++) {
      const slot = "companion-" + i;
      const row = document.createElement("div");
      row.className = "ot-draft-row";
      row.dataset.slot = slot;
      const header = document.createElement("div");
      header.className = "ot-draft-header";
      header.textContent = "Companion " + (i + 1);
      const controls = document.createElement("div");
      controls.className = "ot-draft-controls";
      const lockBtn = document.createElement("button");
      lockBtn.className = "ot-mini-btn";
      lockBtn.textContent = "Lock";
      lockBtn.dataset.action = "lock";
      const rerollBtn = document.createElement("button");
      rerollBtn.className = "ot-mini-btn";
      rerollBtn.textContent = "Reroll";
      rerollBtn.dataset.action = "reroll";
      controls.appendChild(lockBtn);
      controls.appendChild(rerollBtn);
      header.appendChild(controls);
      row.appendChild(header);
      const input = document.createElement("input");
      input.id = "ot-companion-" + i;
      input.className = "ot-input";
      input.placeholder = "Companion " + (i + 1);
      row.appendChild(input);
      const info = document.createElement("div");
      info.id = "ot-draft-info-" + slot;
      info.className = "ot-draft-info";
      row.appendChild(info);
      dom.draftRows.appendChild(row);
      dom.companionInputs.push(input);
      dom.draftButtons[slot] = { lockBtn: lockBtn, rerollBtn: rerollBtn, info: info };
      lockBtn.addEventListener("click", function () {
        toggleDraftLock(slot);
      });
      rerollBtn.addEventListener("click", function () {
        rerollDraft(slot);
      });
    }
    const leaderRow = document.querySelector('.ot-draft-row[data-slot="leader"]');
    if (leaderRow) {
      const lockBtn = leaderRow.querySelector('[data-action="lock"]');
      const rerollBtn = leaderRow.querySelector('[data-action="reroll"]');
      dom.draftButtons.leader = {
        lockBtn: lockBtn,
        rerollBtn: rerollBtn,
        info: dom.draftInfo ? dom.draftInfo.leader : null,
      };
      if (lockBtn)
        lockBtn.addEventListener("click", function () {
          toggleDraftLock("leader");
        });
      if (rerollBtn)
        rerollBtn.addEventListener("click", function () {
          rerollDraft("leader");
        });
    }
  }

  function setRelationship(a, b, opinion, tags) {
    if (!a || !b) return;
    ensurePersonStoryFields(a);
    ensurePersonStoryFields(b);
    if (!a.relationships) a.relationships = {};
    if (!b.relationships) b.relationships = {};
    a.relationships[b.id] = {
      opinion: clamp(typeof opinion === "number" ? opinion : 0, -100, 100),
      tags: tags ? tags.slice() : [],
    };
    b.relationships[a.id] = {
      opinion: clamp(typeof opinion === "number" ? opinion : 0, -100, 100),
      tags: tags ? tags.slice() : [],
    };
  }

  function getRelationship(a, b) {
    if (!a || !b) return null;
    ensurePersonStoryFields(a);
    ensurePersonStoryFields(b);
    if (!a.relationships) a.relationships = {};
    if (!b.relationships) b.relationships = {};
    if (!a.relationships[b.id]) {
      a.relationships[b.id] = { opinion: 0, tags: [] };
    }
    if (!b.relationships[a.id]) {
      b.relationships[a.id] = { opinion: 0, tags: [] };
    }
    return a.relationships[b.id];
  }

  function adjustOpinion(a, b, delta, tag) {
    if (!a || !b || typeof delta !== "number") return;
    const relAB = getRelationship(a, b);
    const relBA = getRelationship(b, a);
    relAB.opinion = clamp((relAB.opinion || 0) + delta, -100, 100);
    relBA.opinion = clamp((relBA.opinion || 0) + delta * 0.8, -100, 100);
    if (tag && relAB.tags.indexOf(tag) < 0) relAB.tags.push(tag);
    if (tag && relBA.tags.indexOf(tag) < 0) relBA.tags.push(tag);
  }

  function getPairKey(a, b) {
    if (!a || !b) return "";
    return a.id < b.id ? a.id + ":" + b.id : b.id + ":" + a.id;
  }

  function pickRivalPair() {
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    let worst = null;
    let lowest = 5;
    people.forEach(function (a, idx) {
      for (let j = idx + 1; j < people.length; j++) {
        const b = people[j];
        const rel = a.relationships && a.relationships[b.id];
        const opinion = rel && typeof rel.opinion === "number" ? rel.opinion : 0;
        if (opinion < lowest) {
          lowest = opinion;
          worst = { a: a, b: b };
        }
      }
    });
    return worst;
  }

  function seedTraitsAndRelationships() {
    const people = getAllPeople();
    if (!people.length) return;
    const draft = ensurePartyDraftState();
    const rng = mulberry32(hashToInt(`${draft.seed || 1}-web`));
    people.forEach(function (p) {
      ensurePersonStoryFields(p);
      const idx = gameState.companions.indexOf(p);
      const slot = p.isLeader ? "leader" : idx >= 0 ? "companion-" + idx : null;
      const d = slot ? draft.people[slot] : null;
      if (d && d.traits && (!p.traits || !p.traits.length)) {
        p.traits = d.traits.slice();
      }
      applyTraitStats(p);
    });

    people.forEach(function (p) {
      if (p === gameState.leader) return;
      setRelationship(p, gameState.leader, 8 + Math.floor(rng() * 12), ["leader"]);
    });

    const companions = gameState.companions || [];
    if (companions.length >= 2 && rng() < 0.35) {
      const a = companions[0];
      const b = companions[1];
      setRelationship(a, b, 52 + Math.floor(rng() * 12), ["sibling"]);
    }

    let bestFriend = null;
    let friendScore = -99;
    let rival = null;
    let rivalScore = 99;
    people.forEach(function (a, idx) {
      for (let j = idx + 1; j < people.length; j++) {
        const b = people[j];
        const traitsA = a.traits || [];
        const traitsB = b.traits || [];
        let score = rng() * 2 - 1;
        if (traitsA.indexOf("cheerful") >= 0 || traitsB.indexOf("cheerful") >= 0) score += 1.5;
        if (traitsA.indexOf("argumentative") >= 0 || traitsB.indexOf("argumentative") >= 0) score -= 1.2;
        if (traitsA.indexOf("caretaker") >= 0 && traitsB.indexOf("camp_medic") >= 0) score += 1.2;
        if (Math.abs((a.age || 24) - (b.age || 24)) < 6) score += 0.4;
        if (score > friendScore) {
          friendScore = score;
          bestFriend = { a: a, b: b };
        }
        if (score < rivalScore) {
          rivalScore = score;
          rival = { a: a, b: b };
        }
      }
    });
    if (friendScore > 0.6 && bestFriend) {
      setRelationship(bestFriend.a, bestFriend.b, 35 + Math.floor(rng() * 25), ["friend"]);
    } else if (rival && rivalScore < -0.4) {
      setRelationship(rival.a, rival.b, -25 - Math.floor(rng() * 20), ["rival"]);
    }
  }

  function renderDepartureSeasonDesc() {
    if (!dom.departureSeasonDesc) return;
    const profileId = dom.departureSeason
      ? dom.departureSeason.value
      : "late_april";
    const profile = START_PROFILES[profileId] || START_PROFILES.late_april;
    dom.departureSeasonDesc.textContent = profile.summary;
  }

  function renderStorytellerOptions(selectEl, selectedId) {
    if (!selectEl) return;
    selectEl.innerHTML = "";
    Object.keys(STORYTELLER_PRESETS).forEach(function (key) {
      const preset = STORYTELLER_PRESETS[key];
      const opt = document.createElement("option");
      opt.value = preset.id;
      opt.textContent =
        preset.label + " – " + (preset.hint || "Narrator mood");
      if (preset.hint) opt.title = preset.hint;
      if (preset.id === selectedId) opt.selected = true;
      selectEl.appendChild(opt);
    });
    renderStorytellerCards(selectedId || (selectEl && selectEl.value));
  }

  function setStorytellerPreset(presetId, opts) {
    const preset = STORYTELLER_PRESETS[presetId] || STORYTELLER_PRESETS.classic;
    const ss = ensureStoryState();
    gameState.storytellerPresetId = preset.id;
    ss.presetId = preset.id;
    ss.lastPresetSwapDayKey = ss.lastPresetSwapDayKey || getWeekKey(gameState.date || new Date());
    if (opts && opts.resetTimers) {
      ss.hoursSinceMajorEvent = Math.min(
        ss.hoursSinceMajorEvent || 0,
        preset.minHoursBetweenMajor || 0
      );
      ss.hoursSinceMinorEvent = Math.min(
        ss.hoursSinceMinorEvent || 0,
        preset.minHoursBetweenMinor || 0
      );
    } else {
      ss.hoursSinceMajorEvent = Math.max(
        ss.hoursSinceMajorEvent || 0,
        Math.floor((preset.minHoursBetweenMajor || 0) / 2)
      );
      ss.hoursSinceMinorEvent = Math.max(
        ss.hoursSinceMinorEvent || 0,
        Math.floor((preset.minHoursBetweenMinor || 0) / 2)
      );
    }
    return preset;
  }

  function ensurePresetSwapWeek() {
    const ss = ensureStoryState();
    const wk = getWeekKey(gameState.date || new Date());
    if (ss.lastPresetSwapDayKey !== wk) {
      ss.presetSwapsThisWeek = 0;
      ss.lastPresetSwapDayKey = wk;
    }
  }

  function canSwapStorytellerPreset(targetId) {
    ensurePresetSwapWeek();
    const ss = ensureStoryState();
    const started = (gameState.milesTraveled || 0) > 0 && gameState.phase !== "start";
    if (!started) {
      return { ok: true, reason: "Free to choose before departure." };
    }
    if (gameState.mode !== "camp") {
      return { ok: false, reason: "You can only change narrator while camped." };
    }
    const limit = 2;
    if (ss.presetSwapsThisWeek >= limit) {
      return { ok: false, reason: "You've already changed narrators twice this week." };
    }
    return { ok: true, reason: "Narrator shift allowed." };
  }

  function noteStorytellerSwap() {
    ensurePresetSwapWeek();
    const ss = ensureStoryState();
    ss.presetSwapsTotal = (ss.presetSwapsTotal || 0) + 1;
    ss.presetSwapsThisWeek = (ss.presetSwapsThisWeek || 0) + 1;
    ss.lastPresetSwapDayKey = getWeekKey(gameState.date || new Date());
  }

  function storytellerIcon(key) {
    switch (key) {
      case "quill":
        return "✒";
      case "skull":
        return "☠";
      case "storm":
        return "✶";
      case "balanced":
        return "⚖";
      default:
        return "⇢";
    }
  }

  function renderNarratorRules() {
    if (!dom.narratorRules) return;
    const ss = ensureStoryState();
    ensurePresetSwapWeek();
    const limit = 2;
    if ((gameState.milesTraveled || 0) <= 0 || gameState.phase === "start") {
      dom.narratorRules.textContent = "Free to pick any narrator before departure.";
      return;
    }
    dom.narratorRules.textContent =
      "Swaps this week: " + (ss.presetSwapsThisWeek || 0) + "/" + limit + " (camp only)";
  }

  function renderStorytellerCards(selectedId) {
    if (!dom.storytellerCards) return;
    dom.storytellerCards.innerHTML = "";
    const exampleFor = function (preset) {
      if (preset.examples && preset.examples.length) return preset.examples[0];
      return preset.exampleStory || preset.description || preset.hint || "";
    };
    const pacingLine = function (preset) {
      if (preset.pacingSummary) return preset.pacingSummary;
      if (preset.regionCurves) {
        const keys = ["plains", "mountains", "columbia"].filter(function (k) {
          return preset.regionCurves[k];
        });
        if (keys.length) {
          return keys
            .map(function (k) {
              return (preset.regionCurves[k].label || k) + "";
            })
            .join(" · ");
        }
      }
      return "Early calm, sharper late miles.";
    };
    Object.keys(STORYTELLER_PRESETS).forEach(function (key) {
      const preset = STORYTELLER_PRESETS[key];
      const card = document.createElement("div");
      card.className = "ot-preset-card";
      card.dataset.presetId = preset.id;
      if (preset.iconKey) card.dataset.iconKey = preset.iconKey;
      card.setAttribute("tabindex", "0");
      card.setAttribute("role", "button");
      if (preset.id === selectedId) card.classList.add("ot-selected");
      const icon = document.createElement("div");
      icon.className = "ot-preset-icon";
      if (preset.iconKey) icon.classList.add("ot-preset-icon--" + preset.iconKey);
      icon.textContent = storytellerIcon(preset.iconKey);
      if (preset.iconClass) icon.classList.add(preset.iconClass);

      const body = document.createElement("div");
      const title = document.createElement("div");
      title.style.fontWeight = "bold";
      title.textContent = preset.label;
      const tagline = document.createElement("div");
      tagline.className = "ot-preset-tagline";
      tagline.textContent = preset.tagline || preset.hint || "";
      const hint = document.createElement("div");
      hint.className = "ot-panel-body-sm ot-preset-meta";
      hint.textContent = preset.personality || preset.description || preset.hint || "";
      const pacing = document.createElement("div");
      pacing.className = "ot-preset-pacing";
      pacing.textContent = pacingLine(preset);

      body.appendChild(title);
      body.appendChild(tagline);
      body.appendChild(hint);
      body.appendChild(pacing);

      card.appendChild(icon);
      card.appendChild(body);
      const detail = document.createElement("div");
      detail.className = "ot-preset-detail";
      const detailTitle = document.createElement("div");
      detailTitle.className = "ot-preset-detail-title";
      detailTitle.textContent = "Story tone";
      const detailList = document.createElement("ul");
      (preset.examples || []).slice(0, 2).forEach(function (ex) {
        const li = document.createElement("li");
        li.textContent = ex;
        detailList.appendChild(li);
      });
      if (preset.hint || preset.personality) {
        const li = document.createElement("li");
        li.textContent = preset.hint || preset.personality;
        detailList.appendChild(li);
      }
      detail.appendChild(detailTitle);
      detail.appendChild(detailList);
      card.appendChild(detail);

      const showExample = function () {
        if (dom.storytellerExample) {
          dom.storytellerExample.textContent = exampleFor(preset);
        }
      };
      card.addEventListener("mouseenter", showExample);
      card.addEventListener("focus", showExample);
      card.addEventListener("click", function (ev) {
        const isMobile = window.matchMedia && window.matchMedia("(max-width: 760px)").matches;
        const alreadySelected = preset.id === selectedId;
        if (isMobile && alreadySelected && !card.classList.contains("ot-show-detail")) {
          card.classList.add("ot-show-detail");
          return;
        }
        const swapCheck = canSwapStorytellerPreset(preset.id);
        if (!swapCheck.ok) {
          if (dom.narratorHint) dom.narratorHint.textContent = swapCheck.reason;
          return;
        }
        setStorytellerPreset(preset.id, { resetTimers: true });
        if ((gameState.milesTraveled || 0) > 0) {
          noteStorytellerSwap();
        }
        if (dom.storytellerPreset) dom.storytellerPreset.value = preset.id;
        renderStorytellerDescription(preset.id);
        renderStorytellerOptions(dom.storytellerMidrun, preset.id);
        renderStorytellerCards(preset.id);
        renderNarratorRules();
        saveGame();
      });
      dom.storytellerCards.appendChild(card);
    });
    const active = STORYTELLER_PRESETS[selectedId] || STORYTELLER_PRESETS.classic;
    if (dom.storytellerExample) dom.storytellerExample.textContent = exampleFor(active);
  }

  function renderStorytellerDescription(presetId) {
    const preset = STORYTELLER_PRESETS[presetId] || STORYTELLER_PRESETS.classic;
    if (dom.storytellerDesc) {
      dom.storytellerDesc.textContent = preset.description || "";
    }
    if (dom.narratorLabel) {
      dom.narratorLabel.textContent = "Narrator: " + preset.label;
      dom.narratorLabel.title = preset.tagline || preset.description || "";
    }
    if (dom.narratorHint) {
      const pacing = preset.pacingSummary ? " · " + preset.pacingSummary : "";
      dom.narratorHint.textContent = (preset.tagline || preset.description || "") + pacing;
    }
    if (dom.storytellerExample) {
      dom.storytellerExample.textContent =
        (preset.examples && preset.examples.length
          ? preset.examples[0]
          : preset.exampleStory) || preset.description || "";
    }
    renderNarratorRules();
  }

  function rollStartingCarryIns(draftState, chosenDrafts) {
    const freeSupplies = {};
    const noteLines = [];
    const pool = [
      { id: "ammo", baseWeight: 3, qty: 1, tags: ["hunter", "guard"] },
      { id: "med_kits", baseWeight: 3, qty: 1, tags: ["doctor"] },
      { id: "coffee", baseWeight: 2, qty: 2, tags: ["cook", "traveler"] },
      { id: "firewood", baseWeight: 1.5, qty: 1, tags: ["craft", "wood"] },
      { id: "dried_fruit", baseWeight: 2, qty: 3, tags: ["forager"] },
      { id: "salt_soda", baseWeight: 2, qty: 2, tags: ["cook", "craft"] },
    ];

    function callingTags(draft) {
      const tags = [];
      const id = draft && draft.backstoryId;
      if (!id) return tags;
      if (
        ["buffalo_hunter", "mountain_trapper", "ranch_hand", "border_ranger"].indexOf(
          id
        ) >= 0
      ) {
        tags.push("hunter");
      }
      if (["apprentice_doc", "frontier_midwife"].indexOf(id) >= 0) {
        tags.push("doctor");
      }
      if (["wagon_cook", "kitchen_servant"].indexOf(id) >= 0) {
        tags.push("cook");
      }
      if (
        [
          "millwright",
          "wheelwright",
          "blacksmith",
          "barrel_maker",
        ].indexOf(id) >= 0
      ) {
        tags.push("craft");
        tags.push("wood");
      }
      if (["herb_gatherer", "shore_fisher", "fur_buyer"].indexOf(id) >= 0) {
        tags.push("forager");
      }
      if (["river_trader", "riverboat_gambler", "wagon_scout"].indexOf(id) >= 0) {
        tags.push("traveler");
      }
      return tags;
    }

    function pickCarryItem(rng, tags) {
      const weighted = pool.map(function (p) {
        let weight = p.baseWeight;
        (p.tags || []).forEach(function (tag) {
          if (tags.indexOf(tag) >= 0) weight += 1.5;
        });
        return { def: p, weight: weight };
      });
      const total = weighted.reduce(function (sum, w) {
        return sum + (w.weight || 0);
      }, 0);
      let pick = rng() * total;
      let choice = null;
      weighted.forEach(function (w) {
        if (pick <= (w.weight || 0) && !choice) choice = w;
        pick -= w.weight || 0;
      });
      if (!choice && weighted.length) choice = weighted[weighted.length - 1];
      return choice ? choice.def : null;
    }

    (chosenDrafts || []).forEach(function (entry) {
      if (!entry || !entry.slot) return;
      const rng = draftRng(entry.slot);
      const draft = entry.draft || {};
      if (rng() >= 0.11) return;
      const tags = callingTags(draft);
      const item = pickCarryItem(rng, tags);
      if (!item || !item.id) return;
      const qty = item.qty || 1;
      freeSupplies[item.id] = (freeSupplies[item.id] || 0) + qty;
      const def = findSupplyDef(item.id);
      const label = def ? def.name.toLowerCase() : item.id;
      const who = draft.name || (entry.slot === "leader" ? "Leader" : "Companion");
      noteLines.push(`${who} carried in +${qty} ${label}.`);
    });

    return { freeSupplies: freeSupplies, noteLines: noteLines };
  }

  function startNewGameFromForm() {
    const draftState = ensurePartyDraftState();

    const leaderName = dom.leaderName.value.trim() || "Unnamed leader";
    const leaderDraft = draftState.people.leader;
    const leaderProfile = computeLeaderStartProfile(leaderDraft);
    const leaderBias = blendSkillBias({}, leaderDraft && leaderDraft.skillBias);
    const leader = createPerson(leaderName, true, leaderBias, leaderDraft);

    const companions = [];
    const chosenDrafts = [{ slot: "leader", draft: leaderDraft }];
    dom.companionInputs.forEach(function (input, idx) {
      const v = input.value.trim();
      if (v) {
        const slot = "companion-" + idx;
        const d = draftState.people[slot];
        const bias = d ? blendSkillBias({}, d.skillBias) : null;
        companions.push(createPerson(v, false, bias, d));
        chosenDrafts.push({ slot: slot, draft: d });
      }
    });
    if (companions.length === 0) {
      const fallback = draftState.people["companion-0"] || generateDraftForSlot("companion-0");
      companions.push(
        createPerson(
          fallback && fallback.name ? fallback.name : "Unnamed companion",
          false,
          fallback ? blendSkillBias({}, fallback.skillBias) : null,
          fallback
        )
      );
      chosenDrafts.push({ slot: "companion-0", draft: fallback });
    }

    gameState.leader = leader;
    gameState.companions = companions;
    gameState.selectedIndex = 0;

    gameState.leader.task = "travel";
    gameState.companions.forEach(function (c) {
      c.task = "auto";
    });

    seedTraitsAndRelationships();

    const presetId = dom.storytellerPreset
      ? dom.storytellerPreset.value
      : "classic";
    gameState.storytellerPresetId = presetId;
    gameState.mythicEnabled = !dom.mythicToggle || dom.mythicToggle.value !== "off";
    ensureStoryState().mythicEnabled = gameState.mythicEnabled;

    gameState.startingPoint = dom.departureSelect
      ? dom.departureSelect.value
      : gameState.startingPoint || "independence";

    gameState.startingMoney = leaderProfile.startingMoney;
    gameState.money = leaderProfile.startingMoney;
    gameState.startingFreeSupplies = {};
    gameState.startingFreeSuppliesNotes = [];
    resetSupplies();

    const carry = rollStartingCarryIns(draftState, chosenDrafts);
    if (carry && carry.freeSupplies) {
      gameState.startingFreeSupplies = carry.freeSupplies;
      Object.keys(carry.freeSupplies).forEach(function (id) {
        gameState.supplies[id] =
          (gameState.supplies[id] || 0) + (carry.freeSupplies[id] || 0);
      });
    }
    if (carry && carry.noteLines) {
      gameState.startingFreeSuppliesNotes = carry.noteLines;
    }

    gameState.date = pickStartDateFromSeason();
    const partyKey =
      (leaderName + "-" + dom.departureSelect.value + "-" + gameState.startProfileId)
        .replace(/\s+/g, "-")
        .toLowerCase();
    gameState.partyId = partyKey;
    gameState.weatherSeed = hashToInt(partyKey + "-" + gameState.date.getFullYear());
    initWeatherSystem(gameState.date.getFullYear(), partyKey);
    gameState.weatherHistory = [];
    gameState.milesTraveled = 0;
    gameState.pace = "steady";
    gameState.rations = "filling";
    gameState.mode = "camp";
    gameState.wagonCondition = 100;
    gameState.guardLevel = 0;
    gameState.log = [];
    gameState.recentRainHours = 0;
    gameState.mapListVisible = false;
    gameState.mapOpen = false;
    gameState.travelView = "journal";
    gameState.traillines = defaultTraillinesState();
    gameState.explorer = { x: 6, y: 20, hourBuffer: 0, initializedFromProgress: true };
    rebuildActiveRoutePath();
    recenterCameraOnPlayer();

    updateRegionAndLocation();
    refreshWeather();
    addLog(
      "You make camp near the Missouri River and begin preparing your wagon."
    );

    dom.leaderPill.textContent =
      "Leader — " +
      leader.name +
      (leader.backstoryLabel ? " · " + leader.backstoryLabel : "");

    updateStartArt();
    buildOutfitTable();
    updateOutfitSummary();
    updateOutfitIntro();
    updateOutfitArt();

    ensureDelegationState();
    showScreen("outfit");
    saveGame();
    renderAll();
  }

  /* ========= REGION, WEATHER, LOG ========================================= */

  function regionToWeatherRegion(region) {
    switch (region) {
      case "plains":
      case "central_plains":
        return "GreatPlains";
      case "high_plains":
        return "HighPlains";
      case "mountains":
        return "Rockies";
      case "great_basin":
        return "SnakePlain";
      case "snake_plain":
        return "SnakePlain";
      case "blue_mountains":
        return "Rockies";
      case "columbia":
      case "willamette":
        return "Columbia";
      default:
        return "GreatPlains";
    }
  }

  function initWeatherSystem(year, partyId) {
    const baseSeed =
      gameState.weatherSeed || hashToInt(`${year || 1848}-${partyId || "party"}`);
    gameState.weatherSeed = baseSeed;
    gameState.weatherSystem = {
      seed: baseSeed,
      rng: mulberry32(baseSeed),
      noise: makeNoise3D(baseSeed),
    };
    if (!Array.isArray(gameState.weatherHistory)) {
      gameState.weatherHistory = [];
    }
  }

  function ensureWeatherRuntime() {
    if (!gameState.weatherSystem || !gameState.weatherSystem.seed) {
      const year = gameState.date ? gameState.date.getFullYear() : 1848;
      initWeatherSystem(year, gameState.partyId || "party");
    }
    if (!gameState.weatherSystem.rng) {
      const seed = gameState.weatherSystem.seed || gameState.weatherSeed || 1;
      gameState.weatherSystem.rng = mulberry32(seed);
    }
    if (!gameState.weatherSystem.noise) {
      const seed = gameState.weatherSystem.seed || gameState.weatherSeed || 1;
      gameState.weatherSystem.noise = makeNoise3D(seed);
    }
  }

  function getClimateBaseline(regionKey, monthName) {
    const monthly = CLIMATE[regionKey] && CLIMATE[regionKey].monthly;
    if (monthly && monthly[monthName]) return monthly[monthName];
    if (monthly) {
      const first = Object.keys(monthly)[0];
      if (first) return monthly[first];
    }
    return { pRain: 0.2, pStorm: 0.08, tMin: 4, tMax: 20, windKph: [8, 22] };
  }


  function updateWeatherHistory(weather) {
    if (!Array.isArray(gameState.weatherHistory)) {
      gameState.weatherHistory = [];
    }
    gameState.weatherHistory.push({
      ...weather,
      loggedAt: new Date(gameState.date.getTime()),
    });
    const maxLen = 48;
    if (gameState.weatherHistory.length > maxLen) {
      gameState.weatherHistory.splice(0, gameState.weatherHistory.length - maxLen);
    }
  }

  function getWeather(state) {
    ensureWeatherRuntime();
    const ws = gameState.weatherSystem || {};
    const noise3 = ws.noise || ((x, y, t) => 0);
    const rng = ws.rng || Math.random;
    const climate = getClimateBaseline(state.region, state.month);
    const tScale = (state.dayOfYear + state.hour / 24) * 0.05;
    const sx = (state.x || 0) * 0.005;
    const sy = (state.y || 0) * 0.003;

    const profile =
      gameState.startProfile || START_PROFILES[gameState.startProfileId];

    const tempNoise = noise3(sx, sy, tScale);
    const diurnal = Math.cos(((state.hour - 15) / 24) * 2 * Math.PI) * 5.2;
    let tempC =
      lerp(climate.tMin, climate.tMax, 0.5 + 0.35 * tempNoise) + diurnal;
    tempC -= 0.006 * (state.altitude || 0);
    if (profile) {
      if (profile.heatHazard === "high") tempC += 2.2;
      else if (profile.heatHazard === "low") tempC -= 1.2;
      if (profile.riverHazard === "high" && state.month === "April") {
        tempC -= 0.8;
      }
    }

    const cloudBase = noise3(sx + 12, sy - 5, tScale * 0.7);
    const frontDrift = noise3(sx + state.dayOfYear * 0.02, sy, tScale * 0.35);
    const clouds = clamp(0.55 + 0.35 * cloudBase + 0.15 * frontDrift, 0, 1);

    let pRain =
      climate.pRain * (0.6 + 0.8 * clouds) * (0.75 + 0.5 * frontDrift);
    let pStorm = climate.pStorm * (0.55 + 0.8 * Math.max(frontDrift, 0));

    if (profile) {
      if (
        profile.riverHazard === "high" &&
        (state.month === "April" || state.month === "May")
      ) {
        pRain *= 1.1;
      }
      if (
        profile.heatHazard === "high" &&
        (state.month === "July" || state.month === "August")
      ) {
        tempC += 1.2;
        pRain *= 0.9;
        pStorm *= 1.15;
      }
    }

    pRain = clamp(pRain, 0, 0.95);
    pStorm = clamp(pStorm, 0, 0.65);

    const precipHit = rng() < pRain;
    const stormHit = precipHit && rng() < pStorm;
    let precip = "none";
    if (precipHit) {
      const isSnow = tempC <= 1 || (state.altitude || 0) >= 1900;
      precip = isSnow ? "snow" : "rain";
    }

    const windSample = noise3(sx + 5, sy - 7, tScale * 1.3);
    let windKph = lerp(
      climate.windKph[0],
      climate.windKph[1],
      0.5 + 0.35 * windSample
    );
    if (stormHit) windKph += 6;

    return {
      tempC: Math.round(tempC * 10) / 10,
      windKph: Math.round(windKph),
      clouds: clouds,
      precip: precip,
      storm: !!stormHit,
    };
  }

  function applyWeatherToParty(party, weather, history) {
    // TODO: Hook future survival effects here (speed, illness, morale, river depth).
    if (!weather) return;
    const recent = history && history[history.length - 1];
    if (!recent) return;
    if (weather.storm && Math.random() < 0.05) {
      addLog("Storm gusts batter the wagon covers and everyone hunches against the rain.");
    }
    if (weather.tempC >= 32 && Math.random() < 0.04) {
      addLog("The heat and dust leave the oxen lathered and thirsty.");
    }
    if (weather.tempC <= -5 && Math.random() < 0.03) {
      addLog("Biting cold makes the party huddle close to share warmth.");
    }
  }

  function refreshWeather() {
    ensureWeatherRuntime();
    const d = gameState.date;
    const doy = getDayOfYear(d);
    const hour = d.getHours() + d.getMinutes() / 60;
    const weatherRegion = regionToWeatherRegion(gameState.region || "plains");
    const altitude = regionAltitude(gameState.region || weatherRegion);
    const monthName = getMonthName(d) || "April";

    const weather = getWeather({
      x: gameState.milesTraveled || 0,
      y: altitude || 0,
      dayOfYear: doy,
      hour: hour,
      region: weatherRegion,
      month: monthName,
      altitude: altitude,
    });

    if (!gameState.recentRainHours) gameState.recentRainHours = 0;
    if (weather.precip === "rain" || weather.precip === "snow") {
      gameState.recentRainHours = Math.min(72, gameState.recentRainHours + 1);
    } else {
      gameState.recentRainHours = Math.max(0, gameState.recentRainHours - 0.5);
    }

    gameState.weatherState = weather;
    gameState.weather = describeWeatherLabel(
      weather.tempC,
      weather.precip,
      weather.storm,
      weather.clouds
    );

    const daysSinceStart =
      gameState.startDayOfYear != null
        ? Math.max(0, doy - gameState.startDayOfYear)
        : 0;
    const plainsPhase =
      gameState.region === "plains" || gameState.region === "central_plains";
    const profile =
      gameState.startProfile || START_PROFILES[gameState.startProfileId];
    gameState.highRiverRisk =
      profile && profile.riverHazard === "high" && plainsPhase && daysSinceStart < 45;

    updateWeatherHistory(weather);
    applyWeatherToParty(getAllPeople(), weather, gameState.weatherHistory);
  }

  function updateRegionAndLocation() {
    const miles = gameState.milesTraveled;
    const milestones = getActiveRouteMilestones();
    let last =
      (milestones.length && milestones[0]) ||
      { name: "On the trail", region: gameState.region || "plains", mile: 0 };
    milestones.forEach(function (m) {
      if (m && typeof m.mile === "number" && miles >= m.mile) {
        last = m;
      }
    });
    gameState.locationName = last.name;
    gameState.region = last.region;
  }

  function addLog(text, meta) {
    const opts = meta || {};
    if (typeof gameState.logVerbosityThreshold !== "number") {
      gameState.logVerbosityThreshold = 1;
    }
    const importance = opts.importance == null ? 1 : opts.importance;
    if (importance >= (gameState.logVerbosityThreshold || 1)) {
      const entry = {
        date: new Date(gameState.date.getTime()),
        text: text,
        tone: opts.tone,
        tag: opts.tag,
        location: opts.location,
        characters: opts.characters || [],
        importance: importance,
      };
      gameState.log.push(entry);
      if (gameState.log.length > 120) {
        gameState.log.splice(0, gameState.log.length - 120);
      }
    }

    if (window.ksOldTrailLog && ksOldTrailLog.add) {
      const dayTag =
        gameState.startDayOfYear != null
          ? Math.max(1, getDayOfYear(gameState.date) - gameState.startDayOfYear + 1)
          : getDayOfYear(gameState.date);
      ksOldTrailLog.add(text, {
        tag: opts.tag || "DAY " + dayTag,
        location: opts.location || gameState.locationName || "On the trail",
        tone: opts.tone,
        day: dayTag,
        characters: opts.characters,
      });
    }
  }

  function ensureReputationState() {
    if (typeof gameState.reputation !== "number") gameState.reputation = 0;
    if (!gameState.reputationFlags || typeof gameState.reputationFlags !== "object") {
      gameState.reputationFlags = {};
    }
    const ss = ensureStoryState();
    if (!ss.factionRep) ss.factionRep = { caravans: 0, forts: 0, open_eye: 0, men_in_gray: 0 };
    if (typeof ss.factionRep.caravans !== "number") ss.factionRep.caravans = 0;
    if (typeof ss.factionRep.forts !== "number") ss.factionRep.forts = 0;
    if (typeof ss.factionRep.open_eye !== "number") ss.factionRep.open_eye = 0;
    if (typeof ss.factionRep.men_in_gray !== "number") ss.factionRep.men_in_gray = 0;
  }

  function adjustFactionRep(factionId, delta, reason, ctx) {
    const ss = ensureStoryState();
    if (!ss.factionRep) ss.factionRep = { caravans: 0, forts: 0, open_eye: 0, men_in_gray: 0 };
    if (typeof ss.factionRep[factionId] !== "number") ss.factionRep[factionId] = 0;
    ss.factionRep[factionId] = clamp(ss.factionRep[factionId] + delta, -100, 100);
    const currentHour = getCurrentTrailHour(gameState);
    const entry = {
      hour: currentHour,
      dayKey: getDayKey(gameState.date),
      factionId: factionId,
      delta: delta,
      value: ss.factionRep[factionId],
      location: (ctx && ctx.location) || gameState.locationName || "",
    };
    ss.factionRepLog.push(entry);
    if (ss.factionRepLog.length > 40) {
      ss.factionRepLog.splice(0, ss.factionRepLog.length - 40);
    }
    ss.factionRepLast[factionId] = {
      hour: currentHour,
      delta: delta,
      value: ss.factionRep[factionId],
    };
    if (reason) {
      addLog(reason, { tone: delta >= 0 ? "event" : "warning", location: ctx && ctx.location });
    }
    return ss.factionRep[factionId];
  }

  function getHoursSinceRepChange(factionId) {
    const ss = ensureStoryState();
    if (!ss.factionRepLast || !ss.factionRepLast[factionId]) return Infinity;
    const last = ss.factionRepLast[factionId];
    return getCurrentTrailHour(gameState) - (last.hour || 0);
  }

  function coerceDate(val) {
    if (val instanceof Date) return val;
    if (typeof val === "string" || typeof val === "number") {
      const d = new Date(val);
      if (!isNaN(d)) return d;
    }
    return null;
  }

  function hoursSinceDate(val) {
    const baseDate = coerceDate(gameState && gameState.date);
    const other = coerceDate(val);
    if (!baseDate || !other) return Infinity;
    return (baseDate.getTime() - other.getTime()) / 3600000;
  }

  function getFactionRepTier(factionId) {
    const ss = ensureStoryState();
    const val = clamp((ss.factionRep && ss.factionRep[factionId]) || 0, -100, 100);
    if (val >= 50) return { id: "ally", label: "Ally", value: val };
    if (val >= 15) return { id: "trusted", label: "Trusted", value: val };
    if (val > -15) return { id: "neutral", label: "Neutral", value: val };
    if (val > -45) return { id: "wary", label: "Wary", value: val };
    return { id: "hostile", label: "Hostile", value: val };
  }

  function getTradeTermsForFaction(factionId) {
    const tier = getFactionRepTier(factionId);
    let costMult = 1;
    let gainMult = 1;
    if (tier.id === "ally") {
      costMult = 0.85;
      gainMult = 1.15;
    } else if (tier.id === "trusted") {
      costMult = 0.92;
      gainMult = 1.08;
    } else if (tier.id === "neutral") {
      costMult = 1;
      gainMult = 1;
    } else if (tier.id === "wary") {
      costMult = 1.08;
      gainMult = 0.92;
    } else {
      costMult = 1.18;
      gainMult = 0.82;
    }
    return { costMult: costMult, gainMult: gainMult, label: tier.label, tier: tier };
  }

  function getFortTradeTerms() {
    const terms = getTradeTermsForFaction("forts");
    const tier = getFactionRepTier("forts");
    return { terms: terms, tier: tier };
  }

  const DEFAULT_FORT_TRADE_DEF = {
    label: "Frontier sutler",
    catalog: [
      "flour",
      "bacon",
      "beans_rice",
      "hardtack",
      "dried_fruit",
      "coffee",
      "sugar",
      "salt_soda",
      "water_barrels",
      "firewood",
      "buffalo_chips",
      "oxen",
      "wheels",
      "axles",
      "tongues",
      "ammo",
      "rifles",
      "med_kits",
    ],
    baseStock: {
      flour: 360,
      bacon: 120,
      beans_rice: 110,
      hardtack: 90,
      dried_fruit: 55,
      coffee: 22,
      sugar: 42,
      salt_soda: 18,
      water_barrels: 4,
      firewood: 28,
      buffalo_chips: 18,
      oxen: 6,
      wheels: 5,
      axles: 4,
      tongues: 3,
      ammo: 240,
      rifles: 4,
      med_kits: 10,
    },
    stockCap: {
      flour: 500,
      bacon: 160,
      beans_rice: 150,
      hardtack: 130,
      dried_fruit: 80,
      coffee: 32,
      sugar: 60,
      salt_soda: 26,
      water_barrels: 6,
      firewood: 40,
      buffalo_chips: 26,
      oxen: 9,
      wheels: 7,
      axles: 6,
      tongues: 5,
      ammo: 340,
      rifles: 6,
      med_kits: 14,
    },
    restockPerDay: {
      flour: 20,
      bacon: 8,
      beans_rice: 7,
      hardtack: 6,
      dried_fruit: 4,
      coffee: 2,
      sugar: 3,
      salt_soda: 1,
      water_barrels: 0.6,
      firewood: 5,
      buffalo_chips: 4,
      oxen: 0.25,
      wheels: 0.4,
      axles: 0.35,
      tongues: 0.2,
      ammo: 14,
      rifles: 0.15,
      med_kits: 0.6,
    },
    flavorNotes: ["Army trains pass through; sutlers mind their ledgers.", "Pay fair, mind the scales, and they keep the gate open."],
  };

  const FORT_POLICY_DEFS = {
    army_tariff: {
      label: "Army tariff ledger",
      desc: "Garrison clerks add duty to keep the barracks fed and the books balanced.",
      buyTariffPct: 0.12,
      sellTariffPct: 0.06,
      notes: [
        "Army stamp shines beside the prices; duty is tallied before ink dries.",
        "Officer eyes the column for rifles twice before nodding you on.",
      ],
      rivals: ["fort_bridger_wy"],
    },
    free_traders: {
      label: "Free-trader slips",
      desc: "Locals favor open purses and quick deals; tariffs stay light if ink stays neat.",
      buyTariffPct: 0.04,
      sellTariffPct: 0.02,
      notes: ["Loose tariffs keep wagons rolling; clerks skip a stamp for regular faces."],
      rivals: ["fort_kearny_ne"],
    },
    company_counter: {
      label: "Company counter",
      desc: "Company brokers skim a quiet cut while keeping rivals guessing at their books.",
      buyTariffPct: 0.09,
      sellTariffPct: 0.04,
      notes: ["Company tallymen weigh every barrel twice before quoting a figure."],
      rivals: ["fort_bridger_wy"],
    },
  };

  const FORT_TRADE_DEFS = {
    caravan_peddler: {
      label: "Ledger of a passing caravan",
      catalog: [
        "flour",
        "bacon",
        "beans_rice",
        "hardtack",
        "dried_fruit",
        "coffee",
        "sugar",
        "salt_soda",
        "firewood",
        "water_barrels",
        "ammo",
        "rifles",
        "med_kits",
      ],
      baseStock: {
        flour: 80,
        bacon: 26,
        beans_rice: 40,
        hardtack: 36,
        dried_fruit: 18,
        coffee: 12,
        sugar: 14,
        salt_soda: 10,
        firewood: 22,
        water_barrels: 4,
        ammo: 70,
        rifles: 2,
        med_kits: 6,
      },
      stockCap: {
        flour: 120,
        bacon: 40,
        beans_rice: 60,
        hardtack: 54,
        dried_fruit: 28,
        coffee: 20,
        sugar: 22,
        salt_soda: 15,
        firewood: 32,
        water_barrels: 6,
        ammo: 110,
        rifles: 3,
        med_kits: 9,
      },
      restockPerDay: {
        flour: 6,
        bacon: 2.2,
        beans_rice: 3.4,
        hardtack: 3,
        dried_fruit: 1.2,
        coffee: 1,
        sugar: 1,
        salt_soda: 0.6,
        firewood: 3,
        water_barrels: 0.35,
        ammo: 6,
        rifles: 0.08,
        med_kits: 0.25,
      },
      flavorNotes: [
        "Canvas ledger smells of dust and cardamom; pages flutter with each gust.",
        "Freighter boys tally bacon twice—once for freight, once for camp kitchens.",
        "Ruts deep as graves near the last crossing; flour shook loose in half the sacks.",
        "Night watch keeps rifles hidden until trust is earned.",
        "Coffee tins are banded with twine and road grit—ask gentle.",
      ],
    },
    open_eye_peddler: {
      label: "Inked-eye satchel",
      catalog: ["tea", "coffee", "dried_fruit", "salt_soda", "med_kits", "buffalo_chips", "ammo"],
      baseStock: { tea: 14, coffee: 8, dried_fruit: 12, salt_soda: 6, med_kits: 4, buffalo_chips: 18, ammo: 24 },
      stockCap: { tea: 22, coffee: 14, dried_fruit: 18, salt_soda: 10, med_kits: 6, buffalo_chips: 28, ammo: 36 },
      restockPerDay: { tea: 1.2, coffee: 0.8, dried_fruit: 0.8, salt_soda: 0.5, med_kits: 0.24, buffalo_chips: 1.4, ammo: 1.4 },
      flavorNotes: [
        "Steeped leaves sold with a blessing, wrapped in blue cloth.",
        "Charcoal marks an open eye on the ledger's cover, watched closely as coins change hands.",
        "They trade stories for salt-soda, listening more than they speak.",
        "Powder tins rattle softly under dried sprigs of sage.",
      ],
    },
    men_in_gray_ledger: {
      label: "Quiet Ledger",
      catalog: ["ammo", "rifles", "med_kits", "coffee", "tea", "dried_fruit", "salt_soda"],
      baseStock: {
        ammo: 52,
        rifles: 3,
        med_kits: 6,
        coffee: 10,
        tea: 14,
        dried_fruit: 12,
        salt_soda: 6,
      },
      stockCap: {
        ammo: 90,
        rifles: 4,
        med_kits: 10,
        coffee: 16,
        tea: 20,
        dried_fruit: 18,
        salt_soda: 10,
      },
      restockPerDay: {
        ammo: 4.5,
        rifles: 0.08,
        med_kits: 0.35,
        coffee: 0.9,
        tea: 1.1,
        dried_fruit: 0.8,
        salt_soda: 0.4,
      },
      flavorNotes: [
        "Pages are faintly oiled to hide notes; the ledger opens without a sound.",
        "Rifles are wrapped in gray cloth, initials stitched where a stamp should be.",
        "A dull silver token weights the corner of the page when you look away.",
      ],
    },
    fort_kearny_ne: {
      label: "Platte River sutler",
      policyId: "army_tariff",
      catalog: [
        "flour",
        "bacon",
        "beans_rice",
        "hardtack",
        "dried_fruit",
        "coffee",
        "sugar",
        "salt_soda",
        "water_barrels",
        "firewood",
        "oxen",
        "wheels",
        "axles",
        "tongues",
        "ammo",
        "rifles",
        "med_kits",
      ],
      baseStock: {
        flour: 420,
        bacon: 140,
        beans_rice: 120,
        hardtack: 96,
        dried_fruit: 60,
        coffee: 24,
        sugar: 50,
        salt_soda: 20,
        water_barrels: 5,
        firewood: 30,
        oxen: 8,
        wheels: 6,
        axles: 5,
        tongues: 3,
        ammo: 260,
        rifles: 5,
        med_kits: 12,
      },
      stockCap: {
        flour: 560,
        bacon: 190,
        beans_rice: 160,
        hardtack: 140,
        dried_fruit: 90,
        coffee: 34,
        sugar: 70,
        salt_soda: 28,
        water_barrels: 8,
        firewood: 46,
        oxen: 11,
        wheels: 8,
        axles: 7,
        tongues: 5,
        ammo: 360,
        rifles: 7,
        med_kits: 16,
      },
      restockPerDay: {
        flour: 24,
        bacon: 10,
        beans_rice: 8,
        hardtack: 7,
        dried_fruit: 5,
        coffee: 2.2,
        sugar: 3.5,
        salt_soda: 1.2,
        water_barrels: 0.8,
        firewood: 6,
        oxen: 0.3,
        wheels: 0.5,
        axles: 0.45,
        tongues: 0.22,
        ammo: 16,
        rifles: 0.2,
        med_kits: 0.7,
      },
      flavorNotes: ["Army freight claims the best bacon first.", "Fresh teams sell quick after muddy weeks."],
    },
    fort_laramie_wy: {
      label: "Laramie sutler",
      policyId: "army_tariff",
      catalog: [
        "flour",
        "bacon",
        "beans_rice",
        "hardtack",
        "dried_fruit",
        "coffee",
        "sugar",
        "salt_soda",
        "water_barrels",
        "buffalo_chips",
        "oxen",
        "wheels",
        "axles",
        "tongues",
        "ammo",
        "rifles",
        "med_kits",
      ],
      baseStock: {
        flour: 380,
        bacon: 130,
        beans_rice: 110,
        hardtack: 90,
        dried_fruit: 55,
        coffee: 24,
        sugar: 45,
        salt_soda: 18,
        water_barrels: 5,
        buffalo_chips: 26,
        oxen: 8,
        wheels: 6,
        axles: 5,
        tongues: 3,
        ammo: 300,
        rifles: 5,
        med_kits: 11,
      },
      stockCap: {
        flour: 520,
        bacon: 180,
        beans_rice: 150,
        hardtack: 130,
        dried_fruit: 80,
        coffee: 36,
        sugar: 64,
        salt_soda: 26,
        water_barrels: 8,
        buffalo_chips: 36,
        oxen: 11,
        wheels: 8,
        axles: 7,
        tongues: 5,
        ammo: 400,
        rifles: 7,
        med_kits: 15,
      },
      restockPerDay: {
        flour: 22,
        bacon: 8,
        beans_rice: 7,
        hardtack: 6,
        dried_fruit: 4,
        coffee: 2.2,
        sugar: 3,
        salt_soda: 1,
        water_barrels: 0.7,
        buffalo_chips: 6,
        oxen: 0.3,
        wheels: 0.45,
        axles: 0.4,
        tongues: 0.22,
        ammo: 18,
        rifles: 0.2,
        med_kits: 0.6,
      },
      flavorNotes: ["Buffalo chips piled high after hunts; wood stays dear.", "Army scouts pay silver for spare cartridges."],
    },
    fort_bridger_wy: {
      label: "Bridger trading post",
      policyId: "free_traders",
      catalog: [
        "flour",
        "bacon",
        "beans_rice",
        "hardtack",
        "dried_fruit",
        "coffee",
        "sugar",
        "salt_soda",
        "water_barrels",
        "firewood",
        "buffalo_chips",
        "oxen",
        "wheels",
        "axles",
        "tongues",
        "ammo",
        "rifles",
        "med_kits",
      ],
      baseStock: {
        flour: 320,
        bacon: 120,
        beans_rice: 110,
        hardtack: 90,
        dried_fruit: 60,
        coffee: 24,
        sugar: 44,
        salt_soda: 18,
        water_barrels: 5,
        firewood: 36,
        buffalo_chips: 20,
        oxen: 7,
        wheels: 7,
        axles: 6,
        tongues: 4,
        ammo: 280,
        rifles: 5,
        med_kits: 12,
      },
      stockCap: {
        flour: 460,
        bacon: 170,
        beans_rice: 150,
        hardtack: 130,
        dried_fruit: 90,
        coffee: 36,
        sugar: 64,
        salt_soda: 26,
        water_barrels: 8,
        firewood: 52,
        buffalo_chips: 30,
        oxen: 10,
        wheels: 10,
        axles: 8,
        tongues: 6,
        ammo: 380,
        rifles: 7,
        med_kits: 16,
      },
      restockPerDay: {
        flour: 18,
        bacon: 7,
        beans_rice: 6,
        hardtack: 6,
        dried_fruit: 4,
        coffee: 2,
        sugar: 2.8,
        salt_soda: 1,
        water_barrels: 0.6,
        firewood: 7,
        buffalo_chips: 4,
        oxen: 0.28,
        wheels: 0.6,
        axles: 0.5,
        tongues: 0.25,
        ammo: 16,
        rifles: 0.18,
        med_kits: 0.6,
      },
      flavorNotes: ["Mountain passes chew up wheels; bring silver for spares.", "Meat’s fine but coffee rides dear over South Pass."],
    },
    fort_hall_id: {
      label: "Snake River post",
      policyId: "company_counter",
      catalog: [
        "flour",
        "bacon",
        "beans_rice",
        "hardtack",
        "dried_fruit",
        "coffee",
        "sugar",
        "salt_soda",
        "water_barrels",
        "firewood",
        "oxen",
        "wheels",
        "axles",
        "tongues",
        "ammo",
        "rifles",
        "med_kits",
      ],
      baseStock: {
        flour: 300,
        bacon: 110,
        beans_rice: 100,
        hardtack: 80,
        dried_fruit: 50,
        coffee: 20,
        sugar: 40,
        salt_soda: 16,
        water_barrels: 5,
        firewood: 32,
        oxen: 6,
        wheels: 6,
        axles: 5,
        tongues: 3,
        ammo: 260,
        rifles: 4,
        med_kits: 10,
      },
      stockCap: {
        flour: 420,
        bacon: 150,
        beans_rice: 140,
        hardtack: 120,
        dried_fruit: 76,
        coffee: 30,
        sugar: 58,
        salt_soda: 24,
        water_barrels: 8,
        firewood: 46,
        oxen: 9,
        wheels: 9,
        axles: 7,
        tongues: 5,
        ammo: 360,
        rifles: 6,
        med_kits: 14,
      },
      restockPerDay: {
        flour: 16,
        bacon: 6,
        beans_rice: 6,
        hardtack: 5,
        dried_fruit: 3,
        coffee: 1.8,
        sugar: 2.6,
        salt_soda: 0.9,
        water_barrels: 0.6,
        firewood: 6,
        oxen: 0.22,
        wheels: 0.45,
        axles: 0.4,
        tongues: 0.2,
        ammo: 14,
        rifles: 0.16,
        med_kits: 0.55,
      },
      flavorNotes: ["River water barrels fetch coin after dust storms.", "Spare wheels lean against the stockade, not for long."],
    },
    fort_boise_id: {
      label: "Boise River sutler",
      policyId: "free_traders",
      catalog: [
        "flour",
        "bacon",
        "beans_rice",
        "hardtack",
        "dried_fruit",
        "coffee",
        "sugar",
        "salt_soda",
        "water_barrels",
        "firewood",
        "oxen",
        "wheels",
        "axles",
        "tongues",
        "ammo",
        "rifles",
        "med_kits",
      ],
      baseStock: {
        flour: 280,
        bacon: 100,
        beans_rice: 100,
        hardtack: 82,
        dried_fruit: 48,
        coffee: 18,
        sugar: 36,
        salt_soda: 16,
        water_barrels: 5,
        firewood: 34,
        oxen: 6,
        wheels: 6,
        axles: 5,
        tongues: 3,
        ammo: 240,
        rifles: 4,
        med_kits: 10,
      },
      stockCap: {
        flour: 400,
        bacon: 140,
        beans_rice: 136,
        hardtack: 118,
        dried_fruit: 72,
        coffee: 28,
        sugar: 54,
        salt_soda: 24,
        water_barrels: 8,
        firewood: 48,
        oxen: 9,
        wheels: 9,
        axles: 7,
        tongues: 5,
        ammo: 330,
        rifles: 6,
        med_kits: 14,
      },
      restockPerDay: {
        flour: 15,
        bacon: 6,
        beans_rice: 6,
        hardtack: 5,
        dried_fruit: 3,
        coffee: 1.5,
        sugar: 2.4,
        salt_soda: 0.9,
        water_barrels: 0.6,
        firewood: 6,
        oxen: 0.22,
        wheels: 0.45,
        axles: 0.4,
        tongues: 0.2,
        ammo: 12,
        rifles: 0.14,
        med_kits: 0.5,
      },
      flavorNotes: ["Coffee grows scarce this far west.", "Boise metalwork is thin; mind your axles."],
    },
    fort_walla_walla_wa: {
      label: "Walla Walla post",
      catalog: [
        "flour",
        "bacon",
        "beans_rice",
        "hardtack",
        "dried_fruit",
        "coffee",
        "sugar",
        "salt_soda",
        "water_barrels",
        "firewood",
        "oxen",
        "wheels",
        "axles",
        "tongues",
        "ammo",
        "rifles",
        "med_kits",
      ],
      baseStock: {
        flour: 360,
        bacon: 120,
        beans_rice: 110,
        hardtack: 90,
        dried_fruit: 52,
        coffee: 18,
        sugar: 38,
        salt_soda: 16,
        water_barrels: 6,
        firewood: 40,
        oxen: 6,
        wheels: 7,
        axles: 6,
        tongues: 4,
        ammo: 240,
        rifles: 4,
        med_kits: 12,
      },
      stockCap: {
        flour: 520,
        bacon: 170,
        beans_rice: 150,
        hardtack: 130,
        dried_fruit: 78,
        coffee: 28,
        sugar: 56,
        salt_soda: 24,
        water_barrels: 10,
        firewood: 60,
        oxen: 9,
        wheels: 10,
        axles: 9,
        tongues: 6,
        ammo: 330,
        rifles: 6,
        med_kits: 16,
      },
      restockPerDay: {
        flour: 18,
        bacon: 7,
        beans_rice: 6,
        hardtack: 6,
        dried_fruit: 3,
        coffee: 1.4,
        sugar: 2.4,
        salt_soda: 0.9,
        water_barrels: 0.8,
        firewood: 7,
        oxen: 0.2,
        wheels: 0.55,
        axles: 0.5,
        tongues: 0.24,
        ammo: 12,
        rifles: 0.14,
        med_kits: 0.5,
      },
      flavorNotes: ["Riverboats bid up sugar and coffee.", "Blacksmith hammers run long hours patching wagon gear."],
    },
    fort_vancouver_wa: {
      label: "Columbia depot",
      catalog: [
        "flour",
        "bacon",
        "beans_rice",
        "hardtack",
        "dried_fruit",
        "coffee",
        "sugar",
        "salt_soda",
        "water_barrels",
        "firewood",
        "oxen",
        "wheels",
        "axles",
        "tongues",
        "ammo",
        "rifles",
        "med_kits",
      ],
      baseStock: {
        flour: 420,
        bacon: 150,
        beans_rice: 130,
        hardtack: 100,
        dried_fruit: 60,
        coffee: 22,
        sugar: 50,
        salt_soda: 18,
        water_barrels: 8,
        firewood: 42,
        oxen: 7,
        wheels: 8,
        axles: 7,
        tongues: 4,
        ammo: 280,
        rifles: 5,
        med_kits: 14,
      },
      stockCap: {
        flour: 600,
        bacon: 210,
        beans_rice: 180,
        hardtack: 150,
        dried_fruit: 90,
        coffee: 34,
        sugar: 72,
        salt_soda: 26,
        water_barrels: 12,
        firewood: 62,
        oxen: 10,
        wheels: 11,
        axles: 10,
        tongues: 6,
        ammo: 380,
        rifles: 7,
        med_kits: 20,
      },
      restockPerDay: {
        flour: 22,
        bacon: 9,
        beans_rice: 8,
        hardtack: 7,
        dried_fruit: 4,
        coffee: 2,
        sugar: 3.2,
        salt_soda: 1,
        water_barrels: 1,
        firewood: 8,
        oxen: 0.22,
        wheels: 0.6,
        axles: 0.55,
        tongues: 0.25,
        ammo: 16,
        rifles: 0.2,
        med_kits: 0.7,
      },
      flavorNotes: ["River ships bring staples, but ships sail west first.", "Doctors ride in with garrison paydays—arrive midweek."],
    },
  };

  function getFortTradeDef(poiId) {
    return (poiId && FORT_TRADE_DEFS[poiId]) || DEFAULT_FORT_TRADE_DEF;
  }

  function getFortPolicyForTradeDef(tradeDef) {
    if (!tradeDef || !tradeDef.policyId) return null;
    const policy = FORT_POLICY_DEFS[tradeDef.policyId];
    return policy || null;
  }

  function getDaySerial(date) {
    const d = date instanceof Date ? date : new Date(date || new Date());
    return Math.floor(d.getTime() / 86400000);
  }

  function ensureTradeVendorsState() {
    const ss = ensureStoryState();
    if (!ss.tradeVendors) ss.tradeVendors = {};
    return ss.tradeVendors;
  }

  function ensureVendorForPoi(poiId) {
    const vendors = ensureTradeVendorsState();
    const key = poiId || "frontier";
    if (!vendors[key]) {
      const def = getFortTradeDef(key);
      const rngSeed = hashToInt((gameState.partyId || "party") + ":" + key + ":vendor");
      const rng = mulberry32(rngSeed);
      const stocks = {};
      (def.catalog || []).forEach(function (id) {
        const base = (def.baseStock && def.baseStock[id]) || 0;
        const cap = getVendorStockCap(def, id, base);
        const start = Math.round(base * (0.75 + rng() * 0.5));
        stocks[id] = clamp(start, 0, cap);
      });
      vendors[key] = {
        stocks: stocks,
        lastRestockDay: getDaySerial(gameState.date || new Date()),
        seed: rngSeed,
      };
    }
    const vendorState = vendors[key];
    if (!vendorState.stocks) vendorState.stocks = {};
    if (vendorState.lastRestockDay == null)
      vendorState.lastRestockDay = getDaySerial(gameState.date || new Date());
    if (typeof vendorState.seed !== "number")
      vendorState.seed = hashToInt((gameState.partyId || "party") + ":" + key + ":vendor");
    return vendorState;
  }

  function restockVendorForPoi(poiId, tradeDef) {
    const def = tradeDef || getFortTradeDef(poiId);
    const vendorState = ensureVendorForPoi(poiId);
    const today = getDaySerial(gameState.date || new Date());
    const lastDay = typeof vendorState.lastRestockDay === "number" ? vendorState.lastRestockDay : today;
    const daysPassed = Math.max(0, today - lastDay);
    const restock = def.restockPerDay || {};
    const base = def.baseStock || {};
    const stocks = vendorState.stocks || {};
    if (daysPassed > 0) {
      (def.catalog || []).forEach(function (id) {
        const perDay = restock[id] != null ? restock[id] : 0;
        const cap = getVendorStockCap(def, id, base[id]);
        const next = clamp(Math.round((stocks[id] || 0) + perDay * daysPassed), 0, cap);
        stocks[id] = next;
      });
    }
    vendorState.lastRestockDay = today;
    vendorState.stocks = stocks;
    return vendorState;
  }

  function getVendorStockCap(tradeDef, itemId, baseVal) {
    const def = tradeDef || DEFAULT_FORT_TRADE_DEF;
    const base = baseVal != null ? baseVal : (def.baseStock && def.baseStock[itemId]) || 0;
    const cap = def.stockCap && def.stockCap[itemId];
    if (typeof cap === "number") return cap;
    const defaultCap = Math.max(4, Math.round((base || 4) * 2));
    return defaultCap;
  }

  function ensureMythicCurioState() {
    const ss = ensureStoryState();
    if (!ss.mythicCurios)
      ss.mythicCurios = { owned: [], slots: [null, null], upkeepState: {} };
    return ss.mythicCurios;
  }

  function getCurioDef(id) {
    return CURIO_DEFS.find(function (c) {
      return c.id === id;
    });
  }

  function gainMythicCurio(id, reason) {
    if (!gameState.mythicEnabled) return;
    const curio = getCurioDef(id);
    if (!curio) return;
    const state = ensureMythicCurioState();
    if (state.owned.indexOf(id) < 0) state.owned.push(id);
    addLog("Gained mythic curio: " + curio.name + (reason ? " — " + reason : ""), { tone: "event" });
    recordStoryBeat("mythic", "curio_gained", curio.name, { curioId: id });
  }

  function equipMythicCurio(id, slot) {
    if (!gameState.mythicEnabled) return;
    const curio = getCurioDef(id);
    const state = ensureMythicCurioState();
    if (!curio || state.owned.indexOf(id) < 0) return;
    const idx = Math.max(0, Math.min(1, slot || 0));
    state.slots[idx] = id;
    addLog(curio.name + " is readied.", { tone: "event" });
  }

  function unequipMythicCurio(slot) {
    const state = ensureMythicCurioState();
    const idx = Math.max(0, Math.min(1, slot || 0));
    const id = state.slots[idx];
    if (!id) return;
    const curio = getCurioDef(id);
    state.slots[idx] = null;
    addLog((curio ? curio.name : "Curio") + " stowed.", { tone: "event" });
  }

  function getReputationTier() {
    ensureReputationState();
    const val = clamp(gameState.reputation, -100, 100);
    if (val >= 50)
      return {
        id: "honorable",
        label: "Honorable",
        desc: "Known for generosity and fair dealing along the trail.",
        colorClass: "ot-rep-chip-virtuous",
      };
    if (val >= 15)
      return {
        id: "trusted",
        label: "Trusted",
        desc: "Most travelers expect honesty when you bargain or ask for aid.",
        colorClass: "ot-rep-chip-virtuous",
      };
    if (val > -15)
      return {
        id: "neutral",
        label: "Unknown",
        desc: "Your name carries little weight yet—good or ill.",
        colorClass: "ot-rep-chip-neutral",
      };
    if (val > -45)
      return {
        id: "questioned",
        label: "Questioned",
        desc: "Rumors say you press hard bargains or turn folks away.",
        colorClass: "ot-rep-chip-notorious",
      };
    return {
      id: "notorious",
      label: "Notorious",
      desc: "Feared for sharp dealing or rough justice on the trail.",
      colorClass: "ot-rep-chip-notorious",
    };
  }

  function adjustReputation(delta, reason, opts) {
    ensureReputationState();
    const change = typeof delta === "number" ? delta : 0;
    const before = gameState.reputation || 0;
    const after = clamp(before + change, -100, 100);
    gameState.reputation = after;
    if (opts && opts.flag) {
      gameState.reputationFlags[opts.flag] = true;
    }
    if (change !== 0) {
      const tier = getReputationTier();
      const direction = change > 0 ? "improves" : "sours";
      addLog(
        (reason || "Word travels") + `: your standing ${direction} (${after}).`,
        { tone: "info" }
      );
      renderReputation();
    }
  }

  function addThought(person, cfg) {
    if (!person || !cfg) return;
    ensurePersonStoryFields(person);
    const id = cfg.id || "thought_" + Date.now();
    const value = clamp(cfg.value || 0, -20, 20);
    const hoursLeft = cfg.hoursLeft != null ? cfg.hoursLeft : 8;
    const existing = person.thoughts.find(function (t) {
      return t && t.id === id;
    });
    if (existing) {
      existing.hoursLeft = Math.max(existing.hoursLeft || 0, hoursLeft);
      existing.value = value;
      existing.source = cfg.source || existing.source;
      existing.label = cfg.label || existing.label;
    } else {
      person.thoughts.push({
        id: id,
        label: cfg.label || id,
        value: value,
        hoursLeft: hoursLeft,
        source: cfg.source || "",
      });
    }
  }

  function ensureSocialHistory() {
    if (!gameState.socialHistory) gameState.socialHistory = { rescues: [] };
    if (!Array.isArray(gameState.socialHistory.rescues)) gameState.socialHistory.rescues = [];
    return gameState.socialHistory;
  }

  function relationshipLabel(rel) {
    if (!rel) return "";
    if (rel.tags && rel.tags.indexOf("sibling") >= 0) return "Family";
    if (rel.tags && rel.tags.indexOf("friend") >= 0) return "Friend";
    if (rel.tags && rel.tags.indexOf("rival") >= 0) return "Rival";
    if (rel.tags && rel.tags.indexOf("leader") >= 0) return "Leader";
    return rel.opinion >= 50 ? "Ally" : rel.opinion <= -25 ? "Tense" : "Neutral";
  }

  function socialInteraction(a, b, type) {
    if (!a || !b) return;
    const labelMap = {
      chat: { delta: 2, thought: "Good talk" },
      joke: { delta: 3, thought: "Shared a joke" },
      help: { delta: 4, thought: "Helped out" },
      argue: { delta: -4, thought: "Argument" },
      cold: { delta: -2, thought: "Cold shoulder" },
      apology: { delta: 2, thought: "Apology" },
    };
    const cfg = labelMap[type] || labelMap.chat;
    adjustOpinion(a, b, cfg.delta, "social");
    adjustOpinion(b, a, cfg.delta * 0.8, "social");
    addThought(a, { id: `${type}_${b.id}`, label: cfg.thought, value: cfg.delta >= 0 ? 2 : -2, hoursLeft: 8, source: "social" });
    addThought(b, { id: `${type}_${a.id}`, label: cfg.thought, value: cfg.delta >= 0 ? 2 : -2, hoursLeft: 8, source: "social" });
    addLog(`${a.name} and ${b.name} ${type === "argue" ? "argued" : type === "cold" ? "kept apart" : "shared a moment"}.`, {
      tone: cfg.delta >= 0 ? "social" : "warning",
      characters: [a.id, b.id],
    });
  }

  function maybeRunDailySocialMoments() {
    const ss = ensureStoryState();
    const dayKey = getDayKey(gameState.date);
    const block = getScheduleBlock(gameState.date);
    if (block !== "evening" && block !== "night") return;
    if (gameState.mode !== "camp") return;
    if (ss.lastSocialDay === dayKey) return;
    ss.lastSocialDay = dayKey;
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    if (people.length < 2) return;
    const rng = draftRng("social:" + dayKey + ":" + block);
    const count = Math.min(2, Math.max(1, Math.floor(people.length / 2)));
    for (let i = 0; i < count; i++) {
      const a = people[Math.floor(rng() * people.length)];
      const b = people[Math.floor(rng() * people.length)];
      if (!a || !b || a.id === b.id) continue;
      const rel = getRelationship(a, b);
      let type = "chat";
      if (rel.opinion < -20 && rng() < 0.5) type = "argue";
      else if (rel.opinion > 40 && rng() < 0.5) type = "joke";
      else if (rng() < 0.3) type = "help";
      else if (rng() < 0.2) type = "cold";
      else if (rel.opinion < -10 && rng() < 0.25) type = "apology";
      socialInteraction(a, b, type);
    }
  }

  function renderSocialWeb() {
    if (!dom.socialBody) return;
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    const seen = {};
    const rows = [];
    people.forEach(function (a) {
      Object.keys(a.relationships || {}).forEach(function (rid) {
        const b = people.find(function (p) {
          return p.id === rid;
        });
        if (!b) return;
        const key = getPairKey(a, b);
        if (seen[key]) return;
        seen[key] = true;
        const rel = a.relationships[rid];
        rows.push({
          a: a,
          b: b,
          rel: rel,
        });
      });
    });
    dom.socialBody.innerHTML = "";
    if (!rows.length) {
      dom.socialBody.textContent = "No bonds recorded yet.";
      return;
    }
    const grid = document.createElement("div");
    grid.className = "ot-social-grid";
    rows.forEach(function (row) {
      const card = document.createElement("div");
      card.className = "ot-social-card";
      const head = document.createElement("div");
      head.className = "ot-social-label";
      head.textContent = row.a.name + " ↔ " + row.b.name;
      const meta = document.createElement("div");
      meta.className = "ot-social-row";
      meta.textContent = relationshipLabel(row.rel) + " · Opinion " + Math.round(row.rel.opinion || 0);
      card.appendChild(head);
      card.appendChild(meta);
      grid.appendChild(card);
    });
    dom.socialBody.appendChild(grid);
  }

  function recordRescueEvent(rescuer, rescued, cause, ctx) {
    if (!rescuer || !rescued) return;
    const hist = ensureSocialHistory();
    hist.rescues.push({
      rescuerId: rescuer.id,
      rescuedId: rescued.id,
      hour: getCurrentTrailHour(gameState),
      region: gameState.region,
      location: gameState.locationName,
      cause: cause || "rescue",
    });
    if (hist.rescues.length > 24) hist.rescues.shift();
    recordCascadePersonEvent(rescuer.id, "lifeline", { linkId: rescued.id, cause: cause });
    recordCascadePersonEvent(rescued.id, "rescued", { linkId: rescuer.id, cause: cause });
  }

  function noteTaskHistory(person, taskId) {
    if (!person || !taskId) return;
    ensurePersonStoryFields(person);
    const h = getCurrentTrailHour(gameState);
    if (!person.taskHistory) person.taskHistory = { recent: [], totals: {} };
    person.taskHistory.recent.push({ task: taskId, hour: h });
    if (person.taskHistory.recent.length > 72) person.taskHistory.recent.shift();
    person.taskHistory.totals[taskId] = (person.taskHistory.totals[taskId] || 0) + 1;
  }

  /* ========= OUTFITTING LOGIC ============================================= */

  const outfitDom = {
    inputs: {},
    totals: {},
  };

  function buildOutfitTable() {
    dom.outfitBody.innerHTML = "";
    outfitDom.inputs = {};
    outfitDom.totals = {};

    SUPPLY_ITEMS.forEach(function (item) {
      const tr = document.createElement("tr");

      const tdName = document.createElement("td");
      tdName.textContent = item.name;
      tr.appendChild(tdName);

      const tdQty = document.createElement("td");
      if (item.readOnly) {
        tdQty.textContent = "—";
      } else {
        const input = document.createElement("input");
        input.type = "number";
        input.min = "0";
        input.step = "1";
        input.className = "ot-outfit-qty";
        input.value = gameState.supplies[item.id] || 0;
        input.addEventListener("change", function () {
          const val = parseFloat(input.value) || 0;
          gameState.supplies[item.id] = Math.max(0, val);
          updateOutfitSummary();
          saveGame();
        });
        outfitDom.inputs[item.id] = input;
        tdQty.appendChild(input);
      }
      tr.appendChild(tdQty);

      const tdUnit = document.createElement("td");
      tdUnit.textContent = item.unit;
      tr.appendChild(tdUnit);

      const tdCost = document.createElement("td");
      tdCost.textContent = "$" + item.cost.toFixed(2);
      tr.appendChild(tdCost);

      const tdSubtotal = document.createElement("td");
      tdSubtotal.textContent = "$0.00";
      outfitDom.totals[item.id] = tdSubtotal;
      tr.appendChild(tdSubtotal);

      dom.outfitBody.appendChild(tr);
    });
  }

  function computeTotalWeight() {
    let total = 0;
    SUPPLY_ITEMS.forEach(function (item) {
      const qty = gameState.supplies[item.id] || 0;
      total += qty * item.weight;
    });
    return total;
  }

  function computeDraftPower() {
    const oxen = gameState.supplies.oxen || 0;
    const cows = gameState.supplies.milk_cows || 0;
    return oxen * 650 + cows * 300;
  }

  function updateOutfitSummary() {
    let spent = 0;
    SUPPLY_ITEMS.forEach(function (item) {
      const qty = gameState.supplies[item.id] || 0;
      const freeQty =
        (gameState.startingFreeSupplies &&
          gameState.startingFreeSupplies[item.id]) ||
        0;
      const chargeQty = Math.max(0, qty - freeQty);
      const subtotal = item.cost * chargeQty;
      spent += subtotal;
      if (outfitDom.totals[item.id]) {
        outfitDom.totals[item.id].textContent = formatMoney(subtotal);
      }
    });

    const startingMoney = gameState.startingMoney || 0;
    gameState.money = startingMoney - spent;
    dom.sumStarting.textContent = formatMoney(startingMoney);
    dom.sumMoney.textContent = formatMoney(gameState.money);
    dom.sumMoney.classList.toggle("ot-text-warning", gameState.money < 0.01);

    const totalWeight = computeTotalWeight();
    const draft = computeDraftPower();

    dom.sumLoad.textContent = Math.round(totalWeight) + " lb";
    if (draft > 0) {
      dom.sumDraft.textContent = Math.round(draft) + " lb pull";
      const ratio = totalWeight / draft;
      const pct = Math.round(ratio * 100);
      dom.sumRatio.textContent = pct + "%";
      dom.sumRatio.classList.toggle("ot-text-warning", ratio > 0.9);
    } else {
      dom.sumDraft.textContent = "No draft animals";
      dom.sumRatio.textContent = "—";
      dom.sumRatio.classList.add("ot-text-warning");
    }

    const okToDepart = gameState.money >= 0 && draft > 0 && totalWeight > 0;
    dom.btnBeginJourney.disabled = !okToDepart;
  }

  function addRecommendedLoad() {
    SUPPLY_ITEMS.forEach(function (item) {
      if (item.readOnly) return;
      const target = item.recommended || 0;
      if (target > (gameState.supplies[item.id] || 0)) {
        gameState.supplies[item.id] = target;
        if (outfitDom.inputs[item.id]) {
          outfitDom.inputs[item.id].value = target;
        }
      }
    });
    updateOutfitSummary();
    saveGame();
  }

  function findSupplyDef(id) {
    return SUPPLY_ITEMS.find(function (s) {
      return s.id === id;
    });
  }

  function formatFreeSuppliesSummary() {
    const free = gameState.startingFreeSupplies || {};
    const entries = Object.keys(free).filter(function (k) {
      return free[k] > 0;
    });
    if (!entries.length) return null;
    const parts = entries.map(function (id) {
      const def = findSupplyDef(id);
      const label = def ? def.name.toLowerCase() : id;
      return `+${free[id]} ${label}`;
    });
    return parts.join(", ");
  }

  function updateOutfitIntro() {
    const mouths = 1 + gameState.companions.length;
    let text =
      "You begin with " +
      formatMoney(gameState.startingMoney || 0) +
      " and a party of " +
      mouths +
      ". Outfit them for five to six months on the trail.";

    const freeSummary = formatFreeSuppliesSummary();
    if (freeSummary) {
      text +=
        " Some companions arrived with supplies already in the wagon: " +
        freeSummary +
        ".";
    } else if (
      gameState.startingFreeSuppliesNotes &&
      gameState.startingFreeSuppliesNotes.length
    ) {
      text += " " + gameState.startingFreeSuppliesNotes.join(" ");
    }

    dom.outfitIntro.textContent = text;
  }

  function renderLeaderStartPreview() {
    if (!dom.leaderCallingPreview || !dom.leaderFundsPreview) return;
    const draft = ensurePartyDraftState().people.leader;
    if (!draft) {
      dom.leaderCallingPreview.textContent = "Draft a leader to begin.";
      dom.leaderFundsPreview.textContent = "Starting funds: —";
      return;
    }
    const profile = computeLeaderStartProfile(draft);
    const callingText = profile.callingLabel;
    const originText = profile.callingOrigin ? ` · ${profile.callingOrigin}` : "";
    dom.leaderCallingPreview.textContent = callingText + originText;
    dom.leaderFundsPreview.textContent =
      "Starting funds: " + formatMoney(profile.startingMoney || 0);
  }

  function updateStartArt() {
    const dep = dom.departureSelect.value;
    let url = IMAGE_URLS.start_screen;
    if (dep === "independence") url = IMAGE_URLS.independence_start_edge;
    else if (dep === "st_joseph") url = IMAGE_URLS.st_joseph_start;
    else if (dep === "council_bluffs") url = IMAGE_URLS.council_bluffs_start;
    dom.startArt.style.backgroundImage =
      "linear-gradient(to top, rgba(0,0,0,.7), rgba(0,0,0,.15)), url('" +
      url +
      "')";
  }

  function updateOutfitArt() {
    dom.outfitArt.style.backgroundImage =
      "linear-gradient(to top, rgba(0,0,0,.7), rgba(0,0,0,.15)), url('" +
      IMAGE_URLS.generalstore_missouri +
      "')";
  }

  function beginJourney() {
    const barrels = gameState.supplies.water_barrels || 0;
    if (!gameState.supplies.water) gameState.supplies.water = 0;
    gameState.supplies.water += barrels * 30;
    registerSpoilageForPerishables(gameState.supplies, gameState.supplies, {
      note: "starting pantry",
      acquiredHour: getCurrentTrailHour(gameState),
    });
    addLog("You roll out from " + gameState.locationName + " and head west.");
    showScreen("travel");
    saveGame();
    renderAll();
  }

  /* ========= HOURLY SIMULATION ============================================ */

  function mouthsCount() {
    return (
      (gameState.leader && gameState.leader.alive ? 1 : 0) +
      gameState.companions.filter(function (c) {
        return c.alive;
      }).length
    );
  }

  function computeMilesForHour() {
    if (gameState.mode !== "travel") return 0;
    const paceCfg = PACE_CONFIG[gameState.pace] || PACE_CONFIG.steady;
    const conditionFactor = 0.6 + (gameState.wagonCondition / 100) * 0.6;
    const w = gameState.weatherState || {};
    let weatherFactor = 1;

    if (w.precip === "rain") {
      weatherFactor -= 0.12;
      if (gameState.recentRainHours > 18) weatherFactor -= 0.1;
    } else if (w.precip === "snow") {
      weatherFactor -= 0.2;
    }
    if (w.tempC >= 30) weatherFactor -= 0.08;
    else if (w.tempC >= 24) weatherFactor -= 0.04;
    if (w.tempC >= 10 && w.tempC <= 20 && w.precip === "none") {
      weatherFactor += 0.04;
    }

    weatherFactor = clamp(weatherFactor, 0.4, 1.15);

    const baseMiles = paceCfg.milesPerHour * conditionFactor * weatherFactor;
    const rhythmBonus = gameState.lastDayRhythmBonus || 0;
    let mobilityPenalty = 1;
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    people.forEach(function (p) {
      activeAfflictions(p).forEach(function (aff) {
        if (aff.id === "sprain") {
          if (aff.stage === "acute") mobilityPenalty *= 0.9;
          else if (aff.stage === "recovery") mobilityPenalty *= 0.97;
        }
      });
    });

    const finalMiles = baseMiles * (1 + rhythmBonus) * mobilityPenalty;
    const mods = getHexWorldModifiers(getPlayerHexFromMiles());
    let terrainFactor = 1;
    if (mods.inSubletteDesert) terrainFactor *= 0.86;
    if (mods.atBigSandy) terrainFactor *= 0.92;
    const adjusted = finalMiles * terrainFactor;
    return adjusted;
  }


  function autoConsumeFor(person) {
    const rationCfg = RATION_CONFIG[gameState.rations] || RATION_CONFIG.filling;
    if (!person.alive) return;

    if (person.hunger < rationCfg.targetHunger) {
      eatUntil(person, rationCfg.targetHunger);
    }
    if (person.thirst < rationCfg.targetThirst) {
      drinkUntil(person, rationCfg.targetThirst);
    }
  }

  function eatUntil(person, target) {
    while (person.hunger < target - 3) {
      if (useFood("meal_feast", person)) continue;
      if (useFood("meal_hearty", person)) continue;
      if (useFood("meal_simple", person)) continue;
      if (useFood("cooked_meals", person)) continue;
      if (useFood("fresh_meat", person)) continue;
      if (useFood("bacon", person)) continue;
      if (useFood("flour", person)) continue;
      if (useFood("beans_rice", person)) continue;
      if (useFood("hardtack", person)) continue;
      if (useFood("dried_fruit", person)) continue;
      break;
    }
  }

  function drinkUntil(person, target) {
    while (person.thirst < target - 5) {
      if (gameState.supplies.water <= 0) break;
      gameState.supplies.water = Math.max(
        0,
        gameState.supplies.water - WATER_PER_DRINK
      );
      person.thirst = clamp(person.thirst + 30, 0, 100);
      person.morale = clamp(person.morale + 1, 0, 100);
    }
  }

  function isCholeraCorridor(region, miles) {
    if (region === "central_plains" || region === "plains") {
      return miles >= 260 && miles <= 620;
    }
    return false;
  }

  function afflictionSeverityLabel(sev) {
    if (sev >= 3) return "severe";
    if (sev >= 2) return "moderate";
    return "mild";
  }

  function logAfflictionStageChange(person, aff, prevStage) {
    if (!person || !aff) return;
    const label = aff.label.toLowerCase();
    if (prevStage === "none") {
      addLog(person.name + " falls ill with " + label + ".");
      return;
    }
    if (aff.stage === "acute" && prevStage !== "acute") {
      if (aff.id === "dysentery") {
        addLog(
          "After foul water, " + person.name + " is struck with violent cramps and diarrhea."
        );
      } else if (aff.id === "cholera") {
        addLog(
          person.name +
            " is wracked by cholera — lips dry, hands trembling, water passing straight through."
        );
      } else if (aff.id === "camp_fever") {
        addLog(
          person.name + " is shivering with fever and complains of aching bones."
        );
      } else if (aff.id === "camp_scurvy") {
        addLog(
          person.name + " moves stiffly; gums bleed and joints flare from long weeks without greens."
        );
      } else if (aff.id === "mountain_pneumonia") {
        addLog(
          "Thin air and cold rain catch up to " +
            person.name +
            "; a deep cough settles in."
        );
      } else if (aff.id === "snakebite") {
        addLog(
          "Swelling creeps up from the punctures in " +
            person.name +
            "'s leg; fever threatens if the bite worsens."
        );
      } else if (aff.id === "broken_bone") {
        addLog(
          person.name +
            " lies still as splints are rigged. Travel will be slow while the bone knits."
        );
      } else if (aff.id === "sprain") {
        addLog(person.name + " is laid up by a sprained ankle.");
      }
    } else if (aff.stage === "recovery" && prevStage !== "recovery") {
      addLog(
        person.name +
          " seems to be past the worst of " +
          aff.label.toLowerCase() +
          " and is slowly regaining strength."
      );
    } else if (aff.resolved && prevStage !== "resolved") {
      addLog(
        person.name +
          " is finally able to keep food down and rest; the illness lifts."
      );
    }
    if (typeof renderAfflictionAlerts === "function") {
      renderAfflictionAlerts();
    }
  }

  function tickAfflictionsForHour() {
    const doctor = getBestDoctor();
    const hasMedicine = (gameState.supplies && gameState.supplies.med_kits) > 0;
    const docSkill = doctor && doctor.skills ? doctor.skills.doctoring || 0 : 0;
    const treatBonusBase = 1 + docSkill * 0.2 + (hasMedicine ? 0.5 : 0);
    const rng =
      (gameState.weatherSystem && gameState.weatherSystem.rng) || Math.random;

    getAllPeople().forEach(function (person) {
      if (!person || !person.alive) return;
      ensureAfflictions(person);
      person.afflictions.forEach(function (aff) {
        if (!aff || aff.resolved) return;
        aff.hoursActive += 1;

        if (aff.stage === "acute" && treatBonusBase > 1) {
          aff.reliefHours = (aff.reliefHours || 0) + 0.05 * (treatBonusBase - 1);
          if (hasMedicine && !aff.medicineUsed && aff.severity >= 2) {
            gameState.supplies.med_kits = Math.max(
              0,
              (gameState.supplies.med_kits || 0) - 1
            );
            aff.medicineUsed = true;
            if (doctor) {
              addLog(
                doctor.name +
                  " tends to " +
                  person.name +
                  " with medicines, easing the worst of the sickness."
              );
            }
          }
        }

        const progress = aff.hoursActive + (aff.reliefHours || 0);
        const incubationEnd = aff.hoursIncubation || 0;
        const acuteEnd = incubationEnd + (aff.hoursAcute || 0);
        const recoveryEnd = acuteEnd + (aff.recoveryBuffer || 24);

        let stageBefore = aff.stage;
        if (aff.stage === "incubation" && progress >= incubationEnd) {
          aff.stage = "acute";
          logAfflictionStageChange(person, aff, stageBefore);
          stageBefore = aff.stage;
        }
        if (aff.stage === "acute" && progress >= acuteEnd) {
          stageBefore = aff.stage;
          aff.stage = "recovery";
          aff.lastNotified = aff.hoursActive;
          logAfflictionStageChange(person, aff, stageBefore);
        }
        if (aff.stage === "recovery" && progress >= recoveryEnd) {
          stageBefore = aff.stage;
          aff.stage = "resolved";
          aff.resolved = true;
          logAfflictionStageChange(person, aff, stageBefore);
          return;
        }

        let conditionLoss = 0;
        const treatDivisor = aff.stage === "acute" ? treatBonusBase : 1.0;

        if (aff.id === "dysentery") {
          if (aff.stage === "incubation") {
            person.morale = clamp(person.morale - 0.5, 0, 100);
          } else if (aff.stage === "acute") {
            person.hunger = clamp(
              person.hunger - (6 * aff.severity) / treatDivisor,
              0,
              100
            );
            person.thirst = clamp(
              person.thirst - (9 * aff.severity) / treatDivisor,
              0,
              100
            );
            person.energy = clamp(
              person.energy - (5 * aff.severity) / treatDivisor,
              0,
              110
            );
            person.morale = clamp(person.morale - 4, 0, 100);
            conditionLoss += (1.3 * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            person.energy = clamp(person.energy + 0.5, 0, 110);
            person.morale = clamp(person.morale + 0.5, 0, 100);
            conditionLoss += 0.2;
          }
        } else if (aff.id === "cholera") {
          person.thirst = clamp(person.thirst - 4, 0, 100);
          person.energy = clamp(person.energy - 1.5, 0, 110);
          person.morale = clamp(person.morale - 1.5, 0, 100);
          if (aff.stage === "acute") {
            conditionLoss += (2.2 * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            conditionLoss += 0.5;
          }
        } else if (aff.id === "camp_fever") {
          if (aff.stage === "incubation") {
            person.energy = clamp(person.energy - 1.2, 0, 110);
          } else if (aff.stage === "acute") {
            person.energy = clamp(
              person.energy - (4 * aff.severity) / treatDivisor,
              0,
              110
            );
            person.warmth = clamp(
              person.warmth - (3 + aff.severity),
              0,
              100
            );
            person.morale = clamp(person.morale - 2.5, 0, 100);
            person.thirst = clamp(person.thirst - 2, 0, 100);
            conditionLoss += (0.9 * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            person.warmth = clamp(person.warmth + 0.4, 0, 100);
            person.morale = clamp(person.morale + 0.4, 0, 100);
            conditionLoss += 0.25;
          }
        } else if (aff.id === "sprain") {
          if (aff.stage === "acute") {
            person.energy = clamp(person.energy - 1, 0, 110);
            person.morale = clamp(person.morale - 0.8, 0, 100);
            conditionLoss += 0.35 / treatDivisor;
          } else if (aff.stage === "recovery") {
            person.energy = clamp(person.energy - 0.25, 0, 110);
          }
        } else if (aff.id === "mountain_pneumonia") {
          if (aff.stage === "acute") {
            person.warmth = clamp(person.warmth - 4, 0, 100);
            person.energy = clamp(person.energy - 2, 0, 110);
            conditionLoss += (1.5 * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            person.warmth = clamp(person.warmth - 1, 0, 100);
          }
        } else if (aff.id === "snakebite") {
          conditionLoss += (1.1 * aff.severity) / treatDivisor;
          person.morale = clamp(person.morale - 2, 0, 100);
        } else if (aff.id === "broken_bone") {
          person.energy = clamp(person.energy - 1.2, 0, 110);
          conditionLoss += 0.9 / treatDivisor;
        }

        person.condition = clamp(person.condition - conditionLoss, 0, 100);

        const needsProgressLog =
          aff.stage === "acute" &&
          (aff.lastNotified == null || aff.hoursActive - aff.lastNotified >= 12);
        if (needsProgressLog) {
          aff.lastNotified = aff.hoursActive;
          if (aff.id === "dysentery") {
            addLog(
              person.name +
                " is too weak to walk and rides in the wagon while the illness grips them."
            );
          } else if (aff.id === "camp_fever") {
            addLog(
              person.name +
                " burns with fever and needs tending; travel slows while they rest."
            );
          } else if (aff.id === "sprain") {
            addLog(person.name + " keeps weight off a swollen ankle.");
          }
        }


        if (person.condition <= 0 && person.alive) {
          person.alive = false;
          addLog(
            person.name +
              " dies after a brutal bout of " +
              aff.label.toLowerCase() +
              " on the trail."
          );
          onPersonDeath(person);
        }
      });
    });
  }

  function maybeTriggerIllnessForHour() {
    const rng =
      (gameState.weatherSystem && gameState.weatherSystem.rng) || Math.random;
    const region = gameState.region;
    const w = gameState.weatherState || {};
    const tempC = typeof w.tempC === "number" ? w.tempC : 15;
    const hot = tempC >= 24;
    const wetRecently = w.precip === "rain" || gameState.recentRainHours > 24;
    const mouths = mouthsCount();
    const s = gameState.supplies || {};
    const waterGal = s.water || 0;
    const miles = gameState.milesTraveled || 0;
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    const waterQuality = gameState.waterQuality || "safe";
    const waterSource = gameState.lastWaterSourceType || waterQuality;
    const boiled = !!gameState.lastWaterBoiled;
    const avgConditionEnergy = people.length
      ?
          people.reduce(function (sum, p) {
            return sum + ((p.condition || 0) + (p.energy || 0)) / 2;
          }, 0) / people.length
      : 100;

    if (isCholeraCorridor(region, miles)) {
      let base = 0.0005;
      const badWaterFactor =
        waterSource === "alkali"
          ? 2.4
          : waterSource === "stagnant"
          ? 1.8
          : waterSource === "running"
          ? 0.75
          : 1.0;
      if (boiled) {
        base *= 0.5;
      }
      if (hot && wetRecently) base *= 1.5;
      if (waterGal < mouths * 0.4) base *= 1.5;
      if (avgConditionEnergy < 50) base *= 1.5;
      base *= badWaterFactor;

      let newCase = false;
      people.some(function (p) {
        if (hasAffliction(p, "dysentery") || hasAffliction(p, "cholera"))
          return false;
        if (rng() < base * 0.4) {
          addAffliction(p, "cholera", { severity: 3 });
          newCase = true;
          return true;
        }
        if (rng() < base) {
          addAffliction(p, "dysentery", { severity: rng() < 0.35 ? 2 : 1 });
          newCase = true;
          return true;
        }
        return false;
      });
      if (newCase) return; // avoid multiple clustered cases in one hour
    }

      if (
        waterSource === "alkali" &&
        !isCholeraCorridor(region, miles) &&
        Math.random() < 0.00025
      ) {
      const target = choice(people);
      if (target && !hasAffliction(target, "dysentery")) {
        addAffliction(target, "dysentery", { severity: 1 });
      }
    }

    const coldWet =
      tempC <= 5 || ((w.precip === "rain" && tempC < 10) || w.precip === "snow");
    if (gameState.mode === "camp" && coldWet) {
      const roughCamp =
        gameState.dayRhythm &&
        gameState.dayRhythm.eveningCampChoice === "rushed";
      people.forEach(function (p) {
        if (!p || hasAffliction(p, "camp_fever")) return;
        const warmthLow = p.warmth < 30;
        const energyLow = p.energy < 30;
        if (!warmthLow && !energyLow) return;
        let risk = 0.0003;
        if (warmthLow) risk *= 1.6;
        if (energyLow) risk *= 1.6;
        if (roughCamp) risk *= 1.3;
        if (rng() < risk) {
          addAffliction(p, "camp_fever", { severity: tempC <= 0 ? 2 : 1 });
        }
      });
    }

    if (gameState.region === "mountains" || gameState.region === "blue_mountains") {
      const highCold = tempC < 3 || (w.precip === "snow" && tempC < 8);
      if (highCold) {
        people.forEach(function (p) {
          if (hasAffliction(p, "mountain_pneumonia")) return;
          let risk = 0.0002;
          if (p.warmth < 35) risk *= 2.2;
          if (rng() < risk) addAffliction(p, "mountain_pneumonia", { severity: 2 });
        });
      }
    }

    if (gameState.region === "snake_plain" || gameState.region === "central_plains") {
      const biteRisk = w.tempC > 15 && gameState.mode === "travel" ? 0.00025 : 0;
      if (biteRisk > 0) {
        const walker = choice(people);
        if (walker && rng() < biteRisk && !hasAffliction(walker, "snakebite")) {
          addAffliction(walker, "snakebite", { severity: 2 });
        }
      }
    }
  }

  function isCholeraCorridor(region, miles) {
    if (region === "central_plains" || region === "plains") {
      return miles >= 260 && miles <= 620;
    }
    return false;
  }

  function afflictionSeverityLabel(sev) {
    if (sev >= 3) return "severe";
    if (sev >= 2) return "moderate";
    return "mild";
  }

  function logAfflictionStageChange(person, aff, prevStage) {
    if (!person || !aff) return;
    if (aff.stage === "acute" && prevStage !== "acute") {
      if (aff.id === "dysentery") {
        addLog(
          "After drinking from a stagnant pool along the Platte, " +
            person.name +
            " is struck with violent cramps and diarrhea."
        );
      } else if (aff.id === "camp_fever") {
        addLog(
          person.name +
            " is shivering with fever and complains of aching bones."
        );
      } else if (aff.id === "sprain") {
        addLog(person.name + " is laid up by a sprained ankle.");
      }
    } else if (aff.stage === "recovery" && prevStage !== "recovery") {
      addLog(
        person.name +
          " seems to be past the worst of " +
          aff.label.toLowerCase() +
          " and is slowly regaining strength."
      );
    } else if (aff.resolved && prevStage !== "resolved") {
      addLog(
        person.name +
          " is finally able to keep food down and rest; the illness lifts."
      );
    }
  }

  function tickAfflictionsForHour() {
    const doctorings = gameState.doctoringThisHour || [];
    const treatmentMap = {};
    doctorings.forEach(function (entry) {
      if (!entry || !entry.patient) return;
      const pid = entry.patient.id;
      const skill = (entry.doctor.skills && entry.doctor.skills.doctoring) || 0;
      const medUsed = entry.usedMedicine ? 0.6 : 0;
      const bonus = 0.4 + skill * 0.25 + medUsed;
      treatmentMap[pid] = Math.max(treatmentMap[pid] || 0, bonus);
    });

    const rng =
      (gameState.weatherSystem && gameState.weatherSystem.rng) || Math.random;
    const resting = gameState.mode === "camp";

    getAllPeople().forEach(function (person) {
      if (!person || !person.alive) return;
      ensureAfflictions(person);
      person.afflictions.forEach(function (aff) {
        if (!aff || aff.resolved) return;
        aff.hoursActive += 1;

        const treatBonus = treatmentMap[person.id] || 0;
        if (aff.tendedThisHour) aff.tendedThisHour = false;

        if (treatBonus > 0 && aff.stage === "acute") {
          aff.reliefHours = (aff.reliefHours || 0) + treatBonus;
        }

        const progress = aff.hoursActive + (aff.reliefHours || 0);
        const incubationEnd = aff.hoursIncubation || 0;
        const acuteEnd = incubationEnd + (aff.hoursAcute || 0);
        const recoveryEnd = acuteEnd + (aff.recoveryBuffer || 24);

        let stageBefore = aff.stage;
        if (aff.stage === "incubation" && progress >= incubationEnd) {
          aff.stage = "acute";
          logAfflictionStageChange(person, aff, stageBefore);
          stageBefore = aff.stage;
        }
        if (aff.stage === "acute" && progress >= acuteEnd) {
          stageBefore = aff.stage;
          aff.stage = "recovery";
          aff.lastNotified = aff.hoursActive;
          logAfflictionStageChange(person, aff, stageBefore);
        }
        if (aff.stage === "recovery" && progress >= recoveryEnd) {
          stageBefore = aff.stage;
          aff.stage = "resolved";
          aff.resolved = true;
          logAfflictionStageChange(person, aff, stageBefore);
          return;
        }

        let conditionLoss = 0;
        const treatDivisor = aff.stage === "acute" ? 1 + treatBonus : 1.0;

        function fatigue(deltaEnergy, deltaMorale, deltaWarmth) {
          if (deltaEnergy) person.energy = clamp(person.energy + deltaEnergy, 0, 110);
          if (deltaMorale) person.morale = clamp(person.morale + deltaMorale, 0, 100);
          if (deltaWarmth) person.warmth = clamp(person.warmth + deltaWarmth, 0, 100);
        }

        if (aff.id === "dysentery" || aff.id === "cholera") {
          const thirstHit = aff.id === "cholera" ? 12 : 9;
          const hungerHit = aff.id === "cholera" ? 7 : 6;
          const condScale = aff.id === "cholera" ? 1.6 : 1.2;
          if (aff.stage === "incubation") {
            fatigue(-1, -0.5, 0);
          } else if (aff.stage === "acute") {
            person.hunger = clamp(
              person.hunger - (hungerHit * aff.severity) / treatDivisor,
              0,
              100
            );
            person.thirst = clamp(
              person.thirst - (thirstHit * aff.severity) / treatDivisor,
              0,
              100
            );
            fatigue(-(5 * aff.severity) / treatDivisor, -4, 0);
            conditionLoss += (condScale * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            fatigue(0.5, 0.6, 0);
            conditionLoss += 0.25;
          }
        } else if (aff.id === "camp_fever") {
          if (aff.stage === "incubation") {
            fatigue(-1.2, -0.6, -0.4);
          } else if (aff.stage === "acute") {
            fatigue(-(4 * aff.severity) / treatDivisor, -3, -3 - aff.severity);
            person.thirst = clamp(person.thirst - 2, 0, 100);
            conditionLoss += (0.9 * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            fatigue(0.6, 0.5, 0.5);
            conditionLoss += 0.2;
          }
        } else if (aff.id === "camp_scurvy") {
          if (aff.stage === "incubation") {
            fatigue(-0.6, -0.6, 0);
            conditionLoss += 0.25;
          } else if (aff.stage === "acute") {
            fatigue(-(2 * aff.severity), -2, 0);
            conditionLoss += (0.6 * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            fatigue(0.4, 0.6, 0);
            conditionLoss += 0.1;
          }
        } else if (aff.id === "mountain_pneumonia") {
          if (aff.stage === "incubation") {
            fatigue(-1, -0.5, -1);
          } else if (aff.stage === "acute") {
            fatigue(-(4 * aff.severity) / treatDivisor, -2, -(4 + aff.severity));
            conditionLoss += (1.1 * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            fatigue(0.6, 0.4, 0.5);
            conditionLoss += 0.2;
          }
        } else if (aff.id === "snakebite") {
          if (aff.stage === "incubation") {
            conditionLoss += 0.6;
            fatigue(-1.2, -1, 0);
          } else if (aff.stage === "acute") {
            conditionLoss += (1.6 * aff.severity) / treatDivisor;
            fatigue(-(2 * aff.severity), -2, 0);
          } else if (aff.stage === "recovery") {
            fatigue(0.5, 0.4, 0);
            conditionLoss += 0.25;
          }
        } else if (aff.id === "broken_bone") {
          if (aff.stage === "incubation") {
            conditionLoss += 0.8;
            fatigue(-2, -1, 0);
          } else if (aff.stage === "acute") {
            fatigue(-(3 * aff.severity), -2, 0);
            conditionLoss += (1.2 * aff.severity) / treatDivisor;
          } else if (aff.stage === "recovery") {
            fatigue(-0.5, 0.2, 0);
            conditionLoss += 0.35;
          }
        } else if (aff.id === "sprain") {
          if (aff.stage === "acute") {
            fatigue(-1, -0.8, 0);
            conditionLoss += 0.35 / treatDivisor;
          } else if (aff.stage === "recovery") {
            fatigue(-0.25, 0, 0);
          }
        }

        if (resting && aff.stage !== "acute") {
          aff.reliefHours = (aff.reliefHours || 0) + 0.2;
        }

        person.condition = clamp(person.condition - conditionLoss, 0, 100);

        const needsProgressLog =
          aff.stage === "acute" &&
          (aff.lastNotified == null || aff.hoursActive - aff.lastNotified >= 12);
        if (needsProgressLog) {
          aff.lastNotified = aff.hoursActive;
          if (aff.id === "dysentery" || aff.id === "cholera") {
            addLog(
              person.name +
                " is too weak to walk and rides in the wagon while the illness grips them."
            );
          } else if (aff.id === "camp_fever") {
            addLog(
              person.name +
                " burns with fever and needs tending; travel slows while they rest."
            );
          } else if (aff.id === "mountain_pneumonia") {
            addLog(
              person.name + " coughs through the night, lungs rattling in the cold air."
            );
          } else if (aff.id === "snakebite") {
            addLog(
              "Red streaks creep from the snakebite on " +
                person.name +
                "'s leg; careful tending might hold infection at bay."
            );
          } else if (aff.id === "broken_bone") {
            addLog(
              person.name +
                " winces with every rut; the bone will only mend with time and steady care."
            );
          } else if (aff.id === "sprain") {
            addLog(person.name + " keeps weight off a swollen ankle.");
          }
        }

        if (person.condition <= 0 && person.alive) {
          person.alive = false;
          addLog(
            person.name +
              " dies after a brutal bout of " +
              aff.label.toLowerCase() +
              " on the trail."
          );
          onPersonDeath(person);
        }
      });
    });
  }

  function maybeTriggerIllnessForHour() {
    const rng =
      (gameState.weatherSystem && gameState.weatherSystem.rng) || Math.random;
    const region = gameState.region;
    const w = gameState.weatherState || {};
    const ss = ensureStoryState();
    const tempC = typeof w.tempC === "number" ? w.tempC : 15;
    const hot = tempC >= 24;
    const wetRecently = w.precip === "rain" || gameState.recentRainHours > 24;
    const mouths = mouthsCount();
    const s = gameState.supplies || {};
    const waterGal = s.water || 0;
    const miles = gameState.milesTraveled || 0;
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    const waterQuality = gameState.waterQuality || "okay";
    const plan = gameState.waterPlan || { mode: "raw" };
    const boiled = plan.mode === "boil";
    const avgConditionEnergy = people.length
      ?
          people.reduce(function (sum, p) {
            return sum + ((p.condition || 0) + (p.energy || 0)) / 2;
          }, 0) / people.length
      : 100;

    ss.risk.bad_water = waterQuality === "risky" || waterQuality === "alkali";
    ss.risk.water_shortage = waterGal < mouths * 0.4;

    if (isCholeraCorridor(region, miles)) {
      let base = 0.00045;
      const qualityFactor =
        waterQuality === "good"
          ? 0.35
          : waterQuality === "okay"
          ? 0.65
          : waterQuality === "alkali"
          ? 2.0
          : 1.6; // risky/stagnant
      if (boiled) base *= 0.35;
      if (hot && wetRecently) base *= 1.5;
      if (ss.risk.water_shortage) base *= 1.4;
      if (avgConditionEnergy < 50) base *= 1.4;
      base *= qualityFactor;

      let newCase = false;
      people.some(function (p) {
        if (hasAffliction(p, "dysentery") || hasAffliction(p, "cholera"))
          return false;
        if (rng() < base * 0.35) {
          addAffliction(p, "cholera", { severity: 3 });
          newCase = true;
          return true;
        }
        if (rng() < base) {
          addAffliction(p, "dysentery", { severity: rng() < 0.35 ? 2 : 1 });
          newCase = true;
          return true;
        }
        return false;
      });
      if (newCase) return; // avoid multiple clustered cases in one hour
    }

    if (waterQuality === "alkali" && !isCholeraCorridor(region, miles)) {
      const target = choice(people);
      if (target && rng() < 0.0003 && !hasAffliction(target, "dysentery")) {
        addAffliction(target, "dysentery", { severity: 1 });
      }
    }

    const coldWet =
      tempC <= 5 || ((w.precip === "rain" && tempC < 10) || w.precip === "snow");
    if (gameState.mode === "camp" && coldWet) {
      const roughCamp =
        gameState.dayRhythm &&
        gameState.dayRhythm.eveningCampChoice === "rushed";
      people.forEach(function (p) {
        if (!p || hasAffliction(p, "camp_fever")) return;
        const warmthLow = p.warmth < 30;
        const energyLow = p.energy < 30;
        if (!warmthLow && !energyLow) return;
        let risk = 0.00032;
        if (warmthLow) risk *= 1.6;
        if (energyLow) risk *= 1.6;
        if (roughCamp) risk *= 1.3;
        if (rng() < risk) {
          addAffliction(p, "camp_fever", { severity: tempC <= 0 ? 2 : 1 });
        }
      });
    }

    if (gameState.region === "mountains" || gameState.region === "blue_mountains") {
      const highCold = tempC < 3 || (w.precip === "snow" && tempC < 8);
      if (highCold) {
        people.forEach(function (p) {
          if (hasAffliction(p, "mountain_pneumonia")) return;
          let risk = 0.00025;
          if (p.warmth < 35) risk *= 2.2;
          if (rng() < risk) addAffliction(p, "mountain_pneumonia", { severity: 2 });
        });
      }
    }

    if (gameState.region === "snake_plain" || gameState.region === "central_plains") {
      const biteRisk = w.tempC > 15 && gameState.mode === "travel" ? 0.00028 : 0;
      if (biteRisk > 0) {
        const walker = choice(people);
        if (walker && rng() < biteRisk && !hasAffliction(walker, "snakebite")) {
          addAffliction(walker, "snakebite", { severity: 2 });
        }
      }
    }

    if (gameState.wagonCondition < 55 && Math.random() < 0.0002) {
      const target = choice(people);
      if (target && !hasAffliction(target, "broken_bone")) {
        addAffliction(target, "broken_bone", { severity: 2 });
      }
    }
  }

  function useFood(itemId, person) {
    const cfg = FOOD_VALUES[itemId];
    if (!cfg) return false;

    const supplyItem = SUPPLY_ITEMS.find(function (s) {
      return s.id === itemId;
    });
    if (!supplyItem) return false;

    const stock = gameState.supplies[itemId] || 0;
    if (stock <= 0) return false;

    let perUnit = 1;
    if (
      supplyItem.category === "FOOD" ||
      supplyItem.category === "FOOD_PREPARED"
    ) {
      perUnit = supplyItem.weight || 1;
    }
    const neededUnits = cfg.lbsPerServing / perUnit;
    if (stock < neededUnits) return false;

    const lbsUsed = neededUnits * perUnit;
    gameState.supplies[itemId] = stock - neededUnits;
    consumeFromBatches(itemId, neededUnits);

    // NEW – long‑term diet tracking
    applyNutritionFromFood(itemId, lbsUsed);

    person.hunger = clamp(
      person.hunger + (cfg.hungerGain || 0),
      0,
      100
    );
    if (cfg.energyGain) {
      person.energy = clamp(
        person.energy + cfg.energyGain,
        0,
        110
      );
    }
    if (cfg.warmthGain) {
      person.warmth = clamp(
        person.warmth + cfg.warmthGain,
        0,
        100
      );
    }
    if (cfg.moraleGain != null) {
      person.morale = clamp(
        person.morale + cfg.moraleGain,
        0,
        100
    );
    } else if (cfg.isPrepared) {
      person.morale = clamp(person.morale + 3, 0, 100);
    } else {
      person.morale = clamp(person.morale + 1, 0, 100);
    }
    if (
      cfg.isPrepared &&
      (itemId === "meal_hearty" || itemId === "meal_feast") &&
      Math.random() < 0.45
    ) {
      addThought(person, {
        id: "hearty_meal",
        label: "Hearty meal",
        value: 5,
        hoursLeft: 12,
        source: "meal",
      });
    }
    return true;
  }

  function brewCoffeeWithMeal(block) {
    const s = gameState.supplies;
    let coffeeLbs = s.coffee || 0;
    if (coffeeLbs <= 0) {
      if (Math.random() < 0.18) {
        addLog(
          "Someone wishes aloud for coffee, but the coffee barrel has been empty for days."
        );
      }
      return;
    }

    const mouths = mouthsCount();
    if (mouths <= 0) return;

    const cupsPerLb = 20;
    const maxCups = Math.floor(coffeeLbs * cupsPerLb);
    if (maxCups <= 0) return;

    const cups   = Math.min(maxCups, mouths);
    const lbsUsed = cups / cupsPerLb;

    s.coffee = clamp(coffeeLbs - lbsUsed, 0, coffeeLbs);
    const coffeeAfter = s.coffee;
    applyNutritionFromFood("coffee", lbsUsed);

    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    people.forEach(function (p) {
      p.morale = clamp(p.morale + 1.5, 0, 100);
      p.energy = clamp(p.energy + 1.5, 0, 110);
      p.warmth = clamp(p.warmth + 0.5, 0, 100);
    });

    if (coffeeAfter <= 0.02 || coffeeAfter < coffeeLbs * 0.12) {
      addLog(
        "A pot of coffee is brewed and passed around the " +
          (block === "morning" ? "breakfast" : "evening") +
          " fire." +
          (coffeeAfter <= 0.02 ? " It's the last of the beans." : ""),
        { importance: coffeeAfter <= 0.02 ? 2 : 1 }
      );
    }
  }



  function rollSkillOutcome(person, taskId, difficulty, context) {
    ensurePersonDelegationFields(person);
    const skillTag = taskId === "repair" ? "repair" : taskId === "guard" ? "guard" : taskId === "craft" ? "craft" : taskId === "doctor" ? "doctoring" : taskId === "forage" ? "foraging" : taskId === "cook" ? "cooking" : taskId;
    const skill = (person.skills && person.skills[skillTag]) || 0;
    const moraleBonus = ((person.morale || 50) - 50) / 8;
    const fatiguePenalty = Math.max(0, 60 - (person.energy || 50)) / 6;
    const weather = context && context.weather ? context.weather : gameState.weatherState || {};
    const weatherPenalty = weather.storm ? 6 : weather.precip === "rain" ? 3 : 0;
    const base = skill * 10 + moraleBonus - fatiguePenalty - weatherPenalty;
    const luck = (Math.random() - 0.5) * 20;
    const target = (difficulty || 0) * 10;
    const score = base - target + luck;
    let outcome = "partial";
    if (score > 12) outcome = "success";
    else if (score < -8) outcome = "fail";
    return {
      outcome: outcome,
      roll: score,
      target: target,
      quality: score,
    };
  }

  function performCooking(person, context) {
    const ss = ensureStoryState();
    const s = gameState.supplies;
    let fuelBefore = (s.firewood || 0) + (s.buffalo_chips || 0);
    if (fuelBefore <= 0.05) {
      addLog(
        person.name +
          " tries to cook, but you have no dry wood or buffalo chips for a cooking fire."
      );
      return;
    }

    const skill    = person.skills.cooking || 1;
    const block    = getScheduleBlock(gameState.date);
    const rationId = gameState.rations || "filling";
    const wState   = gameState.weatherState || {};
    const wetFuel  =
      (gameState.recentRainHours || 0) > 8 ||
      wState.precip === "rain" ||
      wState.precip === "snow";
    const effort =
      context && context.campQuality === "proper" ? "proper" : "quick";

    const skillOutcome = rollSkillOutcome(person, "cook", effort === "proper" ? 1 : 0, {
      weather: wState,
    });

    // How many meals can we plausibly turn out in this hour?
    let maxMealsBase = 1 + skill;
    if (block === "evening") maxMealsBase += 1;
    if (effort === "proper") maxMealsBase += 1 + skill * 0.7;
    const maxMeals = clamp(maxMealsBase, 1, 10);

    // Fuel and burn chance tuned by fuel condition and effort.
    let fuelPerMeal   = effort === "proper" ? 0.25 : 0.18;
    let fuelAvailable = fuelBefore;

    let burnChance = 0.32 - skill * 0.05;
    burnChance -= skillOutcome.quality * 0.003;
    if (wetFuel) burnChance += 0.12;
    if (effort === "proper") burnChance -= 0.07;
    burnChance = clamp(burnChance, 0.06, 0.55);

    // Ration tier gates which recipes we're willing to attempt.
    let allowFeast  = rationId === "filling" || rationId === "normal";
    let allowHearty = rationId !== "barebones";
    if (effort === "quick" && block !== "evening") {
      // Breakfast / rushed camp → mostly quick fry‑ups.
      allowFeast  = false;
      allowHearty = rationId !== "barebones" && rationId !== "meager";
    }
    if (rationId === "meager") {
      // You can still splurge now and then, but it’s rare.
      if (Math.random() < 0.7) allowFeast = false;
    }

    const made = { meal_simple: 0, meal_hearty: 0, meal_feast: 0 };
    const recipeTally = {};
    let burnedMeals = 0;
    let preservedQty = 0;

    function haveLbs(id, lbs) {
      const item = SUPPLY_ITEMS.find(function (i) {
        return i.id === id;
      });
      if (!item) return false;
      const qty = gameState.supplies[id] || 0;
      const perUnit = item.weight || 1;
      return qty * perUnit >= lbs - 1e-4;
    }

    function takeLbs(id, lbs) {
      const item = SUPPLY_ITEMS.find(function (i) {
        return i.id === id;
      });
      if (!item) return false;
      const perUnit = item.weight || 1;
      const unitsNeeded = lbs / perUnit;
      const have = gameState.supplies[id] || 0;
      if (have < unitsNeeded - 1e-4) return false;
      gameState.supplies[id] = have - unitsNeeded;
      return true;
    }

    function haveIngredients(recipe) {
      if (!recipe.ingredients || !recipe.ingredients.length) return true;
      return recipe.ingredients.every(function (ing) {
        return haveLbs(ing.id, ing.lbs);
      });
    }

    function consumeIngredients(recipe) {
      if (!recipe.ingredients || !recipe.ingredients.length) return true;
      if (!haveIngredients(recipe)) return false;
      recipe.ingredients.forEach(function (ing) {
        takeLbs(ing.id, ing.lbs);
      });
      return true;
    }

    function recipeMatches(recipe) {
      if (!recipe) return false;
      if (recipe.tier === "meal_feast" && !allowFeast) return false;
      if (recipe.tier === "meal_hearty" && !allowHearty) return false;
      if (recipe.kind === "preserve") {
        if (effort !== "proper") return false;
        if ((gameState.supplies.fresh_meat || 0) < 3.5) return false;
      }
      if (recipe.blocks && recipe.blocks.length && recipe.blocks.indexOf(block) === -1) return false;
      if (recipe.regionTags && recipe.regionTags.length) {
        if (recipe.regionTags.indexOf(gameState.region) === -1) return false;
      }
      return haveIngredients(recipe);
    }

    function recipeWeight(recipe) {
      let w = recipe.weight || 1;
      if (recipe.regionTags && recipe.regionTags.indexOf(gameState.region) >= 0) w += 0.8;
      if (effort === "proper") w += 0.5;
      if (skillOutcome.outcome === "success") w += 0.4;
      if (recipe.tier === "meal_feast") w += skill * 0.35;
      return w;
    }

    function pickRecipe() {
      const candidates = RECIPE_DEFS.filter(function (r) {
        return recipeMatches(r);
      });
      if (!candidates.length) return null;
      const weighted = candidates.map(function (r) {
        return { def: r, weight: recipeWeight(r) };
      });
      const picked = weightedPick(weighted);
      return picked ? picked.def : candidates[0];
    }

    for (let i = 0; i < maxMeals; i++) {
      if (fuelAvailable < fuelPerMeal) break;
      const recipe = pickRecipe();
      if (!recipe) break;
      if (!consumeIngredients(recipe)) continue;
      fuelAvailable -= fuelPerMeal;
      const isPreserve = recipe.kind === "preserve";
      const burnRoll = !isPreserve && Math.random() < burnChance;
      if (burnRoll) {
        burnedMeals++;
        continue;
      }
      const method =
        recipe.preservationMethod || recipe.method || (recipe.kind === "preserve" ? "smoked" : "cooked");
      if (recipe.tier) {
        const yieldMeals = recipe.yieldMeals || 1;
        made[recipe.tier] += yieldMeals;
        registerFoodBatch(recipe.tier, yieldMeals, method, {
          recipeId: recipe.id,
          note: recipe.name,
        });
      }
      if (recipe.outputSupply) {
        const gain = recipe.outputQty || 1;
        gameState.supplies[recipe.outputSupply] =
          (gameState.supplies[recipe.outputSupply] || 0) + gain;
        preservedQty += gain;
        registerFoodBatch(recipe.outputSupply, gain, method, {
          recipeId: recipe.id,
          note: recipe.name,
        });
      }
      recipeTally[recipe.name] = (recipeTally[recipe.name] || 0) + 1;
    }

    const totalMeals = made.meal_simple + made.meal_hearty + made.meal_feast;

    if (totalMeals <= 0 && preservedQty <= 0) {
      if (fuelAvailable < fuelPerMeal) {
        addLog(
          person.name +
            " tends a smoky little fire, but there isn’t enough fuel or food for a proper hot meal."
        );
      } else {
        addLog(
          person.name +
            " works at the fire, but inexperience and thin stores mean little is fit to eat."
        );
      }
      return;
    }

    if (!s.meal_simple) s.meal_simple = 0;
    if (!s.meal_hearty) s.meal_hearty = 0;
    if (!s.meal_feast) s.meal_feast = 0;
    s.meal_simple += made.meal_simple;
    s.meal_hearty += made.meal_hearty;
    s.meal_feast += made.meal_feast;

    // Adjust fuel stores back into wood vs chips.
    const fuelUsed = fuelBefore - fuelAvailable;
    let use = fuelUsed;
    const useFromWood = Math.min(use, s.firewood || 0);
    s.firewood = (s.firewood || 0) - useFromWood;
    use -= useFromWood;
    if (use > 0) {
      const useFromChips = Math.min(use, s.buffalo_chips || 0);
      s.buffalo_chips = (s.buffalo_chips || 0) - useFromChips;
    }

    if (totalMeals > 0) {
      person.morale = clamp(person.morale + 2 + Math.round(skill / 2), 0, 100);
    }

    if (
      totalMeals > 0 &&
      (block === "morning" || block === "evening") &&
      (made.meal_hearty + made.meal_feast) > 0
    ) {
      brewCoffeeWithMeal(block);
    }

    // Build a flavorful description.
    let desc = "";
    const rLabel =
      rationId === "barebones"
        ? "scant"
        : rationId === "meager"
        ? "meager"
        : rationId === "normal"
        ? "steady"
        : "hearty";

    const recipeNames = Object.keys(recipeTally);
    const dishList = recipeNames.slice(0, 3).join(", ");
    if (totalMeals > 0) {
      if (dishList) {
        desc =
          "a " +
          rLabel +
          " meal of " +
          dishList +
          (recipeNames.length > 3 ? " and more from the pot" : "");
      } else if (block === "evening") {
        desc = "a " + rLabel + " supper from whatever could be coaxed from the larder";
      } else {
        desc = totalMeals + " hot serving" + (totalMeals > 1 ? "s" : "");
      }
    }
    if (preservedQty > 0) {
      desc += (desc ? "; " : "") + "some cuts are smoked for the road";
    }

    let burnDesc = "";
    if (burnedMeals > 0) {
      if (ss.lastHourTaskFailures) ss.lastHourTaskFailures.burnedMealById = person.id;
      if (wetFuel && skill <= 2) {
        burnDesc =
          " The damp chips smoke and sputter; a few biscuits end up scorched on the bottom and doughy on top.";
      } else {
        burnDesc =
          " A few portions are spoiled or burned in the rush.";
      }
    }

    if (skillOutcome.outcome === "success") {
      burnDesc += " The stew tastes better than usual; spirits lift.";
      const diners = getAllPeople().filter(function (p) {
        return p && p.alive;
      });
      diners.forEach(function (p) {
        p.morale = clamp(p.morale + 1, 0, 100);
      });
    } else if (skillOutcome.outcome === "fail") {
      burnDesc += " The meal is thin and smoky—some food is wasted.";
      if (ss.lastHourTaskFailures) ss.lastHourTaskFailures.burnedMealById = person.id;
    }

    const servingsLabel = totalMeals > 0
      ? " (" +
        totalMeals +
        " serving" +
        (totalMeals > 1 ? "s" : "") +
        " prepared)"
      : "";

    const notable =
      burnedMeals > 0 ||
      skillOutcome.outcome !== "partial" ||
      totalMeals <= 0 ||
      preservedQty > 0;
    addLog(person.name + " cooks for the camp: " + desc + servingsLabel + "." + burnDesc, {
      importance: notable ? 1 : 0,
    });
  }


  function performHunt(person) {
    const ammoBoxes = gameState.supplies.ammo || 0;
    const rifles = gameState.supplies.rifles || 0;
    if (ammoBoxes <= 0 || rifles <= 0) {
      addLog(
        person.name +
          " goes hunting but you are short on arms or ammunition."
      );
      return;
    }

    const bullets = ammoBoxes * 20;
    const shots = Math.min(10, bullets);
    const skill = person.skills.hunting || 1;
    const local = getLocalResourceProfile();
    const envNote = local.tags && local.tags.length ? " (" + local.tags[0] + ")" : "";

    const abundance = clamp(0.5 + (local.game || 0.3), 0.35, 1.6);
    const regionBase =
      (gameState.region === "plains"
        ? 0.22
        : gameState.region === "central_plains"
        ? 0.28
        : gameState.region === "snake_plain"
        ? 0.18
        : 0.16) * abundance;

    let meat = 0;
    for (let i = 0; i < shots; i++) {
      if (Math.random() < regionBase + skill * 0.03) {
        meat += randFloat(4, 18);
      }
    }

    const inefficiency = skill <= 1 ? 1.3 : skill >= 4 ? 0.8 : 1.0;
    const usedBullets = Math.min(Math.round(shots * inefficiency), bullets);
    const boxesUsed = usedBullets / 20;
    gameState.supplies.ammo = Math.max(0, ammoBoxes - boxesUsed);

    if (meat > 0) {
      gameState.supplies.fresh_meat =
        (gameState.supplies.fresh_meat || 0) + meat;
      registerFoodBatch("fresh_meat", meat, "raw", { note: "hunting" });
      person.morale = clamp(person.morale + 4, 0, 100);
      addLog(
        person.name +
          " brings back about " +
          Math.round(meat) +
          " lb of fresh game" +
          envNote +
          "."
      );
    } else {
      addLog(person.name + " returns from the hunt empty-handed" + envNote + ".");
    }

    const injuryChance = clamp(0.08 - skill * 0.012, 0.02, 0.08);
    if (Math.random() < injuryChance) {
      person.condition = clamp(person.condition - 8, 0, 100);
      addAffliction(person, "sprain", { severity: 1 });
      addLog(
        person.name + " twists an ankle scrambling over rough ground and limps back to camp."
      );
    }
  }

  function performGatherWood(person) {
    const local = getLocalResourceProfile();
    const yieldBase =
      (gameState.region === "plains"
        ? 4
        : gameState.region === "central_plains"
        ? 6
        : gameState.region === "blue_mountains"
        ? 10
        : 5);
    const richness = clamp(0.45 + (local.wood || 0.25) * 0.9, 0.3, 1.5);
    const skill = person.skills.woodcutting || 1;
    const bundles = yieldBase * richness * (0.3 + skill * 0.2);
    const envNote = local.tags && local.tags.length ? " (" + local.tags[0] + ")" : "";
    if (!gameState.supplies.firewood) gameState.supplies.firewood = 0;
    gameState.supplies.firewood += bundles * 0.2;

    if (
      gameState.region === "plains" ||
      gameState.region === "central_plains"
    ) {
      if (!gameState.supplies.buffalo_chips)
        gameState.supplies.buffalo_chips = 0;
      const chipRichness = clamp(0.7 + (local.forage || 0.2), 0.4, 1.4);
      gameState.supplies.buffalo_chips += bundles * 0.3 * chipRichness;
    }

    addLog(
      person.name +
        " gathers fuel around camp — enough for a couple of fires if kept dry." +
        envNote
    );

    const mishapChance = clamp(0.05 - skill * 0.01, 0.01, 0.05);
    if (Math.random() < mishapChance) {
      person.condition = clamp(person.condition - 5, 0, 100);
      addLog(
        person.name +
          " nicks a hand on rough wood, but the injury is minor."
      );
    }
  }

  function performFetchWater(person) {
    const ss = ensureStoryState();
    const local = getLocalResourceProfile();
    let factor = Math.max(0.25, 0.5 * (0.6 + (local.water || 0.2)));
    const name = gameState.locationName.toLowerCase();
    let quality = local.waterQualityHint || "stagnant";
    let qualityTag = quality === "river" ? "good" : quality === "alkali" ? "alkali" : "risky";
    const envNote = local.tags && local.tags.length ? " (" + local.tags[0] + ")" : "";
    if (
      name.indexOf("river") >= 0 ||
      name.indexOf("ford") >= 0 ||
      name.indexOf("creek") >= 0 ||
      name.indexOf("falls") >= 0 ||
      name.indexOf("springs") >= 0
    ) {
      factor = Math.max(factor, 1.0 * (0.7 + (local.water || 0.3)));
      quality = "running";
      qualityTag = "good";
    } else if (
      gameState.region === "snake_plain" ||
      gameState.region === "mountains"
    ) {
      factor = Math.max(factor, 0.6 * (0.6 + (local.water || 0.3)));
      quality = quality === "river" ? quality : "alkali";
      qualityTag = quality === "river" ? "good" : "alkali";
    } else if (gameState.region === "blue_mountains") {
      factor = Math.max(factor, 0.8 * (0.7 + (local.water || 0.3)));
      quality = "cold_stream";
      qualityTag = "good";
    }
    if (local.tags && local.tags.indexOf("Sublette desert stretch") >= 0) {
      factor *= 0.6;
      quality = "alkali";
      qualityTag = "alkali";
    }

    if (
      local.tags &&
      local.tags.indexOf("Black Rock / High Rock waterless stretch") >= 0
    ) {
      factor *= 0.55;
      quality = "alkali";
      qualityTag = "alkali";
    }

    if (local.tags && local.tags.indexOf("Big Sandy basin") >= 0) {
      factor *= 0.8;
    }

    const dayKey = getDayKey(gameState.date || new Date());
    if (!gameState.waterPlan || gameState.waterPlan.dayKey !== dayKey) {
      gameState.waterPlan = {
        dayKey: dayKey,
        mode: (gameState.waterPlan && gameState.waterPlan.mode) || "boil",
      };
    }

    const boil = gameState.waterPlan && gameState.waterPlan.mode === "boil";
    if (boil) {
      factor *= 0.85;
      if (gameState.supplies.firewood && gameState.supplies.firewood > 0) {
        gameState.supplies.firewood = Math.max(0, gameState.supplies.firewood - 0.25);
      }
      gameState.lastWaterBoiled = true;
      addThought(person, {
        id: "water_boiled",
        label: "Boiled water",
        value: 2,
        hoursLeft: 8,
      });
      addLog(
        person.name +
          " boils water despite the late hour; the camp breathes easier knowing illness risk drops."
      );
    } else {
      factor *= 1.05;
      gameState.lastWaterBoiled = false;
      if (ss.lastHourTaskFailures) ss.lastHourTaskFailures.riskyWaterById = person.id;
      addThought(person, {
        id: "water_risky",
        label: "Drank questionable water",
        value: -2,
        hoursLeft: 6,
      });
      addLog(
        person.name +
          " draws water quickly from a questionable source, hoping to save time and fuel."
      );
    }

    const gallons = 3 * factor;
    if (!gameState.supplies.water) gameState.supplies.water = 0;
    gameState.supplies.water += gallons;
    gameState.waterQuality = qualityTag;
    gameState.lastWaterSourceType = quality;
    if (ss.lastHourTaskFailures && qualityTag === "alkali") {
      ss.lastHourTaskFailures.alkaliWaterById = person.id;
    }
    addLog(
      person.name +
        " hauls water for camp — about " +
        gallons.toFixed(1) +
        " gallons." +
        envNote
    );
  }

  async function ensureWaterPlanForDay() {
    const dayKey = getDayKey(gameState.date || new Date());
    if (gameState.waterPlan && gameState.waterPlan.dayKey === dayKey) return;
    const choice = await presentEncounter({
      id: "water_plan_" + dayKey,
      title: "Water for the day",
      subtitle: formatDateTime(gameState.date) + " · " + gameState.locationName,
      body: [
        "You can boil the day's water, burning a little fuel but lowering illness risk, or draw it quickly and hope for the best.",
      ],
      tags: ["water", "camp"],
      options: [
        {
          id: "boil",
          label: "Boil today's water",
          tone: "warm",
          hint: "Safer stomachs; costs a bit of fuel and time.",
        },
        {
          id: "raw",
          label: "Draw it quick",
          tone: "danger",
          hint: "Saves fuel and effort but risks sickness.",
        },
      ],
      defaultId: (gameState.waterPlan && gameState.waterPlan.mode) || "boil",
    });
    gameState.waterPlan = { dayKey: dayKey, mode: choice === "raw" ? "raw" : "boil" };
    addLog(
      choice === "raw"
        ? "You skip boiling to save fuel; everyone keeps an eye on the kettles."
        : "You commit to boiling the day's water, trading wood for safer bellies.",
      { tone: "info" }
    );
  }

  function performRepair(person) {
    const ss = ensureStoryState();
    const hasParts =
      (gameState.supplies.wheels || 0) +
        (gameState.supplies.axles || 0) +
        (gameState.supplies.tongues || 0) >
      0;
    const skill = person.skills.repair || person.skills.woodcutting || 1;
    const outcome = rollSkillOutcome(person, "repair", hasParts ? 1 : 0, {
      weather: gameState.weatherState,
    });
    let gain = hasParts ? 4 + skill * 1.5 : 2 + skill;
    if (outcome.outcome === "success") gain += 2;
    if (outcome.outcome === "fail") gain = Math.max(1, gain * 0.5);
    gameState.wagonCondition = clamp(
      gameState.wagonCondition + gain,
      0,
      100
    );
    if (ss.lastHourTaskFailures && outcome.outcome === "fail") {
      ss.lastHourTaskFailures.badRepairById = person.id;
    }
    addLog(
      person.name +
      " spends the hour tightening bolts, checking wheels, and greasing the wagon." +
        (outcome.outcome === "fail"
          ? " A few fixes don't hold; more work will be needed."
          : outcome.outcome === "success"
          ? " The repairs feel solid and sure."
          : "")
    );
  }

  function performDoctoring(person) {
    const patients = getAllPeople()
      .filter(function (p) {
        return (
          p &&
          p.alive &&
          p.afflictions &&
          p.afflictions.some(function (a) {
            return a && !a.resolved && a.stage !== "resolved";
          })
        );
      })
      .sort(function (a, b) {
        function score(p) {
          const severe = p.afflictions.filter(function (a) {
            return a && !a.resolved && a.stage === "acute";
          });
          const crisis = severe.reduce(function (sum, a) {
            return sum + (a.crisisThreshold || 20) - (p.condition || 50);
          }, 0);
          return crisis;
        }
        return score(b) - score(a);
      });
    if (!patients.length) {
      if (Math.random() < 0.2) {
        addLog(person.name + " checks everyone over; no one needs tending right now.");
      }
      return;
    }
    const target = patients[0];
    const skill = (person.skills && person.skills.doctoring) || 0;
    const outcome = rollSkillOutcome(person, "doctor", 1, { weather: gameState.weatherState });
    const hasMedicine = (gameState.supplies && gameState.supplies.med_kits) > 0;
    let relief = 0.4 + skill * 0.25;
    if (outcome.outcome === "success") relief += 0.6;
    if (outcome.outcome === "fail") relief *= 0.6;
    let usedMedicine = false;
    target.afflictions.forEach(function (aff) {
      if (!aff || aff.resolved) return;
      aff.reliefHours = (aff.reliefHours || 0) + relief;
      aff.tendedThisHour = true;
      if (hasMedicine && !aff.medicineUsed && aff.severity >= 2) {
        gameState.supplies.med_kits = Math.max(
          0,
          (gameState.supplies.med_kits || 0) - 1
        );
        aff.medicineUsed = true;
        usedMedicine = true;
      }
      if (aff.severity > 1 && Math.random() < 0.15 + skill * 0.05) {
        aff.severity = Math.max(1, aff.severity - 1);
      }
    });

    if (!gameState.doctoringThisHour) gameState.doctoringThisHour = [];
    gameState.doctoringThisHour.push({
      doctor: person,
      patient: target,
      usedMedicine: usedMedicine,
    });

    addLog(
      person.name +
        " tends to " +
        target.name +
        (usedMedicine
          ? " with splints and precious medicine."
          : " with cloths, rest, and steady hands.") +
        (outcome.outcome === "fail"
          ? " The care steadies things but no real improvement comes."
          : outcome.outcome === "success"
          ? " The patient seems better already."
          : ""),
      { characters: [person.id, target.id], tone: "event" }
    );
  }

  function performTask(person, taskIdOverride, context) {
    if (!person || !person.alive) return;

    const ss = ensureStoryState();
    const w = gameState.weatherState || {};
    const rationCfg = RATION_CONFIG[gameState.rations] || RATION_CONFIG.filling;

    let hungerDrain = rationCfg.hungerDrainPerHour;
    let thirstDrain = rationCfg.thirstDrainPerHour;
    let energyDrain = 2.0;

    const task = taskIdOverride || person.task || "travel";
    const isTravelMode = gameState.mode === "travel";

    const workTask =
      task === "travel" ||
      task === "scout" ||
      task === "hunt" ||
      task === "gather_wood" ||
      task === "repair";

    // Extra strain for active work
    if (workTask) {
      hungerDrain += 0.6;
      thirstDrain += 0.6;
      energyDrain += 1.2;
    }

    const hexMods = getHexWorldModifiers(getPlayerHexFromMiles());

    // Weather effects on drains
    if (w.tempC >= 28) {
      thirstDrain += 1.2;
      hungerDrain += 0.4;
    } else if (w.tempC <= 0) {
      hungerDrain += 0.3;
    }

    if (hexMods.inSubletteDesert) {
      thirstDrain += 0.9;
      energyDrain += 0.3;
    } else if (hexMods.atBigSandy) {
      thirstDrain += 0.35;
    }

    // Apply drains
    person.hunger = clamp(person.hunger - hungerDrain, 0, 100);
    person.thirst = clamp(person.thirst - thirstDrain, 0, 100);
    person.energy = clamp(person.energy - energyDrain, 0, 100);

    // Skill XP by doing
    if (task === "travel" || task === "scout") {
      gainSkillXP(person, "travel", 1);
    } else if (task === "hunt") {
      gainSkillXP(person, "hunting", 1.2);
    } else if (task === "cook") {
      gainSkillXP(person, "cooking", 1.1);
    } else if (task === "gather_wood" || task === "repair") {
      gainSkillXP(person, "woodcutting", 1);
    } else if (task === "guard") {
      gainSkillXP(person, "travel", 0.5);
    }
    noteTaskHistory(person, task);

    // Task-specific effects
    if (task === "travel" && isTravelMode) {
      const paceCfg = PACE_CONFIG[gameState.pace] || PACE_CONFIG.steady;
      person.energy = clamp(
        person.energy - (paceCfg.staminaCost || 4) * 0.4,
        0,
        100
      );
    } else if (task === "scout" && isTravelMode) {
      person.energy = clamp(person.energy - 3, 0, 100);
      if (Math.random() < 0.05) {
        addLog(person.name + " scouts ahead and spots a better ford.");
        gameState.wagonCondition = clamp(gameState.wagonCondition + 1, 0, 100);
      }
    } else if (task === "hunt") {
      person.energy = clamp(person.energy - 4, 0, 100);
      if (ss.lastHourCampTasks) ss.lastHourCampTasks.huntedById = person.id;
      performHunt(person);
    } else if (task === "gather_wood") {
      person.energy = clamp(person.energy - 3.5, 0, 100);
      performGatherWood(person);
    } else if (task === "fetch_water") {
      person.energy = clamp(person.energy - 3, 0, 100);
      if (ss.lastHourCampTasks) ss.lastHourCampTasks.fetchedWaterById = person.id;
      performFetchWater(person);
    } else if (task === "cook") {
      person.energy = clamp(person.energy - 2.5, 0, 100);
      // IMPORTANT: pass context so camp-quality & meal macros work
      if (ss.lastHourCampTasks) ss.lastHourCampTasks.cookedById = person.id;
      performCooking(person, context || null);
    } else if (task === "repair") {
      person.energy = clamp(person.energy - 3, 0, 100);
      if (ss.lastHourCampTasks) ss.lastHourCampTasks.repairedById = person.id;
      performRepair(person);
    } else if (task === "guard") {
      person.energy = clamp(person.energy - 2, 0, 100);
      const guardOutcome = rollSkillOutcome(person, "guard", 1, {
        weather: gameState.weatherState,
      });
      const guardGain = guardOutcome.outcome === "success" ? 0.8 : guardOutcome.outcome === "fail" ? 0.3 : 0.5;
      gameState.guardLevel += guardGain;
      if (ss.lastHourCampTasks && ss.lastHourCampTasks.guardedByIds) {
        ss.lastHourCampTasks.guardedByIds.push(person.id);
      }
      if (guardOutcome.outcome === "fail" && Math.random() < 0.3) {
        addLog(person.name + " struggles to stay awake on watch.", { tone: "warning" });
      }
    } else if (task === "doctor") {
      person.energy = clamp(person.energy - 2, 0, 100);
      person.morale = clamp(person.morale + 0.5, 0, 100);
      performDoctoring(person);
    } else if (task === "rest") {
      person.energy = clamp(person.energy + 4, 0, 100);
      person.morale = clamp(person.morale + 1, 0, 100);
    } else if (task === "sleep") {
      if (isNight(gameState.date)) {
        person.energy = clamp(person.energy + 10, 0, 110);
        person.morale = clamp(person.morale + 2, 0, 100);
      } else {
        person.energy = clamp(person.energy + 2, 0, 100);
      }
    }

    // Warmth changes after the hour’s work/rest
    let warmthDelta = -0.4;
    if (w.precip === "snow" || w.tempC <= -2) warmthDelta -= 2.0;
    if (w.precip === "rain" && w.tempC < 8)  warmthDelta -= 1.5;
    if (w.precip === "rain" && w.tempC >= 8) warmthDelta -= 0.5;
    if (w.tempC >= 26)                        warmthDelta += 2.0;

    if (task === "cook" || task === "rest" || (task === "sleep" && !isTravelMode)) {
      warmthDelta += 0.6; // by the fire / wrapped up
    } else if (task === "scout" || task === "hunt") {
      warmthDelta -= 0.4;
    }

    person.warmth = clamp(person.warmth + warmthDelta, 0, 100);

    // Auto-eating & drinking to hit ration targets
    autoConsumeFor(person);

    const avgNeeds =
      (person.hunger + person.thirst + person.warmth + person.energy) / 4;
    const moodDelta = avgNeeds < 40 ? -2 : avgNeeds > 80 ? 1.5 : 0;
    person.morale = clamp(person.morale + moodDelta, 0, 100);

    person.condition = clamp(
      0.15 * person.hunger +
        0.15 * person.thirst +
        0.25 * person.energy +
        0.15 * person.warmth +
        0.3  * person.morale,
      0,
      100
    );

    if (person.condition <= 0 && person.alive) {
      person.alive = false;
      addLog(person.name + " dies on the trail.");
      onPersonDeath(person);
    }
  }



  function updateAdvanceControlsDisabled() {
    const disabled = isAdvancingTime || encounterActive;
    const buttons = [
      dom.btnAdvance1,
      dom.btnAdvance4,
      dom.btnTravel1h,
      dom.btnTravel4h,
      dom.btnAutoTravel,
      dom.btnEveningProperCamp,
      dom.btnEveningRushedCamp,
      dom.btnCampConfirm,
      dom.btnCampAuto,
      dom.btnCampfireMoment,
    ];
    buttons.forEach(function (btn) {
      if (btn) btn.disabled = disabled;
    });
    refreshCampfireButton();
  }

  function withAdvanceLock(fn) {
    if (isAdvancingTime) return Promise.resolve();
    isAdvancingTime = true;
    updateAdvanceControlsDisabled();
    return Promise.resolve()
      .then(fn)
      .catch(function (err) {
        console.error(err);
      })
      .finally(function () {
        isAdvancingTime = false;
        updateAdvanceControlsDisabled();
      });
  }

  function buildEncounterInterjections(tags) {
    const tagSet = Array.isArray(tags) ? tags : [];
    const people = getAllPeople()
      .filter(function (p) {
        return p && p.alive;
      })
      .sort(function (a, b) {
        return (b.morale || 0) - (a.morale || 0);
      });
    const lines = [];

    function lineFor(person) {
      const traits = person.traits || [];
      const skills = person.skills || {};
      const hasTag = function (t) {
        return tagSet.indexOf(t) >= 0;
      };
      if (traits.indexOf("Merciful") >= 0 && (hasTag("mercy") || hasTag("injury"))) {
        return (
          person.name +
          " whispers that leaving them would weigh on the party's conscience."
        );
      }
      if (traits.indexOf("Hard") >= 0 && (hasTag("bandit") || hasTag("trade"))) {
        return person.name + " reminds you the trail rewards those who hold their own line.";
      }
      if (traits.indexOf("Cowardly") >= 0 && hasTag("danger")) {
        return person.name + " urges caution, eyes on the shadows beyond the wagons.";
      }
      if (traits.indexOf("Pious") >= 0 && (hasTag("mercy") || hasTag("camp"))) {
        return (
          person.name +
          " fingers a keepsake and says the right choice keeps the party's soul intact."
        );
      }
      if (traits.indexOf("Reckless") >= 0 && (hasTag("shortcut") || hasTag("danger"))) {
        return person.name + " grins, eager to take the bold path while nerves are hot.";
      }
      if (traits.indexOf("Wry") >= 0) {
        return person.name + " quips that this will make a story—one way or another.";
      }
      if ((skills.doctoring || 0) >= 3 && (hasTag("injury") || hasTag("mercy"))) {
        return (
          person.name +
          " notes they can spare a poultice, but warns every bandage counts this far out."
        );
      }
      if ((skills.guard || 0) >= 3 && hasTag("bandit")) {
        return person.name + " scans the horizon, promising to keep rifles close if talk goes bad.";
      }
      if ((skills.travel || 0) >= 3 && hasTag("shortcut")) {
        return (
          person.name +
          " weighs the terrain and says the detour could shave time—if the team holds together."
        );
      }
      if ((skills.cooking || 0) >= 3 && hasTag("camp")) {
        return person.name + " suggests a calm fire and a song might lift spirits before the push.";
      }
      return person.name + " waits for your nod, eyes searching yours for the call.";
    }

    people.slice(0, 4).forEach(function (p) {
      if (lines.length >= 2) return;
      lines.push(lineFor(p));
    });
    return lines.slice(0, 2);
  }

  function renderEncounterModal(cfg) {
    if (!dom.encounterModal) return;
    dom.encounterTitle.textContent = cfg.title || "Encounter";
    dom.encounterSubtitle.textContent = cfg.subtitle || formatDateTime(gameState.date);

    dom.encounterBody.innerHTML = "";
    const bodyParts = Array.isArray(cfg.body)
      ? cfg.body
      : String(cfg.body || "")
          .split(/\n\s*\n/)
          .map(function (t) {
            return t.trim();
          })
          .filter(Boolean);
    if (!bodyParts.length && cfg.body) bodyParts.push(String(cfg.body));
    if (!bodyParts.length) bodyParts.push("No details.");
    bodyParts.forEach(function (line) {
      const p = document.createElement("p");
      p.textContent = line;
      dom.encounterBody.appendChild(p);
    });

    if (dom.encounterImage) {
      if (cfg.imageUrl) {
        dom.encounterImage.style.display = "block";
        dom.encounterImage.style.backgroundImage =
          "linear-gradient(to bottom, rgba(0,0,0,.35), rgba(0,0,0,.6)), url('" + cfg.imageUrl + "')";
      } else {
        dom.encounterImage.style.display = "none";
      }
    }

    const companionLines = buildEncounterInterjections(cfg.tags || cfg.contextTags || []);
    if (dom.encounterCompanions) {
      dom.encounterCompanions.innerHTML = "";
      if (companionLines.length) {
        dom.encounterCompanions.style.display = "grid";
        companionLines.forEach(function (line) {
          const div = document.createElement("div");
          div.textContent = line;
          dom.encounterCompanions.appendChild(div);
        });
      } else {
        dom.encounterCompanions.style.display = "none";
      }
    }

    dom.encounterOptions.innerHTML = "";
    const opts = (cfg.options && cfg.options.length ? cfg.options : null) || [
      { id: cfg.defaultId || "close", label: "Close" },
    ];
    encounterOptionsEls = [];
    opts.forEach(function (opt, idx) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "ot-encounter-btn";
      if (opt.tone === "warm") btn.classList.add("ot-encounter-tone-warm");
      else if (opt.tone === "danger") btn.classList.add("ot-encounter-tone-danger");
      else if (opt.tone === "neutral") btn.classList.add("ot-encounter-tone-neutral");
      btn.dataset.id = opt.id || idx;
      btn.textContent = opt.label || opt.id || "Choose";
      if (opt.hint) {
        const hint = document.createElement("span");
        hint.className = "ot-encounter-hint";
        hint.textContent = opt.hint;
        btn.appendChild(hint);
      }
      btn.addEventListener("click", function () {
        resolveEncounterChoice(btn.dataset.id || encounterDefaultOption);
      });
      dom.encounterOptions.appendChild(btn);
      encounterOptionsEls.push(btn);
    });
  }

  function resolveEncounterChoice(choiceId) {
    if (!encounterResolver) return;
    encounterOptionsEls.forEach(function (b) {
      b.disabled = true;
    });
    if (dom.encounterModal) {
      dom.encounterModal.classList.remove("active");
      dom.encounterModal.setAttribute("aria-hidden", "true");
    }
    if (dom.encounterModal && encounterKeyHandler) {
      dom.encounterModal.removeEventListener("keydown", encounterKeyHandler);
    }
    encounterKeyHandler = null;
    setEncounterActive(false);
    if (lastFocusedBeforeEncounter && lastFocusedBeforeEncounter.focus) {
      setTimeout(function () {
        lastFocusedBeforeEncounter.focus();
      }, 80);
    }
    const resolver = encounterResolver;
    encounterResolver = null;
    pendingEncounterId = null;
    resolver(choiceId || encounterDefaultOption || null);
  }

  function setEncounterActive(active) {
    encounterActive = !!active;
    updateAdvanceControlsDisabled();
  }

  function presentEncounter(cfg) {
    if (!dom.encounterModal) {
      return Promise.resolve((cfg && cfg.defaultId) || null);
    }
    ensureReputationState();
    return new Promise(function (resolve) {
      encounterResolver = resolve;
      encounterDefaultOption =
        (cfg && cfg.defaultId) ||
        (cfg && cfg.options && cfg.options[0] ? cfg.options[0].id : null);
      encounterAllowEscape = !!(cfg && cfg.allowEscape);
      pendingEncounterId = cfg && cfg.id;
      renderEncounterModal(cfg || {});
      setEncounterActive(true);
      dom.encounterModal.classList.add("active");
      dom.encounterModal.setAttribute("aria-hidden", "false");
      lastFocusedBeforeEncounter = document.activeElement;
      if (encounterKeyHandler && dom.encounterModal) {
        dom.encounterModal.removeEventListener("keydown", encounterKeyHandler);
      }
      encounterKeyHandler = function (evt) {
        if (evt.key === "Escape" && encounterAllowEscape) {
          evt.preventDefault();
          resolveEncounterChoice(encounterDefaultOption);
        }
        if (evt.key === "Tab" && encounterOptionsEls.length) {
          const focusable = encounterOptionsEls.filter(function (b) {
            return !b.disabled;
          });
          if (!focusable.length) return;
          const first = focusable[0];
          const last = focusable[focusable.length - 1];
          if (evt.shiftKey && document.activeElement === first) {
            evt.preventDefault();
            last.focus();
          } else if (!evt.shiftKey && document.activeElement === last) {
            evt.preventDefault();
            first.focus();
          }
        }
      };
      if (dom.encounterModal) {
        dom.encounterModal.addEventListener("keydown", encounterKeyHandler);
      }
      setTimeout(function () {
        if (encounterOptionsEls[0]) encounterOptionsEls[0].focus();
        else if (dom.encounterContent && dom.encounterContent.focus) dom.encounterContent.focus();
      }, 30);
    });
  }

  async function advanceOneHour(context) {
    const ss = ensureStoryState();
    const milesBefore = gameState.milesTraveled || 0;
    gameState.date = new Date(gameState.date.getTime() + 60 * 60 * 1000);

    ss.lastHourCampTasks = {
      guardedByIds: [],
      cookedById: null,
      fetchedWaterById: null,
      repairedById: null,
      huntedById: null,
    };
    ss.lastHourTaskFailures = {};
    coolLeadershipDisputeState();

    // Track daily rhythm and diet per calendar day
    ensureDayRhythmForDate(gameState.date);
    ensureNutritionForDate(gameState.date);
    await ensureWaterPlanForDay();

    refreshWeather();
    gameState.guardLevel = 0;
    gameState.doctoringThisHour = [];

    const people = getAllPeople();
    const resolvedTasks = resolveTasksForHour();

    people.forEach(function (p, idx) {
      if (!p) return;
      const plan = gameState.campPlan;
      const planHour =
        plan && typeof plan.startHour === "number"
          ? gameState.date.getHours() - plan.startHour
          : null;
      let plannedTask = null;
      if (plan && plan.people && planHour != null && planHour >= 0) {
        const entry = plan.people.find(function (row) {
          return row.personId === p.id;
        });
        if (entry && entry.timeline) {
          const slot = entry.timeline.find(function (t) {
            return t.hourOffset === planHour;
          });
          plannedTask = slot ? slot.taskId : null;
        }
      }
      const t = plannedTask || (resolvedTasks && resolvedTasks[idx] ? resolvedTasks[idx] : p.task || "travel");
      performTask(p, t, context);
    });

    if (ss.eventFlags && ss.eventFlags.forcedCampHours > 0) {
      gameState.mode = "camp";
      ss.eventFlags.forcedCampHours -= 1;
    }

    const miles = gameState.mode === "camp" ? 0 : computeMilesForHour();
    gameState.lastHourMiles = miles;
    gameState.milesTraveled = clamp(
      gameState.milesTraveled + miles,
      0,
      gameState.targetMiles
    );
    clampMilesToDestination(milesBefore);

    updateDayRhythmForCurrentHour(miles);

    if (context && context.campQuality) {
      applyCampQualityEffects(context);
    }

    updateRegionAndLocation();
    handleDestinationArrival();
    if (gameState.traillines) {
      gameState.traillines.fogMaxMile = Math.max(
        gameState.traillines.fogMaxMile || 0,
        gameState.milesTraveled || 0
      );
    }
    tickAfflictionsForHour();
    maybeTriggerIllnessForHour();
    updateNeedsAndMoodForHour();
    maybeRunDailySocialMoments();
    updateSpoilageForHour();
    showCompanionThoughtForHour();
    maybeSecretDrift(context);
    await eventDirectorTick();

    if (gameState.milesTraveled >= gameState.targetMiles) {
      addLog(
        "After months on the trail, your wagon rolls into Oregon City to the cheers of other emigrants."
      );
      recordStoryBeat("arrival", "route", "Reached Oregon City", {});
      gameState.runEnded = gameState.runEnded || { reason: "arrival" };
    }
  }

  async function advanceHours(count, context) {
    // Ensure at least 1 hour, and make sure it's an integer
    count = count || 1;
    count = count < 1 ? 1 : Math.floor(count);

    for (let i = 0; i < count; i++) {
      await advanceOneHour(context);
    }

    // After the block of time, persist and redraw
    saveGame();
    renderAll();
  }

  async function advanceHoursTowardDestination(count) {
    count = count || 1;
    count = Math.max(1, Math.min(12, Math.floor(count)));
    if (gameState.mode !== "travel") {
      gameState.mode = "travel";
      resetTasksForCurrentMode();
    }
    for (let i = 0; i < count; i++) {
      const remaining = remainingMilesToDestination();
      if (remaining !== null && remaining <= 0) break;
      await advanceOneHour({ reason: "map_target_travel" });
      if (isDestinationReached()) break;
      if (gameState.mode !== "travel") break;
      if (gameState.runEnded) break;
    }
    saveGame();
    renderAll();
  }

  async function beginAutoTravelToDestination() {
    ensureHexMapState();
    if (!gameState.hexMap.destination || !gameState.hexMap.destination.destKey) {
      addLog("Set a destination on the trail before auto-traveling.");
      return;
    }
    if (gameState.mode !== "travel") {
      gameState.mode = "travel";
      resetTasksForCurrentMode();
      addLog("You set the team toward the marked waypoint.");
    }
    await advanceHoursTowardDestination(12);
  }



  function maybeRandomEvent() {
    const r = Math.random();
    const w = gameState.weatherState || {};
    const loc = gameState.locationName.toLowerCase();

    if (
      (loc.indexOf("river") >= 0 || loc.indexOf("ford") >= 0) &&
      (w.precip === "rain" || gameState.recentRainHours > 18)
    ) {
      const riverRisk = gameState.highRiverRisk ? 0.12 : 0.07;
      if (r < riverRisk) {
        const lost = Math.min(gameState.lastHourMiles || 0, 1.5);
        gameState.milesTraveled = clamp(
          gameState.milesTraveled - lost,
          0,
          gameState.targetMiles
        );
        addLog(
          "High water at " +
            gameState.locationName +
            " forces you to wait and scout for a safer crossing." +
            (gameState.highRiverRisk
              ? " Spring runoff from the early start keeps the current fierce."
              : "")
        );
        return;
      }
    }

    if (r < 0.02 && gameState.wagonCondition < 75) {
      gameState.wagonCondition = clamp(gameState.wagonCondition - 8, 0, 100);
      addLog(
        "The wagon hits a deep rut and something cracks. You make repairs as best you can."
      );
    } else if (r < 0.04 && w.storm) {
      addLog(
        "Lightning forks across the sky and heavy rain turns the trail to mud."
      );
    } else if (r < 0.055 && gameState.region === "plains") {
      addLog(
        "You pass fresh graves along the trail, a sobering reminder of how many never reach Oregon."
      );
      if (gameState.leader) {
        gameState.leader.morale = clamp(
          gameState.leader.morale - 3,
          0,
          100
        );
      }
    }

    const r2 = Math.random();
    if (isNight(gameState.date) && gameState.mode === "camp") {
      if (gameState.guardLevel <= 0 && r2 < 0.06) {
        const roll = Math.random();

        // 1) Stock stampede
        if ((gameState.supplies.oxen || 0) > 0 && roll < 0.4) {
          const lost =
            Math.random() < 0.5 ? 1 : 0; // usually just shaken, sometimes a lost ox
          if (lost > 0) {
            gameState.supplies.oxen = Math.max(
              0,
              (gameState.supplies.oxen || 0) - lost
            );
            addLog(
              "With no one on watch, the stock stampede in the darkness. By morning you're short " +
                lost +
                " head of oxen and the rest are blown and nervous."
            );
          } else {
            addLog(
              "With no one on guard, your stock startles at some unseen noise and you spend part of the night rounding them up."
            );
          }
        }
        // 2) Theft / prowlers
        else if (roll < 0.75) {
          let stoleSomething = false;
          if ((gameState.supplies.flour || 0) > 0) {
            const amt = Math.min(20, gameState.supplies.flour || 0);
            gameState.supplies.flour -= amt;
            stoleSomething = true;
          }
          if ((gameState.supplies.ammo || 0) > 0 && Math.random() < 0.6) {
            const boxes = Math.min(2, gameState.supplies.ammo || 0);
            gameState.supplies.ammo -= boxes;
            stoleSomething = true;
          }
          if (stoleSomething) {
            addLog(
              "Sometime in the small hours, prowlers slip through the unguarded camp. A little food and ammunition are gone by dawn."
            );
          } else {
            addLog(
              "The wagons sit in uneasy silence under the stars. You sleep lightly, half expecting trouble that, mercifully, never comes."
            );
          }
        }
        // 3) Predator / hostile-tension style scare
        else {
          const people = getAllPeople().filter(function (p) {
            return p && p.alive;
          });
          const victim = people.length ? choice(people) : gameState.leader;
          if (victim) {
            victim.condition = clamp(victim.condition - 8, 0, 100);
            victim.morale = clamp(victim.morale - 4, 0, 100);
          }
          addLog(
            "Wolves or some other prowler nose near the wagons. Without a night watch, the camp wakes in confusion and someone is hurt in the scramble."
          );
        }

        if (gameState.leader) {
          gameState.leader.energy = clamp(
            gameState.leader.energy - 6,
            0,
            100
          );
          gameState.leader.morale = clamp(
            gameState.leader.morale - 2,
            0,
            100
          );
        }
      } else if (gameState.guardLevel >= 1.5 && r2 < 0.04) {
        addLog(
          "Those on watch spot trouble early—a stray animal or prowler—and quietly head it off before it reaches camp."
        );
      }
    }
  }

  /* ========= STORYTELLER / MOOD SYSTEM ==================================== */

  function recordCascadePersonEvent(personId, type, extra) {
    if (!personId) return;
    const person = getAllPeople().find(function (p) {
      return p && p.id === personId;
    });
    if (person) {
      ensurePersonStoryFields(person);
      person.cascadeHistory.push({
        hour: getCurrentTrailHour(gameState),
        day: getDayKey(gameState.date),
        type: type,
        extra: extra || {},
      });
      if (person.cascadeHistory.length > 24) person.cascadeHistory.shift();
    }
    const ss = ensureStoryState();
    if (!ss.personCascade[personId]) ss.personCascade[personId] = [];
    ss.personCascade[personId].push({
      hour: getCurrentTrailHour(gameState),
      type: type,
      extra: extra || {},
    });
    if (ss.personCascade[personId].length > 30) ss.personCascade[personId].shift();
  }

  function recordStoryBeat(kind, category, message, extra) {
    const ss = ensureStoryState();
    const dayTag =
      gameState.startDayOfYear != null
        ? Math.max(1, getDayOfYear(gameState.date) - gameState.startDayOfYear + 1)
        : getDayOfYear(gameState.date);
    ss.cascadeLog.push({
      day: dayTag,
      date: new Date(gameState.date.getTime()),
      kind: kind,
      category: category,
      message: message,
      extra: extra || {},
      hour: getCurrentTrailHour(gameState),
    });
    if (extra && extra.personId) recordCascadePersonEvent(extra.personId, category || kind, extra);
    if (extra && extra.rescuer) recordCascadePersonEvent(extra.rescuer, "lifeline", extra);
    if (extra && extra.rescued) recordCascadePersonEvent(extra.rescued, "rescued", extra);
    if (ss.cascadeLog.length > 80) {
      ss.cascadeLog.shift();
    }
  }

  function buildCascadeTimeline(storyState) {
    const entries = (storyState.cascadeLog || []).slice(-30);
    const iconFor = function (cat) {
      switch (cat) {
        case "water":
        case "illness":
          return "💧";
        case "hunger":
          return "🍞";
        case "romance":
          return "❤️";
        case "feud":
          return "⚔";
        case "leadership":
          return "⚖";
        case "lifeline":
          return "✶";
        case "loss":
          return "✝";
        default:
          return "●";
      }
    };
    return entries.map(function (entry) {
      const cat = entry.category || entry.kind || "route";
      return {
        day: entry.day,
        label: entry.day ? "Day " + entry.day : "",
        cls: cat,
        icon: iconFor(cat),
      };
    });
  }

  function renderCascadeTimeline(nodes) {
    if (!dom.cascadeTimeline) return;
    dom.cascadeTimeline.innerHTML = "";
    if (!nodes || !nodes.length) return;
    nodes.forEach(function (node, idx) {
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.alignItems = "center";
      if (idx > 0) {
        const connector = document.createElement("div");
        connector.className = "ot-cascade-connector";
        dom.cascadeTimeline.appendChild(connector);
      }
      const dot = document.createElement("div");
      dot.className = "ot-cascade-node " + (node.cls || "");
      dot.textContent = node.icon || "●";
      dom.cascadeTimeline.appendChild(dot);
      if (node.label) {
        const lab = document.createElement("div");
        lab.className = "ot-cascade-label";
        lab.textContent = node.label;
        dom.cascadeTimeline.appendChild(lab);
      }
    });
  }

  function renderCascadePeopleTracks() {
    if (!dom.cascadePeople) return;
    const ss = ensureStoryState();
    const people = getAllPeople().filter(function (p) {
      return p;
    });
    dom.cascadePeople.innerHTML = "";
    if (!people.length) return;
    const toLabel = function (type) {
      if (type === "injury" || type === "illness") return "injury";
      if (type === "lifeline") return "lifeline";
      if (type === "rescued") return "rescued";
      if (type === "breakdown") return "breakdown";
      if (type === "death") return "loss";
      return type || "event";
    };
    people.forEach(function (p) {
      const row = document.createElement("div");
      row.className = "ot-cascade-person";
      const name = document.createElement("div");
      name.className = "ot-cascade-person-name";
      name.textContent = p.name + (p.id === gameState.actingLeaderId ? " (acting)" : "");
      row.appendChild(name);
      const track = document.createElement("div");
      track.className = "ot-cascade-person-track";
      const hist =
        (p.cascadeHistory && p.cascadeHistory.length ? p.cascadeHistory : [])
          .concat(ss.personCascade[p.id] || [])
          .slice(-12);
      if (!hist.length) {
        const chip = document.createElement("div");
        chip.className = "ot-cascade-chip";
        chip.textContent = "No major notes";
        track.appendChild(chip);
      } else {
        hist.forEach(function (entry) {
          if (!entry) return;
          const chip = document.createElement("div");
          chip.className = "ot-cascade-chip";
          chip.textContent = toLabel(entry.type);
          track.appendChild(chip);
        });
      }
      row.appendChild(track);
      dom.cascadePeople.appendChild(row);
    });
  }

  function coolLeadershipDisputeState() {
    const ss = ensureStoryState();
    const state = ss.leadershipDisputeState;
    if (!state || !state.active) return;
    const now = getCurrentTrailHour(gameState);
    state.heat = Math.max(0, (state.heat || 0) - 0.2);
    state.lastHour = now;
    if (state.heat <= 0.5) state.active = false;
  }

  function updateRiskFlags() {
    const ss = ensureStoryState();
    const previous = Object.assign({}, ss.lastRiskSnapshot || {});
    const s = gameState.supplies || {};
    const mouths = mouthsCount();
    const cookedMeals =
      (s.meal_simple || 0) + (s.meal_hearty || 0) + (s.meal_feast || 0);
    ss.risk.water_shortage = (s.water || 0) < mouths * 0.4;
    ss.risk.starvation = cookedMeals < Math.max(1, mouths * 1.2);

    const ratio = computeDraftPower() > 0
      ? computeTotalWeight() / computeDraftPower()
      : 2;
    ss.risk.overloaded_wagon = ratio > 0.95;

    const w = gameState.weatherState || {};
    const avgWarmth = getAllPeople().reduce(function (sum, p) {
      return sum + (p && p.warmth ? p.warmth : 0);
    }, 0) / Math.max(1, getAllPeople().length);
    ss.risk.cold_exposure = (w.tempC || 0) < -2 && avgWarmth < 55;
    ss.risk.soaked = w.storm || gameState.recentRainHours > 18;

    const dayKeyStart = gameState.startDayOfYear || getDayOfYear(gameState.date);
    const daysOut = Math.max(0, getDayOfYear(gameState.date) - dayKeyStart);
    const expectedMiles = daysOut * 11.5;
    ss.risk.behind_schedule = gameState.milesTraveled < expectedMiles - 60;

    const block = getScheduleBlock(gameState.date);
    ss.risk.no_guard =
      block === "night" && gameState.mode === "camp" && gameState.guardLevel < 1;

    ss.risk.low_morale = (gameState.lastAvgMorale || 60) < 35;

    const categoryMap = {
      water_shortage: "water",
      extended_water_shortage: "water",
      starvation: "hunger",
      extended_starvation: "hunger",
      overloaded_wagon: "wagon",
      cold_exposure: "weather",
      extended_cold_exposure: "weather",
      behind_schedule: "route",
      no_guard: "security",
      low_morale: "social",
      soaked: "weather",
    };

    Object.keys(ss.risk).forEach(function (key) {
      const now = !!ss.risk[key];
      const before = !!previous[key];
      if (now && !before) {
        recordStoryBeat("risk_start", categoryMap[key] || key, key + " became a concern", {
          risk: key,
        });
      } else if (!now && before) {
        recordStoryBeat("risk_clear", categoryMap[key] || key, key + " eased", {
          risk: key,
        });
      }
    });

    ss.riskDurations = ss.riskDurations || {};
    Object.keys(ss.risk).forEach(function (key) {
      const active = !!ss.risk[key];
      const current = ss.riskDurations[key] || 0;
      ss.riskDurations[key] = clamp(current + (active ? 1 : -1.2), 0, 240);
    });
    ss.risk.extended_water_shortage = (ss.riskDurations.water_shortage || 0) > 10;
    ss.risk.extended_starvation = (ss.riskDurations.starvation || 0) > 14;
    ss.risk.extended_cold_exposure = (ss.riskDurations.cold_exposure || 0) > 10;

    ss.lastRiskSnapshot = Object.assign({}, ss.risk);
  }

  function updateNeedsAndMoodForHour() {
    const ss = ensureStoryState();
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    if (!people.length) return;

    let totalMorale = 0;
    let totalNeedScore = 0;

    people.forEach(function (p) {
      ensurePersonStoryFields(p);
      p.thoughts = (p.thoughts || [])
        .map(function (t) {
          if (!t) return null;
          t.hoursLeft = (t.hoursLeft || 0) - 1;
          return t.hoursLeft > 0 ? t : null;
        })
        .filter(Boolean);

      const needsScore =
        (p.hunger + p.thirst + p.warmth + p.energy + p.condition) / 5;
      totalNeedScore += needsScore;

      let thoughtBonus = 0;
      (p.thoughts || []).forEach(function (t) {
        thoughtBonus += t && t.value ? t.value : 0;
      });

      Object.keys(p.relationships || {}).forEach(function (key) {
        const rel = p.relationships[key];
        if (!rel) return;
        const other = people.find(function (x) {
          return x && x.id === key && x.alive;
        });
        if (other && rel.opinion >= 50) {
          thoughtBonus += 1.5;
        }
      });

      let morale =
        needsScore * 0.6 +
        (p.morale || 50) * 0.25 +
        thoughtBonus * 1.5;

      const optimismFactor = clamp((p.optimism || 0) / 100, 0.25, 0.85);
      const deficit = Math.max(0, 70 - needsScore);
      morale -= deficit * (1 - optimismFactor * 0.7);
      morale = clamp(morale, 0, 100);

      p.morale = morale;
      p.optimism = clamp((p.optimism || 0) - 0.06 - (needsScore < 45 ? 0.08 : 0), 0, 85);
      p.moodState =
        morale > 70
          ? "Upbeat"
          : morale >= 35
          ? "Uneasy"
          : morale >= 15
          ? "Worn"
          : "Broken";

      if (morale < 25) {
        p.lowMoraleHours = (p.lowMoraleHours || 0) + 1;
      } else {
        p.lowMoraleHours = Math.max(0, (p.lowMoraleHours || 0) - 0.5);
      }
      if (p.lowMoraleHours > 8 && !ss.eventFlags["pending_break_" + p.id]) {
        ss.eventFlags["pending_break_" + p.id] = true;
      }

      totalMorale += morale;
    });

    gameState.lastAvgMorale = totalMorale / Math.max(1, people.length);
    gameState.lastAvgNeeds = totalNeedScore / Math.max(1, people.length);

    updateRiskFlags();
  }

  function onPersonDeath(person) {
    if (!person) return;
    const others = getAllPeople().filter(function (p) {
      return p && p.alive && p.id !== person.id;
    });
    others.forEach(function (p) {
      const rel = p.relationships && p.relationships[person.id];
      if (rel && rel.opinion >= 50) {
        addThought(p, {
          id: "loss_" + person.id,
          label: "Lost a loved one",
          value: -15,
          hoursLeft: 48,
          source: "loss",
        });
      }
    });

    recordStoryBeat(
      "death",
      "loss",
      person.name + " died on the trail",
      { personId: person.id }
    );
    recordCascadePersonEvent(person.id, "death", { location: gameState.locationName });
    const anyAlive = getAllPeople().some(function (p) {
      return p && p.alive;
    });
    if (!anyAlive) {
      gameState.runEnded = gameState.runEnded || { reason: "loss" };
    }
  }

  function getStoryTensionTargetForContext(storyState, ctx, preset) {
    const basePreset = preset || STORYTELLER_PRESETS.classic;
    const regionKey = ctx && ctx.regionKey;
    const seasonTag = (ctx && ctx.seasonTag) || getSeasonTagForDate(gameState.date);
    const regionCurve =
      (basePreset.regionCurves && regionKey && basePreset.regionCurves[regionKey]) || null;
    let combined = regionCurve || {};
    if (regionCurve && regionCurve.seasons && seasonTag && regionCurve.seasons[seasonTag]) {
      combined = Object.assign({}, regionCurve, regionCurve.seasons[seasonTag]);
    }
    return {
      baseDrift:
        combined.baseDrift != null ? combined.baseDrift : basePreset.tensionBaseDrift,
      minClamp: combined.minClamp != null ? combined.minClamp : basePreset.tensionMin,
      maxClamp: combined.maxClamp != null ? combined.maxClamp : basePreset.tensionMax,
      riskScale:
        combined.tensionRiskScale != null
          ? combined.tensionRiskScale
          : basePreset.tensionRiskScale,
    };
  }

  function updateStoryTension(storyState, ctx) {
    const preset =
      STORYTELLER_PRESETS[storyState.presetId || gameState.storytellerPresetId] ||
      STORYTELLER_PRESETS.classic;
    const target = getStoryTensionTargetForContext(storyState, ctx, preset);
    const activeRisk = ctx.riskCount + (ctx.risk.extended_starvation ? 2 : 0);
    const moralePull =
      ctx.avgMorale > 75 ? -0.35 : ctx.avgMorale < 40 ? 0.45 : ctx.avgMorale < 55 ? 0.15 : 0;
    const riskScale = target.riskScale != null ? target.riskScale : preset.tensionRiskScale;
    const drift = target.baseDrift + (ctx.risk.behind_schedule ? 0.02 : 0);
    const riskPull = activeRisk * riskScale;
    let next = (storyState.tension || 0) + drift + riskPull + moralePull;
    if (target.minClamp != null) next = Math.max(target.minClamp, next);
    if (target.maxClamp != null) next = Math.min(target.maxClamp, next);
    storyState.tension = clamp(next, 0, 100);
  }

  function renderTensionDebug(storyState, ctx) {
    if (!dom.tensionReadout) return;
    if (!gameState.showStorytellerDebug && !gameState.tensionDebug) {
      dom.tensionReadout.textContent = "";
      return;
    }
    const recent = (storyState.recentEvents || []).slice(-4);
    const label = recent
      .map(function (e) {
        return e.id || e.kind || "?";
      })
      .join(", ");
    const preset =
      STORYTELLER_PRESETS[storyState.presetId || gameState.storytellerPresetId] ||
      STORYTELLER_PRESETS.classic;
    const sinceMinor = storyState.hoursSinceMinorEvent || 0;
    const sinceMajor = storyState.hoursSinceMajorEvent || 0;
    const riskCount = ctx && ctx.riskCount != null ? ctx.riskCount : 0;
    const lastId = recent.length ? recent[recent.length - 1].id : "—";
    dom.tensionReadout.innerHTML =
      "<div><strong>" +
      preset.label +
      "</strong> · tension " +
      Math.round(storyState.tension) +
      "</div><div>hrs since minor/major: " +
      sinceMinor +
      " / " +
      sinceMajor +
      "; risk " +
      riskCount +
      "; last: " +
      lastId +
      (label ? "</div><div>recent: " + label + "</div>" : "");
  }

  const EVENT_DEFS = [
    {
      id: "camp_flooded_low_ground",
      kind: "minor",
      condition: function (ctx) {
        return (
          ctx.mode === "camp" &&
          ctx.block === "night" &&
          ctx.weather &&
          ctx.weather.storm &&
          (ctx.location || "").toLowerCase().indexOf("river") >= 0
        );
      },
      weight: function (ctx) {
        return 6 + (ctx.guardCoverage < 0.8 ? 1 : 0);
      },
      run: function (ctx) {
        const people = ctx.people || [];
        people.forEach(function (p) {
          p.warmth = clamp(p.warmth - 4, 0, 100);
          p.morale = clamp(p.morale - 2, 0, 100);
        });
        addLog(
          "Low ground and heavy rain flood the tents. Bedding soaks through and everyone shivers toward dawn.",
          { tone: "warning", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
      },
    },
    {
      id: "camp_tents_blown_down",
      kind: "minor",
      condition: function (ctx) {
        return ctx.mode === "camp" && ctx.weather && ctx.weather.windKph >= 30;
      },
      weight: function (ctx) {
        return 5 + (ctx.guardCoverage < 1 ? 2 : 0);
      },
      run: function (ctx) {
        const people = ctx.people || [];
        people.forEach(function (p) {
          p.energy = clamp(p.energy - 4, 0, 100);
          p.warmth = clamp(p.warmth - 3, 0, 100);
        });
        gameState.wagonCondition = clamp(gameState.wagonCondition - 4, 0, 100);
        addLog(
          "Wind tears at loose ropes. A tent comes down in the dark; everyone stumbles out, cold and tired.",
          { tone: "warning", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
      },
    },
    {
      id: "camp_thief_slips_in",
      kind: "minor",
      condition: function (ctx) {
        return ctx.mode === "camp" && ctx.guardCoverage < 0.6 && ctx.block === "night";
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        let stole = false;
        if ((gameState.supplies.flour || 0) > 5) {
          gameState.supplies.flour = Math.max(0, gameState.supplies.flour - 5);
          stole = true;
        }
        if ((gameState.supplies.ammo || 0) > 0 && Math.random() < 0.4) {
          gameState.supplies.ammo = Math.max(0, gameState.supplies.ammo - 1);
          stole = true;
        }
        addLog(
          stole
            ? "With few eyes on watch, a thief slips between wagons and makes off with some supplies."
            : "A shadow noses around camp but finds little worth taking before vanishing into the dark.",
          { tone: stole ? "warning" : "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
      },
    },
    {
      id: "camp_guard_spots_threat",
      kind: "breather",
      condition: function (ctx) {
        return ctx.mode === "camp" && ctx.guardCoverage >= 1.2 && ctx.block === "night";
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        addLog(
          "A watchful guard hears movement beyond the firelight and warns the camp in time. Everyone settles again, a little more at ease.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
      },
    },
    {
      id: "clear_skies_breather",
      kind: "breather",
      minTension: 15,
      condition: function (ctx) {
        return (
          ctx.storyState.tension > 25 &&
          ctx.avgMorale < 65 &&
          ctx.weather.precip === "none"
        );
      },
      weight: function (ctx) {
        return 6 + (ctx.risk.low_morale ? 3 : 0);
      },
      run: function (ctx) {
        addLog(
          "A clear stretch of trail and calm weather steadies everyone's nerves.",
          {
            tone: "morale",
            tag: "DAY " + ctx.dayTag,
            location: ctx.location,
          }
        );
        ctx.people.forEach(function (p) {
          addThought(p, {
            id: "calm_weather",
            label: "Calm weather",
            value: 4,
            hoursLeft: 12,
            source: "weather",
          });
        });
        ctx.storyState.tension = clamp(ctx.storyState.tension - 10, 0, 100);
        ctx.storyState.hoursSinceMinorEvent = 0;
      },
    },
    {
      id: "soaked_shivers",
      kind: "minor",
      maxTension: 90,
      condition: function (ctx) {
        return ctx.risk.soaked || ctx.risk.cold_exposure;
      },
      weight: function (ctx) {
        return 8 + (ctx.risk.cold_exposure ? 4 : 0);
      },
      run: function (ctx) {
        const target = ctx.people.length ? choice(ctx.people) : null;
        if (target) {
          target.warmth = clamp(target.warmth - 6, 0, 100);
          addThought(target, {
            id: "chilled",
            label: "Chilled and soaked",
            value: -6,
            hoursLeft: 10,
            source: "weather",
          });
          addLog(
            target.name +
              " can't shake the cold after marching in the wet. Spirits dip as everyone tries to dry gear by the fire.",
            {
              tone: "warning",
              characters: [target.id],
              tag: "DAY " + ctx.dayTag,
              location: ctx.location,
            }
          );
        }
        ctx.storyState.tension = clamp(ctx.storyState.tension + 4, 0, 100);
        ctx.storyState.hoursSinceMinorEvent = 0;
      },
    },
    {
      id: "rival_snapping",
      kind: "minor",
      condition: function (ctx) {
        return ctx.rivalPair && ctx.risk.low_morale;
      },
      weight: function () {
        return 7;
      },
      run: function (ctx) {
        const pair = ctx.rivalPair;
        if (!pair) return;
        addLog(
          pair[0].name +
            " snaps at " +
            pair[1].name +
            " over chores, fraying tempers for the evening.",
          {
            tone: "social",
            characters: [pair[0].id, pair[1].id],
            tag: "DAY " + ctx.dayTag,
            location: ctx.location,
          }
        );
        addThought(pair[0], {
          id: "argument",
          label: "Argument at camp",
          value: -4,
          hoursLeft: 12,
          source: "social",
        });
        addThought(pair[1], {
          id: "argument",
          label: "Argument at camp",
          value: -4,
          hoursLeft: 12,
          source: "social",
        });
        const relA = pair[0].relationships[pair[1].id];
        const relB = pair[1].relationships[pair[0].id];
        if (relA) relA.opinion = clamp((relA.opinion || 0) - 4, -100, 100);
        if (relB) relB.opinion = clamp((relB.opinion || 0) - 4, -100, 100);
        ctx.storyState.hoursSinceMinorEvent = 0;
        ctx.storyState.tension = clamp(ctx.storyState.tension + 6, 0, 100);
      },
    },
    {
      id: "lifeline_water",
      kind: "minor",
      condition: function (ctx) {
        return (
          (ctx.risk.water_shortage || ctx.risk.starvation) &&
          !ctx.storyState.eventFlags.lifelineUsed
        );
      },
      weight: function (ctx) {
        return ctx.risk.water_shortage ? 12 : 4;
      },
      run: function (ctx) {
        gameState.supplies.water = (gameState.supplies.water || 0) + 6;
        gameState.supplies.meal_simple = (gameState.supplies.meal_simple || 0) + 2;
        ctx.storyState.eventFlags.lifelineUsed = true;
        ctx.storyState.eventFlags.recent_lifeline = true;
        addLog(
          "A fellow traveler shares a keg of water and a little food after seeing your state.",
          {
            tone: "event",
            tag: "DAY " + ctx.dayTag,
            location: ctx.location,
          }
        );
        ctx.storyState.hoursSinceMinorEvent = 0;
        ctx.storyState.tension = clamp(ctx.storyState.tension - 6, 0, 100);
      },
    },
    {
      id: "snakebit_traveler",
      kind: "minor",
      minTension: 12,
      condition: function (ctx) {
        return (
          ctx.mode === "travel" &&
          (ctx.regionKey === "high_plains" || ctx.regionKey === "mountains") &&
          !ctx.storyState.eventFlags.snake_traveler_helped
        );
      },
      weight: function (ctx) {
        return 5 + (ctx.weather && ctx.weather.tempC > 25 ? 1 : 0);
      },
      run: async function (ctx) {
        const choice = await presentEncounter({
          id: "snakebit_traveler",
          title: "Snake-bitten traveler",
          subtitle: ctx.location,
          body: [
            "You find a young man sweating by the trail, leg swollen from a rattler bite. His partner begs for aid.",
          ],
          imageUrl: IMAGE_URLS.snake_bench_heat || IMAGE_URLS.snake_bench_storm,
          tags: ["mercy", "injury", "danger"],
          options: [
            { id: "aid", label: "Use medicine and tend him", tone: "warm", hint: "Costs medicine; raises your standing." },
            { id: "ignore", label: "Wish them luck and move on", tone: "neutral" },
            { id: "rob", label: "Take their gear while they're down", tone: "danger", hint: "Quick profit but word will spread." },
          ],
          defaultId: "aid",
        });
        if (choice === "aid") {
          const onHand = gameState.supplies.med_kits || 0;
          const spend = Math.min(onHand, 1);
          gameState.supplies.med_kits = Math.max(0, onHand - spend);
          const careLine =
            spend > 0
              ? "You clean and wrap the bite, leaving a precious dose of medicine behind."
              : "With no medicine left, you improvise a poultice and keep him calm as best you can.";
          addLog(careLine, { tone: "morale" });
          adjustReputation(4, "You treated a stranger", { flag: "knownGenerous" });
          ctx.storyState.eventFlags.snake_traveler_helped = true;
          gameState.reputationFlags.helpedSnakeTraveler = true;
        } else if (choice === "rob") {
          gameState.money = (gameState.money || 0) + 6;
          gameState.supplies.ammo = Math.max(0, (gameState.supplies.ammo || 0) + 2);
          addLog("You strip a pouch of coins and cartridges while the pair watches, helpless.", { tone: "warning" });
          adjustReputation(-8, "You robbed a helpless traveler", { flag: "knownThief" });
          ctx.storyState.tension = clamp(ctx.storyState.tension + 4, 0, 100);
        } else {
          addLog("You offer water and move on, the wounded traveler fading into the dust behind you.", { tone: "info" });
          adjustReputation(-1, "You left the snakebite to fate");
        }
      },
    },
    {
      id: "snake_traveler_followup",
      kind: "breather",
      condition: function (ctx) {
        return (
          ctx.location.toLowerCase().indexOf("fort") >= 0 &&
          ctx.storyState.eventFlags.snake_traveler_helped
        );
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        ctx.storyState.eventFlags.snake_traveler_helped = false;
        const gift = 8;
        gameState.money = (gameState.money || 0) + gift;
        addLog("The healed traveler finds you at the fort with a pouch of coins and a grateful grin.", { tone: "event" });
        adjustReputation(2, "Word of your aid spread", { flag: "fort_gratitude" });
      },
    },
    {
      id: "broken_axle_wagon",
      kind: "minor",
      condition: function (ctx) {
        return (
          ctx.mode === "travel" &&
          (ctx.regionKey === "plains" || ctx.regionKey === "central_plains") &&
          !ctx.storyState.eventFlags.broken_axle_recent
        );
      },
      weight: function () {
        return 7;
      },
      run: async function (ctx) {
        const rep = gameState.reputation || 0;
        const choice = await presentEncounter({
          id: "broken_axle_wagon",
          title: "Wagon with a broken axle",
          subtitle: ctx.location,
          body: [
            "A family waves you down beside a wagon tipped in the ruts. They ask if you can spare a part or lend a hand.",
          ],
          tags: ["mercy", "trade"],
          options: [
            { id: "share", label: "Share a spare part", tone: "warm", hint: "Costs an axle or wheel; earns gratitude." },
            { id: "trade", label: "Trade repair for supplies", tone: "neutral", hint: "Better terms if you're trusted." },
            { id: "move", label: "Wish them luck and move on", tone: "danger" },
          ],
          defaultId: "share",
        });
        if (choice === "share") {
          const nowHour = getCurrentTrailHour(gameState);
          if ((gameState.supplies.axles || 0) > 0) {
            gameState.supplies.axles = Math.max(0, (gameState.supplies.axles || 0) - 1);
          } else if ((gameState.supplies.wheels || 0) > 0) {
            gameState.supplies.wheels = Math.max(0, (gameState.supplies.wheels || 0) - 1);
          } else {
            gameState.lastHourMiles = Math.max(0, (gameState.lastHourMiles || 0) - 0.2);
          }
          gameState.supplies.meal_hearty = (gameState.supplies.meal_hearty || 0) + 1;
          addLog("You help brace the wagon and hand over a spare part. They share a hearty meal in thanks.", { tone: "morale" });
          adjustReputation(3, "You lent parts on the trail");
          setEventFlag("helped_stranded_family_time", nowHour);
          setEventFlag("helped_stranded_family", true);
        } else if (choice === "trade") {
          const nowHour = getCurrentTrailHour(gameState);
          const generosity = rep >= 15 ? 2 : 0;
          gameState.money = (gameState.money || 0) + 4 + generosity;
          gameState.supplies.meal_simple = Math.max(0, (gameState.supplies.meal_simple || 0) - 1);
          addLog("You bargain repairs for coin and a sack of biscuits.", { tone: "event" });
          adjustReputation(1, "Fair trade on the trail");
          setEventFlag("helped_stranded_family_time", nowHour);
          setEventFlag("helped_stranded_family", true);
        } else {
          addLog("You nod and move on, leaving them to flag another wagon.", { tone: "info" });
          adjustReputation(-2, "Ignored a stranded wagon");
        }
        ctx.storyState.eventFlags.broken_axle_recent = true;
      },
    },
    {
      id: "family_returns_favor",
      kind: "lifeline",
      condition: function (ctx) {
        const helped = getEventFlag("helped_stranded_family");
        const paid = getEventFlag("helped_stranded_family_paid");
        const waited = hoursSinceFlag("helped_stranded_family_time");
        return helped && !paid && waited >= 72 && waited <= 240;
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        setEventFlag("helped_stranded_family_paid", true);
        setEventFlag("helped_stranded_family", false);
        gameState.supplies.flour = (gameState.supplies.flour || 0) + 5;
        gameState.supplies.ammo = (gameState.supplies.ammo || 0) + 1;
        gameState.supplies.axles = (gameState.supplies.axles || 0) + 1;
        addLog(
          "The family you helped catches up and presses a bundle of flour, a spare axle, and a box of cartridges into your hands.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        recordStoryBeat("lifeline", "aid", "Family you helped returned the favor");
      },
    },
    {
      id: "shortcut_guide_offer",
      kind: "minor",
      minTension: 18,
      condition: function (ctx) {
        return ctx.mode === "travel" && ctx.regionKey === "mountains" && !ctx.storyState.eventFlags.shortcut_guide_seen;
      },
      weight: function (ctx) {
        return 5 + (ctx.risk.behind_schedule ? 2 : 0);
      },
      run: async function (ctx) {
        const travelSkill = (gameState.leader && gameState.leader.skills && gameState.leader.skills.travel) || 1;
        const choice = await presentEncounter({
          id: "shortcut_guide_offer",
          title: "Dubious shortcut guide",
          subtitle: ctx.location,
          body: [
            "A wiry guide offers to shave days off the mountain climb for a fee, swearing he knows a dry canyon route.",
          ],
          tags: ["shortcut", "danger"],
          options: [
            { id: "pay", label: "Pay for the shortcut", tone: "danger", hint: "$5. Could save time or cost dearly." },
            { id: "decline", label: "Stick to the mapped road", tone: "neutral" },
            { id: "press", label: "Press for proof", tone: "warm", hint: "Lean on your reputation and wits." },
          ],
          defaultId: "decline",
        });
        if (choice === "pay") {
          gameState.money = Math.max(0, (gameState.money || 0) - 5);
          const lucky = Math.random() < 0.35 + travelSkill * 0.05;
          if (lucky) {
            gameState.lastHourMiles = (gameState.lastHourMiles || 0) + 1.2;
            addLog("The guide threads a hidden draw; you make rare quick miles through the ridges.", { tone: "event" });
          } else {
            gameState.wagonCondition = clamp(gameState.wagonCondition - 6, 0, 100);
            ctx.storyState.tension = clamp(ctx.storyState.tension + 6, 0, 100);
            addLog("The shortcut bogs in shale. A wheel groans and time is lost.", { tone: "warning" });
          }
        } else if (choice === "press") {
          const trusted = (gameState.reputation || 0) >= 10;
          if (trusted) {
            gameState.lastHourMiles = (gameState.lastHourMiles || 0) + 0.6;
            addLog("Your firm questions make the guide draw a real map, yielding a small savings.", { tone: "event" });
            adjustReputation(1, "Handled a shortcut guide wisely");
          } else {
            addLog("The guide bristles at your doubt and slips away into the trees.", { tone: "info" });
            ctx.storyState.tension = clamp(ctx.storyState.tension + 2, 0, 100);
          }
        } else {
          addLog("You keep to the marked road despite the sales pitch.", { tone: "info" });
        }
        ctx.storyState.eventFlags.shortcut_guide_seen = true;
      },
    },
    {
      id: "passing_caravan",
      kind: "breather",
      condition: function (ctx) {
        return ctx.mode === "travel" && ctx.block === "morning" && !ctx.storyState.eventFlags.caravan_travel_tag;
      },
      weight: function () {
        return 6;
      },
      run: async function (ctx) {
        const choice = await presentEncounter({
          id: "passing_caravan",
          title: "Passing caravan",
          subtitle: ctx.location,
          body: [
            "A well-armed caravan rolls alongside for a while. Faces are wary but curious.",
          ],
          tags: ["trade", "social"],
          options: [
            { id: "greet", label: "Exchange pleasantries", tone: "warm", hint: "Small morale lift." },
            {
              id: "trade",
              label: "Trade staples",
              tone: "neutral",
              hint: "Swap coffee or flour; terms hinge on caravan regard.",
            },
            { id: "travel", label: "Travel together for a day", tone: "warm", hint: "Safer for a bit; slower pace." },
            { id: "threaten", label: "Rattle them for goods", tone: "danger", hint: "Risky, reputation hit." },
          ],
          defaultId: "greet",
        });
        const tradeTerms = getTradeTermsForFaction("caravans");
        let flourCost = Math.max(2, Math.round(4 * tradeTerms.costMult));
        let coffeeGain = Math.max(1, Math.round(1 * tradeTerms.gainMult));
        if (tradeTerms.tier.id === "ally") {
          flourCost = Math.max(2, flourCost - 1);
          coffeeGain += 1;
        } else if (tradeTerms.tier.id === "wary" || tradeTerms.tier.id === "hostile") {
          flourCost += 1;
          coffeeGain = Math.max(1, coffeeGain - 1);
        }
        if (choice === "greet") {
          getAllPeople().forEach(function (p) {
            adjustPersonStat(p, "morale", 1);
          });
          adjustFactionRep("caravans", 1, null, ctx);
          addLog("Shared jokes and trail gossip lighten the morning march.", { tone: "morale" });
        } else if (choice === "trade") {
          if ((gameState.supplies.flour || 0) >= flourCost) {
            gameState.supplies.coffee = (gameState.supplies.coffee || 0) + coffeeGain;
            gameState.supplies.flour = Math.max(0, (gameState.supplies.flour || 0) - flourCost);
            adjustFactionRep("caravans", 2, null, ctx);
            addLog(
              `You trade ${flourCost} flour for ${coffeeGain} coffee under watchful eyes.`,
              { tone: "event" }
            );
            adjustReputation(1, "Fair caravan trade");
          } else {
            addLog("Lacking flour to spare, the trade falls through with polite nods.", { tone: "info" });
          }
        } else if (choice === "travel") {
          ctx.storyState.eventFlags.caravan_travel_tag = ctx.dayTag;
          ctx.storyState.eventFlags.caravan_guard_bonus = 3;
          gameState.lastHourMiles = Math.max(0, (gameState.lastHourMiles || 0) - 0.3);
          adjustFactionRep("caravans", 1, null, ctx);
          addLog("You fall in with the caravan for the day, sharing watch and stories.", { tone: "morale" });
        } else {
          gameState.money = (gameState.money || 0) + 3;
          adjustFactionRep("caravans", -5, null, ctx);
          adjustReputation(-6, "You shook down a caravan", { flag: "knownThief" });
          addLog("You rattle the caravan for a few coins. Eyes stay cold as they pull away.", { tone: "warning" });
          ctx.storyState.tension = clamp(ctx.storyState.tension + 5, 0, 100);
        }
      },
    },
    {
      id: "caravan_travel_followup",
      kind: "breather",
      condition: function (ctx) {
        return ctx.storyState.eventFlags.caravan_travel_tag && ctx.dayTag > ctx.storyState.eventFlags.caravan_travel_tag;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        ctx.storyState.eventFlags.caravan_travel_tag = null;
        ctx.storyState.eventFlags.caravan_guard_bonus = null;
        getAllPeople().forEach(function (p) {
          adjustPersonStat(p, "morale", 1);
        });
        addLog("The caravan peels off toward another valley, leaving you with fresh rumors and steadier spirits.", { tone: "event" });
      },
    },
    {
      id: "bandit_tax",
      kind: "major",
      minTension: 32,
      condition: function (ctx) {
        return (
          ctx.mode === "travel" &&
          (ctx.regionKey === "blue_mountains" || ctx.regionKey === "snake_plain" || ctx.regionKey === "mountains")
        );
      },
      weight: function () {
        return 6;
      },
      run: async function (ctx) {
        const rep = gameState.reputation || 0;
        const guard = ctx.guardCoverage || 0;
        const selection = await presentEncounter({
          id: "bandit_tax",
          title: "Bandits demand a toll",
          subtitle: ctx.location,
          body: [
            "Riders block a narrow stretch, asking for a \"tax\" to pass. Their eyes weigh your weapons and weary faces.",
          ],
          tags: ["bandit", "danger"],
          options: [
            { id: "parley", label: "Parley and pay a little", tone: "neutral", hint: "Reputation may soften them." },
            { id: "fight", label: "Fight through", tone: "danger", hint: "Spend ammo; risk injury." },
            { id: "flee", label: "Flee and drop goods", tone: "warm", hint: "Lose supplies to avoid blood." },
          ],
          defaultId: "parley",
        });
        if (selection === "parley") {
          const discount = rep >= 15 ? 2 : 0;
          const cost = Math.max(2, 5 - discount);
          gameState.money = Math.max(0, (gameState.money || 0) - cost);
          addLog("You hand over a few dollars and pass with tense nods.", { tone: "event" });
          adjustReputation(discount ? 1 : 0, "Talked past bandits");
        } else if (selection === "fight") {
          const ammoUse = Math.max(1, 3 - guard);
          gameState.supplies.ammo = Math.max(0, (gameState.supplies.ammo || 0) - ammoUse);
          const hurt = Math.random() < 0.4;
          if (hurt) {
            const target = choice(ctx.people || getAllPeople());
            if (target) target.condition = clamp((target.condition || 50) - 8, 0, 100);
            addLog("Shots ring out. You break through but someone is bloodied.", { tone: "warning" });
          } else {
            addLog("A few well-placed shots send the bandits riding. You push on.", { tone: "event" });
          }
          adjustReputation(-1, "You chose to fight off a toll");
        } else {
          gameState.supplies.flour = Math.max(0, (gameState.supplies.flour || 0) - 6);
          gameState.supplies.ammo = Math.max(0, (gameState.supplies.ammo || 0) - 1);
          addLog("You toss a sack of flour to distract them and bolt down the trail.", { tone: "warning" });
          adjustReputation(-2, "Fled from a bandit toll");
          ctx.storyState.tension = clamp(ctx.storyState.tension + 2, 0, 100);
        }
      },
    },
    {
      id: "campfire_visitor",
      kind: "breather",
      condition: function (ctx) {
        return ctx.mode === "camp" && ctx.block === "evening" && !ctx.weather.storm;
      },
      weight: function () {
        return 6;
      },
      run: async function (ctx) {
        const choice = await presentEncounter({
          id: "campfire_visitor",
          title: "Visitor at the campfire",
          subtitle: formatDateTime(gameState.date) + " · " + ctx.location,
          body: [
            "A wandering preacher with a fiddle pauses at the edge of camp, hat in hand, asking to share the fire.",
          ],
          tags: ["camp", "social"],
          options: [
            { id: "invite", label: "Invite him in", tone: "warm", hint: "Morale boost; a rumor in return." },
            { id: "trade", label: "Trade for a tune", tone: "neutral", hint: "Spend $2; gain a small boon." },
            { id: "turn", label: "Turn him away", tone: "danger", hint: "Guard the stores." },
          ],
          defaultId: "invite",
        });
        if (choice === "invite") {
          getAllPeople().forEach(function (p) {
            adjustPersonStat(p, "morale", 3);
          });
          adjustReputation(2, "Welcomed a campfire guest");
          addLog("The fiddle tune carries over the wagons, easing hearts for a night.", { tone: "morale" });
        } else if (choice === "trade") {
          gameState.money = Math.max(0, (gameState.money || 0) - 2);
          gameState.supplies.med_kits = (gameState.supplies.med_kits || 0) + 1;
          addLog("You pay for a tune and a pouch of herbs the preacher swears by.", { tone: "event" });
        } else {
          addLog("You keep the fire close and the stranger moves on into the dark.", { tone: "info" });
          adjustReputation(-1, "Turned away a traveler");
        }
      },
    },
    {
      id: "seed_gun_misfire",
      kind: "breather",
      condition: function (ctx) {
        const ammo = (gameState.supplies.ammo || 0) > 0;
        const cooldown = hoursSinceFlag("seed_gun_misfire_time") >= 48;
        const huntingContext = ctx.lastHourCampTasks && ctx.lastHourCampTasks.huntedById;
        return cooldown && ammo && (ctx.mode === "travel" || huntingContext);
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const selection = await presentEncounter({
          id: "seed_gun_misfire",
          title: "Rifle misfire",
          subtitle: ctx.location,
          body: [
            "A shot hangs in the barrel and the powder fizzles. The wagon jolts while you steady the weapon.",
          ],
          tags: ["travel", "hunting"],
          options: [
            { id: "clear", label: "Clear it carefully", tone: "neutral", hint: "Costs a round." },
            { id: "force", label: "Force it back to life", tone: "danger", hint: "Risk a kickback." },
          ],
          defaultId: "clear",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_gun_misfire_time", nowHour);
        gameState.supplies.ammo = Math.max(0, (gameState.supplies.ammo || 0) - 1);
        let logText = "You clear the misfire and lose a round before moving on.";
        let tone = "event";
        if (selection === "force") {
          const target = choice(ctx.people || getAllPeople());
          const injury = Math.random() < 0.35 && target;
          if (injury) {
            target.condition = clamp((target.condition || 50) - 6, 0, 100);
            addAffliction(target, "sprain", { severity: 1 });
            logText =
              "You snap the hammer forward. The shot goes, but the recoil smacks " +
              target.name +
              " hard.";
            tone = "warning";
          } else {
            logText = "You force the hammer and the rifle cracks off with a jolt, startling the team.";
          }
        }
        addLog(logText, { tone: tone, tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "gear", "Handled a rifle misfire", { choice: selection });
      },
    },
    {
      id: "seed_lost_diary_pages",
      kind: "breather",
      condition: function (ctx) {
        return ctx.mode === "travel" && hoursSinceFlag("seed_lost_diary_pages_time") >= 72;
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const choice = await presentEncounter({
          id: "seed_lost_diary_pages",
          title: "Pages on the wind",
          subtitle: ctx.location,
          body: [
            "Loose diary pages flutter along the ruts. A careful hand has written dates, debts, and a child’s scribbles in the margins.",
          ],
          tags: ["travel", "find"],
          options: [
            { id: "keep", label: "Keep them for later reading", tone: "warm" },
            { id: "sell", label: "Save to sell in the next town", tone: "neutral" },
            { id: "return", label: "Ask around to return them", tone: "warm" },
          ],
          defaultId: "keep",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_lost_diary_pages_time", nowHour);
        let logText = "You tuck the pages away and carry on.";
        if (choice === "keep") {
          getAllPeople().forEach(function (p) {
            adjustPersonStat(p, "morale", 2);
          });
          logText = "The diary pages become quiet camp reading, lifting spirits for a moment.";
        } else if (choice === "sell") {
          setEventFlag("diary_pages_for_sale", true);
          logText = "You press the pages flat and plan to see if a clerk or post rider will pay for them.";
        } else if (choice === "return") {
          adjustReputation(2, "Tried to return a diary");
          logText = "You ask nearby wagons about the diary and promise to pass it along if you find the owner.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "find", "Found loose diary pages", { choice: choice });
      },
    },
    {
      id: "seed_broken_compass",
      kind: "breather",
      condition: function (ctx) {
        const badWeather = ctx.weather && (ctx.weather.storm || ctx.weather.fog || ctx.weather.cold);
        return badWeather && hoursSinceFlag("seed_broken_compass_time") >= 72;
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const choice = await presentEncounter({
          id: "seed_broken_compass",
          title: "Compass off its needle",
          subtitle: ctx.location,
          body: [
            "Condensation fogs the glass and the needle sticks. The horizon is a smear of storm and gray hills.",
          ],
          tags: ["weather", "travel"],
          options: [
            { id: "slow", label: "Slow and reorient", tone: "neutral", hint: "Costs energy but safer." },
            { id: "push", label: "Push on by feel", tone: "danger", hint: "Risk wasting supplies." },
          ],
          defaultId: "slow",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_broken_compass_time", nowHour);
        let logText = "You slow the teams and pick landmarks until the compass frees up.";
        if (choice === "slow") {
          (ctx.people || []).forEach(function (p) {
            adjustPersonStat(p, "energy", -2);
          });
        } else {
          if (Math.random() < 0.45) {
            gameState.supplies.flour = Math.max(0, (gameState.supplies.flour || 0) - 3);
            logText = "You press forward blind. A wrong draw costs a few miles and flour before the sky clears.";
          } else {
            logText = "You keep a bearing by the wind and emerge on course, uneasy but unhurt.";
          }
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "navigation", "Compass trouble in bad weather", { choice: choice });
      },
    },
    {
      id: "seed_wagon_tongue_crack",
      kind: "minor",
      condition: function (ctx) {
        const wagonWear = (gameState.wagonCondition || 100) <= 75;
        const roughRegion =
          ctx.regionKey === "mountains" || ctx.regionKey === "blue_mountains" || ctx.regionKey === "snake_plain";
        return (wagonWear || roughRegion) && hoursSinceFlag("seed_wagon_tongue_crack_time") >= 96;
      },
      weight: function () {
        return 3;
      },
      run: async function (ctx) {
        const choice = await presentEncounter({
          id: "seed_wagon_tongue_crack",
          title: "Crack in the wagon tongue",
          subtitle: ctx.location,
          body: [
            "A hairline crack creeps along the wagon tongue after a hard jolt. The team stomps and snorts, waiting on your call.",
          ],
          tags: ["wagon", "repair"],
          options: [
            { id: "repair", label: "Repair it now", tone: "warm", hint: "Spend wood and time; safer later." },
            { id: "patch", label: "Patch and watch", tone: "danger", hint: "Risk it for now." },
          ],
          defaultId: "repair",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_wagon_tongue_crack_time", nowHour);
        let logText = "You lash a quick patch and keep rolling, watching the splintered wood.";
        if (choice === "repair") {
          gameState.supplies.firewood = Math.max(0, (gameState.supplies.firewood || 0) - 1.5);
          setEventFlag("wagon_tongue_reinforced", true);
          setEventFlag("wagon_tongue_patch_risk", false);
          logText = "You plane a spare plank, bolt it on, and brace the tongue before moving again.";
        } else {
          setEventFlag("wagon_tongue_patch_risk", true);
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "wagon", "Noticed a crack in the wagon tongue", { choice: choice });
      },
    },
    {
      id: "seed_campfire_tall_tale",
      kind: "breather",
      condition: function (ctx) {
        return (
          ctx.mode === "camp" &&
          ctx.block === "evening" &&
          (ctx.storyState.tension || 0) <= 40 &&
          hoursSinceFlag("seed_campfire_tall_tale_time") >= 48
        );
      },
      weight: function () {
        return 3;
      },
      run: async function (ctx) {
        await presentEncounter({
          id: "seed_campfire_tall_tale",
          title: "Tall tale by the coals",
          subtitle: formatDateTime(gameState.date) + " · " + ctx.location,
          body: [
            "A neighbor wagon spins a story of haunted buttes and buried goods. The fire pops; faces lean in despite themselves.",
          ],
          tags: ["camp", "story"],
          options: [{ id: "listen", label: "Listen in", tone: "warm" }],
          defaultId: "listen",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_campfire_tall_tale_time", nowHour);
        getAllPeople().forEach(function (p) {
          adjustPersonStat(p, "morale", 3);
        });
        if (ctx.storyState.mythicEnabled !== false) {
          setEventFlag("tall_tale_hook", true);
          ctx.storyState.mythicRumor = clamp((ctx.storyState.mythicRumor || 0) + 1, 0, 100);
        }
        addLog("The tale winds on, leaving the camp smiling and a little spooked before bed.", { tone: "morale" });
        recordStoryBeat("seed", "camp", "Shared a tall campfire tale");
      },
    },
    {
      id: "seed_feral_hogs_raid",
      kind: "minor",
      condition: function (ctx) {
        return ctx.mode === "camp" && hoursSinceFlag("seed_feral_hogs_raid_time") >= 72;
      },
      weight: function () {
        return 3;
      },
      run: async function (ctx) {
        const selection = await presentEncounter({
          id: "seed_feral_hogs_raid",
          title: "Feral hogs nose the camp",
          subtitle: ctx.location,
          body: [
            "Snorts and clattering pots wake the camp. Half-wild hogs root near the stores, tusks flashing in the firelight.",
          ],
          tags: ["camp", "animals"],
          options: [
            { id: "scare", label: "Scare them off", tone: "danger", hint: "Lose a little food." },
            { id: "chase", label: "Chase and hunt", tone: "danger", hint: "Risk a gash; maybe meat." },
          ],
          defaultId: "scare",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("seed_feral_hogs_raid_time", nowHour);
        let logText = "You throw embers and shouting drives the hogs off, with a few rations lost.";
        if (selection === "scare") {
          gameState.supplies.meal_simple = Math.max(0, (gameState.supplies.meal_simple || 0) - 2);
        } else {
          const target = choice(ctx.people || getAllPeople());
          const injury = Math.random() < 0.3 && target;
          if (injury) {
            target.condition = clamp((target.condition || 50) - 7, 0, 100);
            addAffliction(target, "sprain", { severity: 1 });
          }
          const haul = injury ? randInt(2, 4) : randInt(4, 7);
          gameState.supplies.fresh_meat = (gameState.supplies.fresh_meat || 0) + haul;
          logText = injury
            ? target.name + " drives the hogs, taking a bruise but bringing back a few cuts of meat."
            : "The camp circles the hogs and brings down a few, filling the larder with fresh meat.";
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("seed", "camp", "Hogs raided the camp", { choice: selection });
      },
    },
    {
      id: "minor_break",
      kind: "minor",
      condition: function (ctx) {
        return !!ctx.pendingBreakPerson;
      },
      weight: function () {
        return 10;
      },
      run: function (ctx) {
        const p = ctx.pendingBreakPerson;
        if (!p) return;
        ctx.storyState.eventFlags["pending_break_" + p.id] = false;
        addLog(
          p.name + " begs off chores, too worn in spirit to help for a while.",
          {
            tone: "morale",
            characters: [p.id],
            tag: "DAY " + ctx.dayTag,
            location: ctx.location,
          }
        );
        addThought(p, {
          id: "minor_break",
          label: "Shaken nerves",
          value: -5,
          hoursLeft: 10,
          source: "morale",
        });
        ctx.storyState.tension = clamp(ctx.storyState.tension + 4, 0, 100);
        ctx.storyState.hoursSinceMinorEvent = 0;
      },
    },
    // River drama events
    {
      id: "river_debate_and_delay",
      kind: "minor",
      minTension: 16,
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        const w = ctx.weather || {};
        return (
          (loc.indexOf("river") >= 0 || loc.indexOf("ford") >= 0) &&
          (w.precip === "rain" || w.storm || ctx.storyState.risk.soaked)
        );
      },
      weight: function (ctx) {
        return 6 + (ctx.storyState.tension > 30 ? 3 : 0);
      },
      run: function (ctx) {
        addLog(
          "Hours go to scouting and arguing over the crossing. By dusk you have little to show but wet boots and frayed nerves.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        gameState.lastHourMiles = Math.max(0, (gameState.lastHourMiles || 0) - 1);
        ctx.people.forEach(function (p) {
          addThought(p, {
            id: "river_argue",
            label: "Argued at the ford",
            value: -3,
            hoursLeft: 8,
            source: "river",
          });
        });
        ctx.storyState.tension = clamp(ctx.storyState.tension + 2, 0, 100);
      },
    },
    {
      id: "river_wagon_swept",
      kind: "major",
      minTension: 24,
      condition: function (ctx) {
        const w = ctx.weather || {};
        return ctx.gameState.highRiverRisk || w.storm || ctx.storyState.risk.soaked;
      },
      weight: function (ctx) {
        return 6 + (ctx.storyState.risk.overloaded_wagon ? 4 : 0);
      },
      run: function (ctx) {
        const people = ctx.people.slice();
        if (!people.length) return;
        const victim = choice(people);
        const rescuer = choice(people.filter(function (p) { return p.id !== victim.id; })) || victim;
        addLog(
          victim.name +
            " slips as the wagon lurches. For a moment the current seizes them before " +
            rescuer.name +
            " drags them to a snagging branch.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [victim.id, rescuer.id] }
        );
        adjustOpinion(victim, rescuer, 12, "rescued");
        addThought(victim, {
          id: "river_rescued",
          label: "Pulled from the river",
          value: 8,
          hoursLeft: 24,
          source: "river",
        });
        addThought(rescuer, {
          id: "river_rescuer",
          label: "Risked myself in the river",
          value: -2,
          hoursLeft: 12,
          source: "river",
        });
        recordRescueEvent(rescuer, victim, "river_swept", ctx);
        gameState.wagonCondition = clamp(gameState.wagonCondition - 10, 0, 100);
        ctx.storyState.risk.overloaded_wagon = true;
      },
    },
    {
      id: "river_good_signs",
      kind: "breather",
      minTension: 10,
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        return loc.indexOf("river") >= 0 && !ctx.storyState.risk.soaked;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        addLog(
          "The river runs lower than expected. You wade across with steady footing and spirits lift.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.people.forEach(function (p) {
          addThought(p, {
            id: "river_relief",
            label: "River went well",
            value: 4,
            hoursLeft: 10,
            source: "river",
          });
        });
      },
    },
    // Illness cascade events
    {
      id: "illness_simmering_fever",
      kind: "minor",
      condition: function (ctx) {
        return ctx.storyState.risk.cold_exposure && ctx.people.some(function (p) { return hasAffliction(p, "dysentery") || hasAffliction(p, "camp_fever"); });
      },
      weight: function () {
        return 8;
      },
      run: function (ctx) {
        addLog(
          "Feverish faces around the fire make the camp whisper about what a cold, soaked night might bring.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.people.forEach(function (p) {
          addThought(p, {
            id: "fever_worry",
            label: "Worried about fevers",
            value: -4,
            hoursLeft: 12,
            source: "illness",
          });
        });
      },
    },
    {
      id: "illness_crisis_night",
      kind: "major",
      minTension: 26,
      condition: function (ctx) {
        const night = isNight(ctx.gameState.date);
        const severe = ctx.people.some(function (p) {
          return p.afflictions && p.afflictions.some(function (a) { return a && a.stage === "acute"; });
        });
        return night && severe && (ctx.storyState.risk.behind_schedule || ctx.storyState.risk.cold_exposure);
      },
      weight: function () {
        return 7;
      },
      run: function (ctx) {
        const sick = ctx.people.filter(function (p) {
          return p.afflictions && p.afflictions.some(function (a) { return a && a.stage === "acute"; });
        });
        if (!sick.length) return;
        const patient = choice(sick);
        addLog(
          "Night stretches on as " +
            patient.name +
            " fights fevered shivers. No miles made—just damp cloths, whispered prayers, and a late start to come.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [patient.id] }
        );
        addThought(patient, {
          id: "fever_crisis",
          label: "Burning fever",
          value: -8,
          hoursLeft: 16,
          source: "illness",
        });
        ctx.storyState.risk.behind_schedule = true;
      },
    },
    {
      id: "illness_turning_point",
      kind: "breather",
      maxTension: 55,
      condition: function (ctx) {
        return ctx.storyState.risk.behind_schedule && !ctx.storyState.risk.extended_starvation;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        addLog(
          "After days of tending, the worst of the fever breaks. The camp breathes easier and tidies the scattered gear.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.storyState.risk.behind_schedule = false;
        ctx.people.forEach(function (p) {
          addThought(p, {
            id: "fever_broke",
            label: "Fever finally broke",
            value: 6,
            hoursLeft: 14,
            source: "illness",
          });
        });
      },
    },
    {
      id: "fort_hospital_care",
      kind: "breather",
      condition: function (ctx) {
        const atFort = (ctx.location || "").toLowerCase().indexOf("fort") >= 0;
        if (!atFort) return false;
        const serious = ctx.people.some(function (p) {
          return (
            p &&
            p.afflictions &&
            p.afflictions.some(function (a) {
              return a && !a.resolved && a.stage === "acute";
            })
          );
        });
        const flagKey = "fort_hospital_" + (ctx.location || "fort");
        return serious && !ctx.storyState.eventFlags[flagKey];
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        const flagKey = "fort_hospital_" + (ctx.location || "fort");
        ctx.storyState.eventFlags[flagKey] = true;
        const cost = 18;
        if (ctx.gameState.money && ctx.gameState.money > cost) {
          ctx.gameState.money = Math.max(0, ctx.gameState.money - cost);
          ctx.people.forEach(function (p) {
            if (!p || !p.afflictions) return;
            p.afflictions.forEach(function (a) {
              if (!a || a.resolved) return;
              a.reliefHours = (a.reliefHours || 0) + 8;
              a.tendedThisHour = true;
            });
          });
          addLog(
            "The fort’s surgeon lances abscesses, sets splints, and shares tonic. It costs $" +
              cost +
              " but the care steadies the sick.",
            { tone: "event", location: ctx.location }
          );
        } else {
          addLog(
            "A hospital tent stands near the palisade, but funds are too thin for extended care.",
            { tone: "warning", location: ctx.location }
          );
        }
      },
    },
    {
      id: "fort_sutler_quick_trade",
      kind: "breather",
      condition: function (ctx) {
        const atFort = (ctx.location || "").toLowerCase().indexOf("fort") >= 0;
        return atFort && ctx.mode !== "travel" && hoursSinceFlag("fort_sutler_time") >= 120;
      },
      weight: function () {
        return 4;
      },
      run: async function (ctx) {
        const terms = getTradeTermsForFaction("forts");
        const ammoGain = Math.max(1, Math.round(3 * terms.gainMult));
        const ammoCost = Math.max(3, Math.round(7 * terms.costMult));
        const medGain = Math.max(1, Math.round(1 * terms.gainMult));
        const medCost = Math.max(4, Math.round(10 * terms.costMult));
        const sellPayout = Math.max(3, Math.round(6 * terms.gainMult));
        const hasAxle = (gameState.supplies.axles || 0) > 0;
        const hasWheel = (gameState.supplies.wheels || 0) > 0;
        const hasFlour = (gameState.supplies.flour || 0) >= 5;
        const selection = await presentEncounter({
          id: "fort_sutler_quick_trade",
          title: "Sutler's counter",
          subtitle: ctx.location,
          body: [
            "A sutler at the fort's gate offers quick trades before the wagon rolls on.",
          ],
          tags: ["trade", "fort"],
          options: [
            {
              id: "buy_ammo",
              label: `Buy ammo (${ammoGain} rounds for $${ammoCost})`,
              tone: "neutral",
              hint: `${terms.label} terms apply.`,
            },
            {
              id: "buy_med",
              label: `Buy medicine (${medGain} dose for $${medCost})`,
              tone: "neutral",
              hint: `${terms.label} terms apply.`,
            },
            {
              id: "sell_parts",
              label: hasAxle || hasWheel || hasFlour
                ? "Sell a spare (axle/wheel or 5 flour)"
                : "No surplus to sell",
              tone: hasAxle || hasWheel || hasFlour ? "warm" : "neutral",
              hint: hasAxle || hasWheel || hasFlour
                ? `Earn $${sellPayout} on ${terms.label} terms.`
                : "You lack parts or flour to spare.",
            },
            { id: "pass", label: "Decline", tone: "neutral", hint: "Move along." },
          ],
          defaultId: "buy_ammo",
        });
        const nowHour = getCurrentTrailHour(gameState);
        setEventFlag("fort_sutler_time", nowHour);
        let logText = "You nod to the sutler and keep moving.";
        if (selection === "buy_ammo") {
          if ((gameState.money || 0) >= ammoCost) {
            gameState.money = Math.max(0, (gameState.money || 0) - ammoCost);
            gameState.supplies.ammo = (gameState.supplies.ammo || 0) + ammoGain;
            adjustFactionRep("forts", 2, null, ctx);
            logText = `You pay $${ammoCost} for cartridges and tuck ${ammoGain} into the chest.`;
          } else {
            logText = "Short on cash, you leave the cartridges behind.";
          }
        } else if (selection === "buy_med") {
          if ((gameState.money || 0) >= medCost) {
            gameState.money = Math.max(0, (gameState.money || 0) - medCost);
            gameState.supplies.med_kits = (gameState.supplies.med_kits || 0) + medGain;
            adjustFactionRep("forts", 2, null, ctx);
            logText = `The sutler slips over ${medGain} dose of tonic for $${medCost}.`;
          } else {
            logText = "You count your coins twice and decide to save them.";
          }
        } else if (selection === "sell_parts") {
          if (hasAxle) {
            gameState.supplies.axles = Math.max(0, (gameState.supplies.axles || 0) - 1);
            gameState.money = (gameState.money || 0) + sellPayout;
            adjustFactionRep("forts", 1, null, ctx);
            logText = `You part with a spare axle and take $${sellPayout} in return.`;
          } else if (hasWheel) {
            gameState.supplies.wheels = Math.max(0, (gameState.supplies.wheels || 0) - 1);
            gameState.money = (gameState.money || 0) + sellPayout;
            adjustFactionRep("forts", 1, null, ctx);
            logText = `You sell a wheel to the sutler and pocket $${sellPayout}.`;
          } else if (hasFlour) {
            gameState.supplies.flour = Math.max(0, (gameState.supplies.flour || 0) - 5);
            gameState.money = (gameState.money || 0) + Math.max(2, Math.round(sellPayout * 0.6));
            adjustFactionRep("forts", 1, null, ctx);
            logText = "You swap a small sack of flour for travel money.";
          } else {
            logText = "With nothing spare, you wave off the offer.";
          }
        }
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("trade", "fort", "Quick sutler trade", { choice: selection });
      },
    },
    {
      id: "camp_quarantine_outbreak",
      kind: "major",
      minTension: 18,
      condition: function (ctx) {
        const shared = ctx.people.filter(function (p) {
          return p && p.afflictions && p.afflictions.some(function (a) {
            return a && !a.resolved && a.stage === "acute" && (a.id === "dysentery" || a.id === "cholera");
          });
        });
        return shared.length >= 2 && ctx.storyState.risk.bad_water;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        addLog(
          "Illness spreads through camp. You post a quarantine and lose a day calming the sick and boiling every drop of water.",
          { tone: "event", location: ctx.location }
        );
        ctx.storyState.eventFlags.forcedCampHours = 24;
        ctx.storyState.risk.behind_schedule = true;
        ctx.people.forEach(function (p) {
          if (!p) return;
          p.morale = clamp((p.morale || 50) - 4, 0, 100);
        });
      },
    },
    // Mental break events
    {
      id: "minor_break_snapped_at_camp",
      kind: "minor",
      minTension: 12,
      condition: function (ctx) {
        return ctx.pendingBreakPerson && ctx.storyState.risk.low_morale;
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        const p = ctx.pendingBreakPerson;
        if (!p) return;
        ctx.storyState.eventFlags["pending_break_" + p.id] = false;
        p.lastBreakHour = (p.lastBreakHour || 0) + 6;
        addLog(
          p.name + " slams tools down and stalks off for a while, chores left half-done and tempers raw.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [p.id] }
        );
        addThought(p, {
          id: "snap_camp",
          label: "Snapped at camp",
          value: -6,
          hoursLeft: 10,
          source: "morale",
        });
        ctx.storyState.tension = clamp(ctx.storyState.tension + 3, 0, 100);
        ctx.storyState.eventFlags.recentBreak = {
          personId: p.id,
          day: ctx.dayTag,
          severity: "minor",
        };
      },
    },
    {
      id: "major_break_refuse_travel",
      kind: "major",
      minTension: 24,
      condition: function (ctx) {
        return ctx.pendingBreakPerson && ctx.pendingBreakPerson.moodState === "Broken";
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        const p = ctx.pendingBreakPerson;
        if (!p) return;
        ctx.storyState.eventFlags["pending_break_" + p.id] = false;
        ctx.storyState.eventFlags.forcedCampHours = Math.max(
          ctx.storyState.eventFlags.forcedCampHours || 0,
          8
        );
        p.lowMoraleHours = 0;
        addLog(
          p.name +
            " refuses to take another step today. The wagon circle holds for hours while they sit apart from the fire.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [p.id] }
        );
        addThought(p, {
          id: "after_break",
          label: "Emptied out but calmer",
          value: 5,
          hoursLeft: 18,
          source: "morale",
        });
        ctx.storyState.eventFlags.recentBreak = {
          personId: p.id,
          day: ctx.dayTag,
          severity: "major",
        };
      },
    },
    {
      id: "major_break_storming_off_to_hunt",
      kind: "major",
      minTension: 18,
      condition: function (ctx) {
        return ctx.pendingBreakPerson && ctx.storyState.risk.starvation;
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        const p = ctx.pendingBreakPerson;
        if (!p) return;
        ctx.storyState.eventFlags["pending_break_" + p.id] = false;
        const success = Math.random() < 0.45;
        if (success) {
          gameState.supplies.meat = (gameState.supplies.meat || 0) + 12;
          addLog(
            p.name +
              " storms off with a rifle and returns at dusk blood-spattered but triumphant with fresh meat.",
            { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [p.id] }
          );
          addThought(p, { id: "risked_for_food", label: "Hunted alone", value: 4, hoursLeft: 16, source: "morale" });
        } else {
          p.condition = clamp(p.condition - 8, 0, 100);
          addLog(
            p.name +
              " vanishes to hunt and limps back empty-handed, scraped and chilled after hours in the brush.",
            { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [p.id] }
          );
          addThought(p, { id: "hunt_failure", label: "Lonely, cold hunt", value: -6, hoursLeft: 12, source: "morale" });
        }
        ctx.storyState.eventFlags.recentBreak = {
          personId: p.id,
          day: ctx.dayTag,
          severity: success ? "major_lifeline" : "major",
        };
      },
    },
    {
      id: "major_break_leadership_dispute",
      kind: "major",
      minTension: 28,
      condition: function (ctx) {
        return ctx.rivalPair && (ctx.storyState.risk.behind_schedule || ctx.storyState.risk.low_morale);
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        const pair = ctx.rivalPair;
        const a = pair[0];
        const b = pair[1];
        const winner = (a.morale || 0) >= (b.morale || 0) ? a : b;
        const loser = winner === a ? b : a;
        addLog(
          winner.name +
            " and " +
            loser.name +
            " clash over the route. Voices carry until one backs down.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [a.id, b.id] }
        );
        adjustOpinion(loser, winner, -8, "dispute");
        adjustOpinion(winner, loser, -2, "dispute");
        addThought(winner, { id: "vindicated", label: "Stood my ground", value: 5, hoursLeft: 16, source: "social" });
        addThought(loser, { id: "humiliated", label: "Questioned leadership", value: -7, hoursLeft: 20, source: "social" });
      },
    },
    {
      id: "leadership_dispute",
      kind: "major",
      minTension: 30,
      condition: function (ctx) {
        return (
          ctx.leadershipDisputePair &&
          ctx.risk.low_morale &&
          ctx.risk.behind_schedule &&
          ctx.storyState.tension >= 30
        );
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        const pair = ctx.leadershipDisputePair;
        if (!pair) return;
        const challenger = pair.challenger;
        const leader = pair.leader;
        addLog(
          challenger.name +
            " questions " +
            leader.name +
            " about the pace and risky calls. Voices rise until the camp gathers to settle it.",
          { tone: "event", location: ctx.location, characters: [challenger.id, leader.id] }
        );
        adjustOpinion(challenger, leader, -6, "leadership_dispute");
        adjustOpinion(leader, challenger, -3, "leadership_dispute");
        addThought(challenger, { id: "spoke_up", label: "Spoke up", value: 3, hoursLeft: 10, source: "social" });
        addThought(leader, { id: "challenged", label: "Challenged authority", value: -4, hoursLeft: 12, source: "social" });
        ctx.storyState.risk.low_morale = true;
        ctx.storyState.leadershipDisputeState = {
          active: true,
          heat: 4.5,
          challengerId: challenger.id,
          leaderId: leader.id,
          lastHour: getCurrentTrailHour(gameState),
        };
        recordStoryBeat(
          "leadership",
          "leadership",
          challenger.name + " challenged " + leader.name + " about the trail decisions",
          {
            challenger: challenger.id,
            leader: leader.id,
          }
        );
      },
    },
    {
      id: "leadership_council_choice",
      kind: "major",
      minTension: 26,
      condition: function (ctx) {
        const state = ctx.storyState.leadershipDisputeState || {};
        return state.active && (state.heat || 0) >= 3 && !ctx.storyState.eventFlags.leader_council;
      },
      weight: function () {
        return 3;
      },
      run: async function (ctx) {
        const state = ctx.storyState.leadershipDisputeState || {};
        const challenger = ctx.people.find(function (p) { return state.challengerId === p.id; }) || ctx.leadershipDisputePair && ctx.leadershipDisputePair.challenger;
        const leader = getActiveLeader();
        if (!challenger || !leader) return;
        ctx.storyState.eventFlags.leader_council = true;
        const choiceId = await presentEncounter({
          id: "leadership_council_choice",
          title: "Leadership council",
          subtitle: formatDateTime(gameState.date) + " · " + (ctx.location || "Camp"),
          body: [
            "Raised voices around the fire draw the group into a council. " +
              challenger.name +
              " argues for a steadier hand, while " +
              leader.name +
              " claims the trail needs consistency.",
          ],
          tags: ["social", "camp"],
          options: [
            { id: "stay", label: "Back " + leader.name, tone: "neutral", hint: "Keep the current reins despite tension." },
            {
              id: "elevate",
              label: "Let " + challenger.name + " lead for a stretch",
              tone: "warm",
              hint: "A change might steady nerves if things are rough.",
            },
            {
              id: "compromise",
              label: "Split duties",
              tone: "danger",
              hint: "Scout-leading and final say shared to cool tempers.",
            },
          ],
          defaultId: "stay",
        });
        const struggling = ctx.risk.low_morale || ctx.risk.behind_schedule || (ctx.storyState.tension || 0) > 45;
        if (choiceId === "elevate" && struggling && !ctx.storyState.eventFlags.leader_swap_done) {
          gameState.actingLeaderId = challenger.id;
          adjustOpinion(challenger, leader, 2, "acting_leader");
          adjustOpinion(leader, challenger, -6, "acting_leader");
          addLog(
            "Camp votes to let " +
              challenger.name +
              " lead decisions for a stretch while " +
              leader.name +
              " steps back.",
            { tone: "event", characters: [challenger.id, leader.id] }
          );
          recordStoryBeat("leadership", "leadership", challenger.name + " became acting leader", { personId: challenger.id });
          ctx.storyState.eventFlags.leader_swap_done = true;
        } else if (choiceId === "compromise") {
          addLog("You broker a compromise: the challenger scouts and the leader keeps final say.", { tone: "event" });
          adjustOpinion(challenger, leader, -1, "compromise");
          ctx.storyState.leadershipDisputeState.heat = Math.max(0, (ctx.storyState.leadershipDisputeState.heat || 0) - 2);
        } else {
          addLog(leader.name + " keeps the reins after a tense vote.", { tone: "event" });
          adjustOpinion(challenger, leader, -4, "shut_down");
          ctx.storyState.leadershipDisputeState.heat = Math.max(0, (ctx.storyState.leadershipDisputeState.heat || 0) - 1);
        }
        recordCascadePersonEvent(challenger.id, "leadership", { target: leader.id, choice: choiceId });
      },
    },
    // Relationship arcs
    {
      id: "break_followup_apology",
      kind: "breather",
      maxTension: 64,
      condition: function (ctx) {
        const flag = ctx.storyState.eventFlags.recentBreak;
        return (
          flag &&
          ctx.gameState.mode === "camp" &&
          ctx.risk.low_morale &&
          ctx.storyState.tension < 70
        );
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        const flag = ctx.storyState.eventFlags.recentBreak;
        if (!flag) return;
        const person = ctx.people.find(function (p) {
          return p && p.id === flag.personId;
        });
        if (!person) return;
        addLog(
          person.name +
            " returns to the fire quietly, offering an apology and taking up small chores to make amends.",
          { tone: "morale", location: ctx.location, characters: [person.id] }
        );
        person.morale = clamp((person.morale || 50) + 4, 0, 100);
        ctx.people.forEach(function (p) {
          if (!p || p.id === person.id) return;
          adjustOpinion(p, person, 2, "break_followup");
        });
        ctx.storyState.eventFlags.recentBreak = null;
        recordStoryBeat("break_followup", "social", person.name + " returned to duties after cooling off", {
          personId: person.id,
        });
      },
    },
    {
      id: "break_followup_resentment",
      kind: "minor",
      minTension: 24,
      condition: function (ctx) {
        const flag = ctx.storyState.eventFlags.recentBreak;
        return flag && ctx.risk.low_morale && ctx.storyState.tension >= 60;
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        const flag = ctx.storyState.eventFlags.recentBreak;
        if (!flag) return;
        const person = ctx.people.find(function (p) {
          return p && p.id === flag.personId;
        });
        if (!person) return;
        addLog(
          person.name +
            " keeps to themselves after the outburst, doing only the bare minimum. The mood around camp stays brittle.",
          { tone: "warning", location: ctx.location, characters: [person.id] }
        );
        person.morale = clamp((person.morale || 50) - 3, 0, 100);
        ctx.storyState.eventFlags.recentBreak = null;
        ctx.storyState.risk.low_morale = true;
        recordStoryBeat(
          "break_followup",
          "social",
          person.name + " stayed sullen after their break",
          { personId: person.id }
        );
      },
    },
    {
      id: "romance_under_stars",
      kind: "breather",
      maxTension: 55,
      condition: function (ctx) {
        return ctx.strongBondPair && ctx.gameState.mode === "camp" && !ctx.storyState.risk.no_guard;
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        const pair = ctx.strongBondPair;
        if (!pair) return;
        const key = "romance:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key] || { stage: 0, tag: "romance" };
        addLog(
          pair[0].name +
            " and " +
            pair[1].name +
            " share quiet stories by the coals. The camp moves softly around them.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [pair[0].id, pair[1].id] }
        );
        pair.forEach(function (p) {
          addThought(p, { id: "quiet_moment", label: "Quiet moment under stars", value: 6, hoursLeft: 12, source: "social" });
        });
        ctx.storyState.socialArcs[key] = Object.assign({}, arc, { stage: Math.max(1, arc.stage || 0) });
        adjustOpinion(pair[0], pair[1], 3, "romance_seed");
        adjustOpinion(pair[1], pair[0], 2, "romance_seed");
        recordStoryBeat("social", "romance", pair[0].name + " and " + pair[1].name + " grew closer under the stars", {
          arc: key,
          stage: 1,
        });
      },
    },
    {
      id: "romance_stargazing",
      kind: "breather",
      maxTension: 60,
      condition: function (ctx) {
        const pair = ctx.strongBondPair;
        if (!pair) return false;
        const key = "romance:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key];
        return arc && arc.stage >= 1 && (!arc.stage || arc.stage < 2) && ctx.gameState.mode === "camp";
      },
      weight: function () {
        return 3;
      },
      run: function (ctx) {
        const pair = ctx.strongBondPair;
        const key = "romance:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key] || { stage: 1, tag: "romance" };
        addLog(
          pair[0].name +
            " points out constellations and " +
            pair[1].name +
            " laughs quietly. A warmth settles over camp despite the long road ahead.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [pair[0].id, pair[1].id] }
        );
        adjustOpinion(pair[0], pair[1], 5, "romance_stargazing");
        adjustOpinion(pair[1], pair[0], 5, "romance_stargazing");
        pair.forEach(function (p) {
          addThought(p, { id: "romance_stars", label: "Shared stargazing", value: 5, hoursLeft: 18, source: "social" });
        });
        ctx.storyState.socialArcs[key] = Object.assign({}, arc, { stage: Math.max(2, arc.stage || 1) });
        recordStoryBeat("social", "romance", "Romance deepened under the night sky", { arc: key, stage: 2 });
      },
    },
    {
      id: "romance_confession",
      kind: "minor",
      minTension: 18,
      maxTension: 70,
      condition: function (ctx) {
        const pair = ctx.strongBondPair;
        if (!pair) return false;
        const key = "romance:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key];
        const rel = pair[0].relationships && pair[0].relationships[pair[1].id];
        return arc && arc.stage >= 2 && (!arc.stage || arc.stage < 3) && rel && rel.opinion >= 70;
      },
      weight: function () {
        return 3;
      },
      run: function (ctx) {
        const pair = ctx.strongBondPair;
        const key = "romance:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key] || { stage: 2, tag: "romance" };
        addLog(
          pair[0].name +
            " admits how much " +
            pair[1].name +
            " has come to mean to them. The confession draws knowing smiles from the rest of camp.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [pair[0].id, pair[1].id] }
        );
        adjustOpinion(pair[0], pair[1], 8, "romance_confession");
        adjustOpinion(pair[1], pair[0], 7, "romance_confession");
        pair.forEach(function (p) {
          addThought(p, { id: "romance_confessed", label: "Confession shared", value: 7, hoursLeft: 30, source: "social" });
        });
        ctx.storyState.socialArcs[key] = Object.assign({}, arc, { stage: Math.max(3, arc.stage || 2) });
        recordStoryBeat("social", "romance", "A confession of affection brightened the trail", { arc: key, stage: 3 });
      },
    },
    {
      id: "romance_commitment",
      kind: "major",
      minTension: 15,
      maxTension: 65,
      condition: function (ctx) {
        const pair = ctx.strongBondPair;
        if (!pair) return false;
        const key = "romance:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key];
        const rel = pair[0].relationships && pair[0].relationships[pair[1].id];
        return arc && arc.stage >= 3 && rel && rel.opinion >= 80 && ctx.dayTag > 20;
      },
      weight: function () {
        return 2;
      },
      run: function (ctx) {
        const pair = ctx.strongBondPair;
        const key = "romance:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key] || { stage: 3, tag: "romance" };
        addLog(
          pair[0].name +
            " and " +
            pair[1].name +
            " promise to see the journey through together. The pledge steadies everyone nearby.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [pair[0].id, pair[1].id] }
        );
        adjustOpinion(pair[0], pair[1], 10, "romance_commitment");
        adjustOpinion(pair[1], pair[0], 9, "romance_commitment");
        pair.forEach(function (p) {
          addThought(p, { id: "romance_commit", label: "Committed on the trail", value: 9, hoursLeft: 60, source: "social" });
        });
        ctx.storyState.socialArcs[key] = Object.assign({}, arc, { stage: Math.max(4, arc.stage || 3) });
        recordStoryBeat("social", "romance", "A lasting commitment formed on the trail", { arc: key, stage: 4 });
      },
    },
    {
      id: "romance_triangle_tension",
      kind: "minor",
      minTension: 26,
      maxTension: 78,
      condition: function (ctx) {
        const tri = ctx.loveTriangle;
        if (!tri) return false;
        const key = "romance:" + getPairKey(tri.a, tri.b);
        const arc = ctx.storyState.socialArcs[key];
        return arc && arc.stage >= 3;
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        const tri = ctx.loveTriangle;
        if (!tri) return;
        const triangleKey = "triangle:" + getPairKey(tri.a, tri.b) + ":" + tri.c.id;
        const arc = ctx.storyState.socialArcs[triangleKey] || { stage: 0, tag: "triangle" };
        addLog(
          tri.c.name +
            " walks in on " +
            tri.a.name +
            " and " +
            tri.b.name +
            " sharing an intimate moment by the fire. Awkward silence hangs in the air.",
          { tone: "social", location: ctx.location, characters: [tri.a.id, tri.b.id, tri.c.id] }
        );
        addThought(tri.c, { id: "jealous", label: "Jealous", value: -5, hoursLeft: 12, source: "social" });
        adjustOpinion(tri.c, tri.a, -4, "triangle" );
        adjustOpinion(tri.c, tri.b, -4, "triangle" );
        ctx.storyState.socialArcs[triangleKey] = Object.assign({}, arc, { stage: Math.max(1, arc.stage || 0) });
        recordStoryBeat("social", "romance", tri.c.name + " felt shut out of a budding romance", {
          triangle: triangleKey,
        });
      },
    },
    {
      id: "romance_triangle_drift",
      kind: "breather",
      minTension: 12,
      maxTension: 72,
      condition: function (ctx) {
        const tri = ctx.loveTriangle;
        if (!tri) return false;
        const triangleKey = "triangle:" + getPairKey(tri.a, tri.b) + ":" + tri.c.id;
        const arc = ctx.storyState.socialArcs[triangleKey];
        return arc && arc.stage >= 1 && ctx.storyState.risk.low_morale === false;
      },
      weight: function () {
        return 3;
      },
      run: function (ctx) {
        const tri = ctx.loveTriangle;
        if (!tri) return;
        const triangleKey = "triangle:" + getPairKey(tri.a, tri.b) + ":" + tri.c.id;
        const arc = ctx.storyState.socialArcs[triangleKey] || { stage: 1, tag: "triangle" };
        addLog(
          "Around the evening fire, " +
            tri.c.name +
            " keeps to their own bedroll while " +
            tri.a.name +
            " and " +
            tri.b.name +
            " talk softly. The tension eases but leaves an ache.",
          { tone: "morale", location: ctx.location, characters: [tri.a.id, tri.b.id, tri.c.id] }
        );
        adjustOpinion(tri.a, tri.b, 2, "triangle_soften");
        adjustOpinion(tri.b, tri.a, 2, "triangle_soften");
        addThought(tri.c, { id: "lonely_triangle", label: "Keeping distance", value: -2, hoursLeft: 10, source: "social" });
        ctx.storyState.socialArcs[triangleKey] = Object.assign({}, arc, { stage: Math.max(2, arc.stage || 1) });
        recordStoryBeat("social", "romance", "A love triangle cooled into uneasy distance", {
          triangle: triangleKey,
        });
      },
    },
    {
      id: "romance_triangle_choice",
      kind: "minor",
      minTension: 18,
      maxTension: 70,
      condition: function (ctx) {
        const tri = ctx.loveTriangle;
        if (!tri) return false;
        const triangleKey = "triangle:" + getPairKey(tri.a, tri.b) + ":" + tri.c.id;
        const arc = ctx.storyState.socialArcs[triangleKey];
        return arc && arc.stage >= 2 && !ctx.storyState.eventFlags[triangleKey + ":choice"];
      },
      weight: function () {
        return 3;
      },
      run: async function (ctx) {
        const tri = ctx.loveTriangle;
        if (!tri) return;
        const triangleKey = "triangle:" + getPairKey(tri.a, tri.b) + ":" + tri.c.id;
        const choice = await presentEncounter({
          id: "romance_triangle_choice",
          title: "Whispers by the fire",
          subtitle: formatDateTime(gameState.date) + " · " + (ctx.location || "Camp"),
          body: [
            tri.a.name +
              " and " +
              tri.b.name +
              " trade glances while " +
              tri.c.name +
              " watches. The tension hangs over camp chores.",
          ],
          tags: ["social", "camp"],
          options: [
            { id: "bless", label: "Let the romance breathe", tone: "warm", hint: "Might leave someone hurt." },
            { id: "cool", label: "Ask them to cool it", tone: "neutral", hint: "Keep the peace until a fort." },
            { id: "focus", label: "Shut it down for survival", tone: "danger", hint: "Feelings bruised but work continues." },
          ],
          defaultId: "cool",
        });
        if (choice === "bless") {
          adjustOpinion(tri.a, tri.b, 4, "triangle_choice");
          adjustOpinion(tri.b, tri.a, 3, "triangle_choice");
          addThought(tri.c, { id: "triangle_left_out", label: "Left out", value: -6, hoursLeft: 16, source: "social" });
          addLog(tri.a.name + " and " + tri.b.name + " pair off openly. " + tri.c.name + " keeps their distance.", { tone: "social" });
        } else if (choice === "cool") {
          addThought(tri.a, { id: "triangle_pause", label: "Agreed to pause", value: -2, hoursLeft: 10, source: "social" });
          addThought(tri.b, { id: "triangle_pause2", label: "Agreed to pause", value: -2, hoursLeft: 10, source: "social" });
          adjustOpinion(tri.c, tri.a, 2, "triangle_pause");
          adjustOpinion(tri.c, tri.b, 2, "triangle_pause");
          addLog("You ask the would-be couple to cool things until the next fort.", { tone: "social" });
        } else {
          addLog("You shut the talk down and steer conversation back to maps and chores.", { tone: "warning" });
          [tri.a, tri.b, tri.c].forEach(function (p) {
            addThought(p, { id: "triangle_shut", label: "Tension shelved", value: -1, hoursLeft: 8, source: "social" });
          });
        }
        ctx.storyState.socialArcs[triangleKey] = Object.assign({}, ctx.storyState.socialArcs[triangleKey], {
          stage: Math.max(2, ctx.storyState.socialArcs[triangleKey].stage || 1),
        });
        ctx.storyState.eventFlags[triangleKey + ":choice"] = true;
        recordStoryBeat("social", "romance", "Triangle handled by camp council", { triangle: triangleKey });
      },
    },
    {
      id: "camp_gratitude_for_cook",
      kind: "breather",
      maxTension: 70,
      condition: function (ctx) {
        return (
          ctx.mode === "camp" &&
          ctx.lastHourCampTasks &&
          ctx.lastHourCampTasks.cookedById &&
          !ctx.lastHourTaskFailures.burnedMealById &&
          (ctx.block === "evening" || ctx.block === "morning")
        );
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        const cookId = ctx.lastHourCampTasks.cookedById;
        const cook = ctx.people.find(function (p) {
          return p && p.id === cookId;
        });
        if (!cook) return;
        const others = ctx.people.filter(function (p) {
          return p && p.id !== cookId;
        });
        addLog(
          "Around the fire, the party quietly thanks " +
            cook.name +
            " for the meal. Warm bowls and softer voices make the camp feel closer.",
          { tone: "morale", location: ctx.location, characters: [cook.id] }
        );
        cook.morale = clamp((cook.morale || 50) + 4, 0, 100);
        others.slice(0, 2).forEach(function (p) {
          adjustOpinion(p, cook, 3, "camp_gratitude");
        });
        recordStoryBeat("social", "gratitude", cook.name + " was thanked for cooking", { personId: cook.id });
      },
    },
    {
      id: "camp_blame_for_screwup",
      kind: "minor",
      minTension: 18,
      condition: function (ctx) {
        return (
          (ctx.lastHourTaskFailures.burnedMealById || ctx.lastHourTaskFailures.badRepairById) &&
          (ctx.risk.behind_schedule || ctx.risk.starvation)
        );
      },
      weight: function () {
        return 7;
      },
      run: function (ctx) {
        const blameId =
          ctx.lastHourTaskFailures.burnedMealById || ctx.lastHourTaskFailures.badRepairById;
        const blamed = ctx.people.find(function (p) {
          return p && p.id === blameId;
        });
        if (!blamed) return;
        const accuser = choice(
          ctx.people.filter(function (p) {
            return p && p.id !== blameId;
          })
        );
        addLog(
          (accuser ? accuser.name + " snaps that " : "Someone snaps that ") +
            " mistakes are slowing the wagon. Tempers fray as miles slip away.",
          { tone: "warning", location: ctx.location, characters: [blameId] }
        );
        adjustOpinion(accuser || ctx.people[0], blamed, -5, "camp_blame");
        blamed.morale = clamp((blamed.morale || 50) - 4, 0, 100);
        ctx.storyState.risk.low_morale = true;
        recordStoryBeat("social", "camp_blame", "Frustration over chores boiled over", {
          personId: blameId,
        });
      },
    },
    {
      id: "historic_kansas_river_delay",
      kind: "minor",
      minTension: 12,
      maxTension: 70,
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        return ctx.regionKey === "plains" && loc.indexOf("kansas") >= 0 && ctx.block === "morning";
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        addLog(
          "High spring water at the Kansas River forces a careful survey. You lose half a day scouting a safe ford.",
          { tone: "warning", location: ctx.location }
        );
        ctx.storyState.risk.behind_schedule = true;
        recordStoryBeat("historic", "route", "Kansas River delay slowed the party", { location: ctx.location });
      },
    },
    {
      id: "historic_snake_river_thirst",
      kind: "major",
      minTension: 28,
      condition: function (ctx) {
        return ctx.regionKey === "snake_plain" && ctx.risk.water_shortage;
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        addLog(
          "The Snake country bakes under the sun. Water runs low and every mouthful is argued over.",
          { tone: "warning", location: ctx.location }
        );
        ctx.people.forEach(function (p) {
          if (!p) return;
          p.thirst = clamp((p.thirst || 50) - 8, 0, 100);
          addThought(p, { id: "snake_thirst", label: "Parched on the Snake", value: -4, hoursLeft: 10, source: "water" });
        });
        ctx.storyState.risk.water_shortage = true;
        recordStoryBeat("historic", "water", "Snake River thirst tightened tempers", { location: ctx.location });
      },
    },
    {
      id: "historic_fort_clinic",
      kind: "major",
      minTension: 10,
      condition: function (ctx) {
        const atFort = (ctx.location || "").toLowerCase().indexOf("fort") >= 0;
        const serious = ctx.people.some(function (p) {
          return p && p.afflictions && p.afflictions.some(function (a) {
            return a && !a.resolved && a.stage === "acute";
          });
        });
        const flagKey = "historic_clinic_" + (ctx.location || "fort");
        return atFort && serious && !ctx.storyState.eventFlags[flagKey];
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        const flagKey = "historic_clinic_" + (ctx.location || "fort");
        ctx.storyState.eventFlags[flagKey] = true;
        const cost = 25;
        if ((ctx.gameState.money || 0) >= cost) {
          ctx.gameState.money = Math.max(0, ctx.gameState.money - cost);
          const patient = choice(
            ctx.people.filter(function (p) {
              return p && p.afflictions && p.afflictions.some(function (a) { return a && !a.resolved && a.stage === "acute"; });
            })
          );
          if (patient) {
            patient.afflictions.forEach(function (a) {
              if (!a || a.resolved) return;
              a.reliefHours = (a.reliefHours || 0) + 12;
            });
            addThought(patient, { id: "clinic_care", label: "Treated at the fort", value: 6, hoursLeft: 20, source: "illness" });
          }
          addLog(
            "A mission doctor at the fort cleans wounds and mixes tonics. The care costs $" + cost + " but steadies the sick.",
            { tone: "event", location: ctx.location }
          );
          recordStoryBeat("historic", "illness", "Fort clinic care eased an affliction", { location: ctx.location });
        } else {
          addLog("A small clinic sits by the palisade, but you cannot afford its medicines.", {
            tone: "warning",
            location: ctx.location,
          });
        }
      },
    },
    {
      id: "historic_rest_grande_ronde",
      kind: "breather",
      minTension: 10,
      condition: function (ctx) {
        return ctx.regionKey === "blue_mountains" && ctx.risk.behind_schedule && (ctx.risk.starvation || ctx.risk.cold_exposure);
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        addLog(
          "In the Grande Ronde valley, grass and water are plentiful. You rest the stock and gather strength for the passes ahead.",
          { tone: "morale", location: ctx.location }
        );
        ctx.storyState.risk.behind_schedule = false;
        ctx.storyState.risk.starvation = false;
        ctx.people.forEach(function (p) {
          addThought(p, { id: "rest_valley", label: "Rested in a green valley", value: 5, hoursLeft: 14, source: "social" });
        });
        recordStoryBeat("lifeline", "lifeline", "Grande Ronde rest gave the party a breather", { location: ctx.location });
      },
    },
    {
      id: "feud_sniping",
      kind: "minor",
      minTension: 18,
      condition: function (ctx) {
        const pair = ctx.rivalPair;
        if (!pair) return false;
        const key = "feud:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key];
        return (!arc || arc.stage < 2) && ctx.storyState.risk.low_morale;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        const pair = ctx.rivalPair;
        const key = "feud:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key] || { stage: 0, tag: "feud" };
        addLog(
          pair[0].name +
            " and " +
            pair[1].name +
            " trade barbs over chores and pace. The rest of camp pointedly looks away.",
          { tone: "social", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [pair[0].id, pair[1].id] }
        );
        adjustOpinion(pair[0], pair[1], -6, "feud_sniping");
        adjustOpinion(pair[1], pair[0], -5, "feud_sniping");
        ctx.people.forEach(function (p) {
          p.morale = clamp(p.morale - 1, 0, 100);
        });
        ctx.storyState.socialArcs[key] = Object.assign({}, arc, { stage: Math.max(1, arc.stage || 0) });
        recordStoryBeat("social", "feud", "Sniping at camp frayed tempers", { arc: key, stage: 1 });
      },
    },
    {
      id: "feud_public_argument",
      kind: "minor",
      minTension: 22,
      maxTension: 80,
      condition: function (ctx) {
        const pair = ctx.rivalPair;
        if (!pair) return false;
        const key = "feud:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key];
        return arc && arc.stage >= 1 && arc.stage < 3;
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        const pair = ctx.rivalPair;
        const key = "feud:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key] || { stage: 1, tag: "feud" };
        const recentBreak = ctx.pendingBreakPerson && (ctx.pendingBreakPerson.id === pair[0].id || ctx.pendingBreakPerson.id === pair[1].id);
        addLog(
          pair[0].name +
            " and " +
            pair[1].name +
            " argue loudly over how the guard was posted. You step in before it turns physical.",
          { tone: "warning", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [pair[0].id, pair[1].id] }
        );
        adjustOpinion(pair[0], pair[1], -8, "feud_argument");
        adjustOpinion(pair[1], pair[0], -7, "feud_argument");
        ctx.storyState.risk.low_morale = true;
        if (recentBreak) {
          addThought(pair[0], { id: "feud_fragile", label: "Frayed nerves", value: -4, hoursLeft: 18, source: "social" });
          addThought(pair[1], { id: "feud_fragile", label: "Frayed nerves", value: -4, hoursLeft: 18, source: "social" });
        }
        ctx.storyState.socialArcs[key] = Object.assign({}, arc, { stage: Math.max(2, arc.stage || 1) });
        recordStoryBeat("social", "feud", "Public argument rattled camp", { arc: key, stage: 2 });
      },
    },
    {
      id: "feud_showdown",
      kind: "major",
      minTension: 28,
      condition: function (ctx) {
        const pair = ctx.rivalPair;
        if (!pair) return false;
        const key = "feud:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key];
        const rel = pair[0].relationships && pair[0].relationships[pair[1].id];
        return arc && arc.stage >= 2 && rel && rel.opinion <= -40;
      },
      weight: function () {
        return 3;
      },
      run: function (ctx) {
        const pair = ctx.rivalPair;
        const key = "feud:" + getPairKey(pair[0], pair[1]);
        const arc = ctx.storyState.socialArcs[key] || { stage: 2, tag: "feud" };
        const conciliatory = Math.random() < 0.35;
        if (conciliatory) {
          addLog(
            "After tempers flare, the two rivals finally agree to split chores and keep out of each other's way.",
            { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [pair[0].id, pair[1].id] }
          );
          adjustOpinion(pair[0], pair[1], 4, "feud_cooldown");
          adjustOpinion(pair[1], pair[0], 4, "feud_cooldown");
          ctx.storyState.socialArcs[key] = Object.assign({}, arc, { stage: 4, status: "truce" });
        } else {
          addLog(
            pair[0].name +
              " challenges " +
              pair[1].name +
              " over repeated mistakes. One storms off to cool down, leaving the camp short-handed.",
            { tone: "warning", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [pair[0].id, pair[1].id] }
          );
          ctx.storyState.eventFlags.forcedCampHours = Math.max(2, ctx.storyState.eventFlags.forcedCampHours || 0);
          ctx.storyState.risk.behind_schedule = true;
          ctx.storyState.socialArcs[key] = Object.assign({}, arc, { stage: 3, status: "simmer" });
        }
        recordStoryBeat("social", "feud", "A feud boiled over", { arc: key, stage: ctx.storyState.socialArcs[key].stage });
      },
    },
    {
      id: "rival_showdown",
      kind: "major",
      minTension: 30,
      condition: function (ctx) {
        return ctx.rivalPair && ctx.storyState.risk.low_morale;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        const pair = ctx.rivalPair;
        if (!pair) return;
        const winner = Math.random() < 0.5 ? pair[0] : pair[1];
        const loser = winner === pair[0] ? pair[1] : pair[0];
        addLog(
          "Arguments boil over until " + winner.name + " wins the camp to their side—at least for now.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [winner.id, loser.id] }
        );
        adjustOpinion(loser, winner, -10, "showdown");
        addThought(winner, { id: "vindicated2", label: "Vindicated", value: 6, hoursLeft: 18, source: "social" });
        addThought(loser, { id: "humiliated2", label: "Humiliated", value: -8, hoursLeft: 18, source: "social" });
        ctx.storyState.risk.low_morale = false;
      },
    },
    {
      id: "resented_chores",
      kind: "minor",
      minTension: 14,
      condition: function (ctx) {
        const plan = ctx.campPlan;
        if (!plan || !plan.people || !plan.people.length) return false;
        const sorted = plan.people.slice().sort(function (a, b) {
          return (b.summary.guardHours || 0) + (b.summary.forageHours || 0) - ((a.summary.guardHours || 0) + (a.summary.forageHours || 0));
        });
        const heavy = sorted[0];
        const othersRest = sorted.slice(1).reduce(function (sum, entry) {
          return sum + (entry.summary.restHours || 0);
        }, 0);
        return heavy && heavy.summary && heavy.summary.guardHours >= 2 && othersRest >= sorted.length - 1;
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        const plan = ctx.campPlan;
        const heavy = plan.people[0];
        const person = ctx.people.find(function (p) {
          return p.id === heavy.personId;
        });
        if (!person) return;
        addLog(
          person.name +
            " shoulders the late watch again while others rest. Grumbling ripples through the camp about fairness.",
          { tone: "social", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [person.id] }
        );
        addThought(person, { id: "overworked_guard", label: "Overworked", value: -5, hoursLeft: 14, source: "chores" });
        person.morale = clamp(person.morale - 4, 0, 100);
        ctx.storyState.risk.low_morale = true;
      },
    },
    {
      id: "river_debate",
      kind: "major",
      minTension: 20,
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        const riskyWeather = ctx.weather && (ctx.weather.storm || ctx.weather.precip === "rain");
        return (loc.indexOf("river") >= 0 || loc.indexOf("ford") >= 0) && riskyWeather;
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        const cautious = Math.random() < 0.45;
        if (cautious) {
          addLog(
            "The party debates the crossing and opts to wait, shoring gear and scouting for a shallower bend.",
            { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
          );
          ctx.storyState.risk.behind_schedule = true;
          recordStoryBeat("risk_start", "route", "Crossing delayed for safety", { location: ctx.location });
        } else {
          const wagonHit = Math.random() < 0.5;
          if (wagonHit) {
            gameState.wagonCondition = clamp(gameState.wagonCondition - 8, 0, 100);
            addLog(
              "You push the crossing in fast water. A wheel slams a submerged boulder, cracking a spoke.",
              { tone: "warning", tag: "DAY " + ctx.dayTag, location: ctx.location }
            );
          } else {
            addLog(
              "Ropes and steady nerves see the wagon across despite the current. Everyone exhales together.",
              { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
            );
          }
          recordStoryBeat("risk_start", "river", "Risky ford attempted", { wagonHit: wagonHit });
        }
      },
    },
    {
      id: "river_rescue",
      kind: "major",
      minTension: 22,
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        return (
          ctx.strongBondPair &&
          (loc.indexOf("river") >= 0 || loc.indexOf("ford") >= 0) &&
          (ctx.weather.storm || ctx.storyState.risk.soaked)
        );
      },
      weight: function () {
        return 3;
      },
      run: function (ctx) {
        const pair = ctx.strongBondPair;
        const rescuer = pair[0];
        const rescued = pair[1];
        addLog(
          rescued.name +
            " slips from the wagon tongue as the current shoves hard. " +
            rescuer.name +
            " hauls them back, coughing and soaked, to the cheers of the others.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [rescuer.id, rescued.id] }
        );
        adjustOpinion(rescuer, rescued, 4, "river_rescue");
        adjustOpinion(rescued, rescuer, 10, "river_rescue");
        addThought(rescued, { id: "saved_life", label: "Saved from the current", value: 10, hoursLeft: 36, source: "social" });
        recordRescueEvent(rescuer, rescued, "river_rescue", ctx);
        recordStoryBeat("social", "river", "A river rescue strengthened bonds", { rescuer: rescuer.id, rescued: rescued.id });
      },
    },
    {
      id: "lander_cutoff_choice",
      kind: "major",
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        return loc.indexOf("south pass") >= 0 && !ctx.storyState.eventFlags.lander_cutoff_choice;
      },
      weight: function () {
        return 5;
      },
      run: async function (ctx) {
        ctx.storyState.eventFlags.lander_cutoff_choice = true;
        gameState.routeChoices = gameState.routeChoices || {};
        const choice = await presentEncounter({
          id: "lander_cutoff_choice",
          title: "Split at South Pass",
          subtitle: ctx.location,
          body: [
            "Wagons debate at South Pass. The Lander Road climbs high country toward the Salt River, promising shorter miles but rougher pulls.",
          ],
          tags: ["route", "shortcut"],
          options: [
            { id: "lander", label: "Take the Lander Cutoff", tone: "danger", hint: "Higher, rougher, but faster if all goes well." },
            { id: "main", label: "Stay on the main trail", tone: "neutral", hint: "Safer forts ahead; longer miles." },
          ],
          defaultId: gameState.routeChoices.lander_route || "main",
        });
        if (choice === "lander") {
          gameState.routeChoices.lander_route = "lander";
          addLog("You turn onto the Lander Road, hoping to make time over the higher ground.", { tone: "event" });
          recordStoryBeat("route", "route", "Chose the Lander Cutoff", {});
        } else {
          gameState.routeChoices.lander_route = "main";
          addLog("You stay on the main Oregon Trail toward Parting of the Ways.", { tone: "event" });
          recordStoryBeat("route", "route", "Stayed on main road at South Pass", {});
        }
        rebuildActiveRoutePath();
        recenterCameraOnPlayer();
        renderAll();
      },
    },
    {
      id: "fort_hall_california_choice",
      kind: "major",
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        return loc.indexOf("fort hall") >= 0 && !ctx.storyState.eventFlags.fort_hall_california_choice;
      },
      weight: function () {
        return 5;
      },
      run: async function (ctx) {
        ctx.storyState.eventFlags.fort_hall_california_choice = true;
        gameState.routeChoices = gameState.routeChoices || {};
        const choice = await presentEncounter({
          id: "fort_hall_california_choice",
          title: "Fork at Fort Hall",
          subtitle: ctx.location,
          body: [
            "Supplies shift hands at Fort Hall. Some wagons eye the California corridor toward the Humboldt, others stay aimed for Oregon's valleys.",
          ],
          tags: ["route"],
          options: [
            { id: "oregon", label: "Stay on the Oregon Trail", tone: "neutral", hint: "Toward the Blue Mountains and Columbia." },
            { id: "california", label: "Angle toward California", tone: "danger", hint: "Southwest toward the Humboldt basin." },
          ],
          defaultId: gameState.routeChoices.california_branch || "oregon",
        });
        if (choice === "california") {
          gameState.routeChoices.california_branch = "california";
          gameState.routeChoices.applegate_cutoff = "applegate";
          addLog("You angle toward the Raft River and the California Trail corridor.", { tone: "event" });
          recordStoryBeat("route", "route", "Branched toward California Trail", {});
        } else {
          gameState.routeChoices.california_branch = "oregon";
          addLog("You commit to the Oregon Trail westward from Fort Hall.", { tone: "event" });
          recordStoryBeat("route", "route", "Stayed on Oregon Trail at Fort Hall", {});
        }
        rebuildActiveRoutePath();
        recenterCameraOnPlayer();
        renderAll();
      },
    },
    {
      id: "lassen_applegate_choice",
      kind: "major",
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        return loc.indexOf("lassen meadows") >= 0 && !ctx.storyState.eventFlags.lassen_applegate_choice;
      },
      weight: function () {
        return 4;
      },
      run: async function (ctx) {
        ctx.storyState.eventFlags.lassen_applegate_choice = true;
        gameState.routeChoices = gameState.routeChoices || {};
        const choice = await presentEncounter({
          id: "lassen_applegate_choice",
          title: "Lassen Meadows fork",
          subtitle: ctx.location,
          body: [
            "Ahead lies the Applegate Cutoff curving toward Oregon; west, rougher miles toward California beckon fortune-seekers.",
          ],
          tags: ["route", "shortcut"],
          options: [
            { id: "applegate", label: "Take the Applegate Cutoff", tone: "warm", hint: "North toward Oregon's Rogue Valley." },
            { id: "california", label: "Press west toward California", tone: "danger", hint: "Riskier, still taking you into Oregon here." },
          ],
          defaultId: gameState.routeChoices.applegate_cutoff || "applegate",
        });
        gameState.routeChoices.applegate_cutoff = "applegate";
        if (choice === "california") {
          addLog(
            "California destination not modeled here yet; you still slide onto the Applegate road with the crowd.",
            { tone: "warning" }
          );
          recordStoryBeat("route", "route", "Deferred California destination, following Applegate", {});
        } else {
          addLog("You follow the Applegate Cutoff north toward Goose Lake and the Rogue Valley.", { tone: "event" });
          recordStoryBeat("route", "route", "Chose the Applegate Cutoff", {});
        }
        rebuildActiveRoutePath();
        recenterCameraOnPlayer();
        renderAll();
      },
    },
    {
      id: "salt_river_pass_choice",
      kind: "minor",
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        return loc.indexOf("salt river pass") >= 0 && !ctx.storyState.eventFlags.salt_river_pass_choice;
      },
      weight: function () {
        return 4;
      },
      run: async function () {
        const ss = ensureStoryState();
        ss.eventFlags.salt_river_pass_choice = true;
        const people = getAllPeople().filter(function (p) {
          return p && p.alive;
        });
        const choice = await presentEncounter({
          id: "salt_river_pass_choice",
          title: "Salt River Pass",
          subtitle: formatDateTime(gameState.date) + " · " + gameState.locationName,
          body: [
            "The grade climbs ahead. Pushing over today will wear the team but bank daylight; camping below keeps the stock fresher.",
          ],
          tags: ["route", "danger"],
          options: [
            { id: "push", label: "Push over now", tone: "danger", hint: "Faster miles, tougher on the teams." },
            { id: "rest", label: "Camp and wait", tone: "neutral", hint: "Costs water and food but saves strength." },
          ],
          defaultId: "push",
        });
        if (choice === "push") {
          gameState.lastHourMiles = (gameState.lastHourMiles || 0) + 1;
          people.forEach(function (p) {
            p.energy = clamp(p.energy - 4, 0, 100);
            p.condition = clamp(p.condition - 1, 0, 100);
          });
          addLog("You press over Salt River Pass now—hard on the team but quicker miles.", { tone: "warning" });
          recordStoryBeat("route", "route", "Pushed over Salt River Pass", {});
        } else {
          const s = (gameState.supplies = gameState.supplies || {});
          s.water = Math.max(0, (s.water || 0) - 3);
          s.meal_simple = Math.max(0, (s.meal_simple || 0) - 1);
          people.forEach(function (p) {
            p.energy = clamp(p.energy + 3, 0, 100);
            p.morale = clamp(p.morale + 2, 0, 100);
          });
          gameState.lastHourMiles = Math.max(0, (gameState.lastHourMiles || 0) - 0.5);
          addLog("You camp below the pass, water up, and rest the teams for a cooler climb tomorrow.", { tone: "event" });
          recordStoryBeat("route", "route", "Rested before Salt River Pass", {});
        }
      },
    },
    {
      id: "granite_pass_choice",
      kind: "minor",
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        return loc.indexOf("granite pass") >= 0 && !ctx.storyState.eventFlags.granite_pass_choice;
      },
      weight: function () {
        return 4;
      },
      run: async function () {
        const ss = ensureStoryState();
        ss.eventFlags.granite_pass_choice = true;
        const people = getAllPeople().filter(function (p) {
          return p && p.alive;
        });
        const choice = await presentEncounter({
          id: "granite_pass_choice",
          title: "Granite Pass",
          subtitle: formatDateTime(gameState.date) + " · " + gameState.locationName,
          body: [
            "Granite Pass rises ahead. You can chain wheels and shove now or rest and make a steadier climb tomorrow.",
          ],
          tags: ["route", "danger"],
          options: [
            { id: "push", label: "Haul over now", tone: "danger", hint: "Spend energy for quicker miles." },
            { id: "wait", label: "Scout and rest", tone: "neutral", hint: "Costs time; safer on the stock." },
          ],
          defaultId: "push",
        });
        if (choice === "push") {
          gameState.lastHourMiles = (gameState.lastHourMiles || 0) + 0.8;
          people.forEach(function (p) {
            p.energy = clamp(p.energy - 3, 0, 100);
            p.condition = clamp(p.condition - 1, 0, 100);
          });
          addLog("You chain wheels and shove over Granite Pass, spending energy but saving daylight.", { tone: "warning" });
          recordStoryBeat("route", "route", "Pushed over Granite Pass", {});
        } else {
          const s = (gameState.supplies = gameState.supplies || {});
          s.water = Math.max(0, (s.water || 0) - 2);
          s.meal_simple = Math.max(0, (s.meal_simple || 0) - 1);
          people.forEach(function (p) {
            p.energy = clamp(p.energy + 2, 0, 100);
          });
          gameState.lastHourMiles = Math.max(0, (gameState.lastHourMiles || 0) - 0.4);
          addLog("You cool the stock and scout the grade at Granite Pass before tackling it tomorrow.", { tone: "event" });
          recordStoryBeat("route", "route", "Rested before Granite Pass", {});
        }
      },
    },
    {
      id: "siskiyou_pass_choice",
      kind: "minor",
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        return loc.indexOf("siskiyou pass") >= 0 && !ctx.storyState.eventFlags.siskiyou_pass_choice;
      },
      weight: function () {
        return 4;
      },
      run: async function () {
        const ss = ensureStoryState();
        ss.eventFlags.siskiyou_pass_choice = true;
        const people = getAllPeople().filter(function (p) {
          return p && p.alive;
        });
        const choice = await presentEncounter({
          id: "siskiyou_pass_choice",
          title: "Siskiyou Pass",
          subtitle: formatDateTime(gameState.date) + " · " + gameState.locationName,
          body: [
            "Fog and firs guard the crest. You can force the wagons over today or camp below for a rested push tomorrow.",
          ],
          tags: ["route", "danger"],
          options: [
            { id: "push", label: "Push over now", tone: "danger", hint: "Spend energy, reach the Rogue sooner." },
            { id: "rest", label: "Hold and rest", tone: "neutral", hint: "Lose time, spare morale and energy." },
          ],
          defaultId: "push",
        });
        if (choice === "push") {
          gameState.lastHourMiles = (gameState.lastHourMiles || 0) + 0.9;
          people.forEach(function (p) {
            p.energy = clamp(p.energy - 3, 0, 100);
            p.morale = clamp(p.morale - 1, 0, 100);
          });
          addLog("You press over Siskiyou Pass despite fatigue, eager to reach the Rogue Valley.", { tone: "warning" });
          recordStoryBeat("route", "route", "Pushed over Siskiyou Pass", {});
        } else {
          const s = (gameState.supplies = gameState.supplies || {});
          s.water = Math.max(0, (s.water || 0) - 2);
          s.meal_simple = Math.max(0, (s.meal_simple || 0) - 1);
          people.forEach(function (p) {
            p.energy = clamp(p.energy + 2, 0, 100);
            p.morale = clamp(p.morale + 1, 0, 100);
          });
          gameState.lastHourMiles = Math.max(0, (gameState.lastHourMiles || 0) - 0.4);
          addLog("You camp below Siskiyou Pass, saving strength for the final climb into Oregon.", { tone: "event" });
          recordStoryBeat("route", "route", "Rested before Siskiyou Pass", {});
        }
      },
    },
    {
      id: "snake_three_islands_choice",
      kind: "major",
      minTension: 24,
      condition: function (ctx) {
        return ctx.regionKey === "snake_plain" && ctx.dayTag > 60 && !ctx.storyState.eventFlags.snake_three_islands;
      },
      weight: function () {
        return 4;
      },
      run: async function (ctx) {
        ctx.storyState.eventFlags.snake_three_islands = true;
        const choice = await presentEncounter({
          id: "snake_three_islands_choice",
          title: "Three Islands Crossing",
          subtitle: ctx.location,
          body: [
            "Swirling channels braid the Snake. A shaky ferry waits, or you can seal the wagon and float, or scout upstream for a quieter braid.",
          ],
          tags: ["river", "danger"],
          options: [
            { id: "ferry", label: "Pay for the ferry ($8)", tone: "neutral", hint: "Safer but slow; costs cash." },
            { id: "float", label: "Caulk and float", tone: "danger", hint: "Risk swamping; saves money." },
            { id: "scout", label: "Scout upstream", tone: "warm", hint: "Burns daylight, may find calmer water." },
          ],
          defaultId: "ferry",
        });
        if (choice === "ferry" && (gameState.money || 0) >= 8) {
          gameState.money -= 8;
          addLog("You pay for the shaky ferry and make the crossing damp but intact.", { tone: "event" });
          recordStoryBeat("route", "water", "Ferry crossing at Three Islands", {});
        } else if (choice === "float") {
          gameState.wagonCondition = clamp(gameState.wagonCondition - 8, 0, 100);
          ctx.storyState.risk.soaked = true;
          addLog("You seal the wagon and shove off. The current spins you but you scrape through, soaked and rattled.", { tone: "warning" });
          recordStoryBeat("route", "water", "Floated the Snake after debate", {});
        } else {
          gameState.lastHourMiles = Math.max(0, (gameState.lastHourMiles || 0) - 1);
          addLog("Scouting upstream burns daylight but finds a calmer braid of the river.", { tone: "event" });
          recordStoryBeat("route", "water", "Scouted for a better Snake crossing", {});
        }
      },
    },
    {
      id: "fort_clinic_volunteer",
      kind: "breather",
      maxTension: 70,
      condition: function (ctx) {
        return (ctx.location || "").toLowerCase().indexOf("fort") >= 0 && !ctx.storyState.eventFlags.fort_clinic_help;
      },
      weight: function (ctx) {
        return ctx.risk.long_illness ? 6 : 3;
      },
      run: async function (ctx) {
        ctx.storyState.eventFlags.fort_clinic_help = true;
        ensureReputationState();
        const rep = gameState.reputation || 0;
        const generous = rep >= 20;
        const distrusted = rep <= -20;
        const selection = await presentEncounter({
          id: "fort_clinic_volunteer",
          title: "Fort clinic appeal",
          subtitle: ctx.location,
          body: [
            "A weary surgeon asks if you can spare medicine or hands. Word of your conduct on the trail colors the request.",
          ],
          tags: ["fort", "mercy"],
          options: [
            { id: "volunteer", label: "Leave medicine and help", tone: "warm", hint: "Earn clinic favor; costs supplies." },
            { id: "modest", label: "Offer a modest bundle", tone: "neutral", hint: "Small gesture to keep relations steady." },
            { id: "decline", label: "Move on", tone: "danger", hint: "Save supplies; may sour your name." },
          ],
          defaultId: "volunteer",
        });
        if (selection === "volunteer") {
          const cost = distrusted ? 3 : generous ? 1 : 2;
          const spent = Math.min(gameState.supplies.med_kits || 0, cost);
          gameState.supplies.med_kits = Math.max(0, (gameState.supplies.med_kits || 0) - spent);
          const friendA = ctx.people && ctx.people.length ? choice(ctx.people) : null;
          const friendB = ctx.people && ctx.people.length ? choice(ctx.people) : null;
          if (friendA && friendB) adjustOpinion(friendA, friendB, 1, "clinic_help");
          addLog(
            "You leave medicine and a pair of helpers at the clinic. The surgeon notes your kindness and promises priority if illness strikes.",
            { tone: "morale" }
          );
          if (generous) {
            adjustReputation(4, "Fort clinic aid", { flag: "clinic_generous" });
          } else {
            adjustReputation(2, "Fort clinic aid");
          }
          recordStoryBeat("historic", "illness", "Assisted a mission clinic", {});
          ctx.storyState.eventFlags.fort_clinic_favor = true;
          if (generous || rep >= 10) gameState.reputationFlags.clinic_priority = true;
        } else if (selection === "modest") {
          const spent = Math.min(gameState.supplies.med_kits || 0, 1);
          gameState.supplies.med_kits = Math.max(0, (gameState.supplies.med_kits || 0) - spent);
          addLog("You leave a small bundle of bandages and move on.", { tone: "info" });
          adjustReputation(1, "Offered modest clinic help");
        } else {
          addLog("You nod politely and move on, keeping your scarce supplies.", { tone: "info" });
          adjustReputation(-2, "Declined fort clinic plea");
          if (distrusted) ctx.storyState.eventFlags.fort_clinic_favor = false;
        }
      },
    },
    {
      id: "blue_mountains_cutoff",
      kind: "major",
      minTension: 18,
      condition: function (ctx) {
        return ctx.regionKey === "blue_mountains" && !ctx.storyState.eventFlags.blue_cutoff;
      },
      weight: function () {
        return 3;
      },
      run: async function (ctx) {
        ctx.storyState.eventFlags.blue_cutoff = true;
        const choice = await presentEncounter({
          id: "blue_mountains_cutoff",
          title: "Blue Mountains decision",
          subtitle: ctx.location,
          body: [
            "A toll gate climbs sharply over the Blue Mountains, shaving days if the wagons hold. The longer valley road is kinder but slower.",
          ],
          tags: ["route", "shortcut"],
          options: [
            { id: "toll", label: "Pay and take the toll gate", tone: "danger", hint: "Shorter, rougher; pay $5." },
            { id: "valley", label: "Stick to the valley road", tone: "neutral", hint: "Longer but easier on gear." },
          ],
          defaultId: gameState.routeChoices.blue_cutoff || "valley",
        });
        gameState.routeChoices = gameState.routeChoices || {};
        if (choice === "toll") {
          gameState.routeChoices.blue_cutoff = "toll";
          gameState.money = Math.max(0, (gameState.money || 0) - 5);
          ctx.storyState.risk.overloaded_wagon = true;
          addLog("You choose the toll gate climb. It's shorter but punishing on the wagon.", { tone: "warning" });
          recordStoryBeat("route", "route", "Chose the Toll Gate Road shortcut", {});
          rebuildActiveRoutePath();
          recenterCameraOnPlayer();
          renderAll();
        } else {
          gameState.routeChoices.blue_cutoff = "valley";
          addLog("You follow the valley road, safer but days longer. Everyone breathes easier.", { tone: "event" });
          recordStoryBeat("route", "route", "Stayed on the safer valley road", {});
          rebuildActiveRoutePath();
          recenterCameraOnPlayer();
          renderAll();
        }
      },
    },
    {
      id: "illness_fevers_through_night",
      kind: "minor",
      minTension: 20,
      condition: function (ctx) {
        const patient = ctx.people.find(function (p) {
          return activeAfflictions(p).some(function (a) {
            return a.stage === "acute" && (a.id === "cholera" || a.id === "camp_fever" || a.id === "mountain_pneumonia");
          });
        });
        return !!patient;
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        const patient = ctx.people.find(function (p) {
          return activeAfflictions(p).some(function (a) {
            return a.stage === "acute" && (a.id === "cholera" || a.id === "camp_fever" || a.id === "mountain_pneumonia");
          });
        });
        if (!patient) return;
        const watcher = ctx.people.find(function (p) {
          return p.id !== patient.id && p.energy > 35;
        });
        addLog(
          "Fevers wrack " + patient.name + " through the night. Someone must sit up with water and cool cloths.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: watcher ? [patient.id, watcher.id] : [patient.id] }
        );
        patient.energy = clamp(patient.energy - 4, 0, 100);
        patient.morale = clamp(patient.morale - 3, 0, 100);
        if (watcher) {
          watcher.energy = clamp(watcher.energy - 3, 0, 100);
          addThought(watcher, { id: "kept_watch", label: "Kept fever watch", value: -1, hoursLeft: 16, source: "illness" });
        }
        ctx.storyState.risk.behind_schedule = true;
        recordStoryBeat("affliction", "illness", patient.name + " suffered fever through the night", { patient: patient.id });
      },
    },
    {
      id: "illness_delirium_wandering",
      kind: "major",
      minTension: 25,
      condition: function (ctx) {
        const patient = ctx.people.find(function (p) {
          return activeAfflictions(p).some(function (a) {
            return a.stage === "acute" && a.severity >= 2;
          }) && p.morale < 40;
        });
        return !!patient;
      },
      weight: function () {
        return 3;
      },
      run: function (ctx) {
        const patient = ctx.people.find(function (p) {
          return activeAfflictions(p).some(function (a) {
            return a.stage === "acute" && a.severity >= 2;
          }) && p.morale < 40;
        });
        if (!patient) return;
        addLog(
          patient.name +
            " wanders away from camp in delirium. You lose time searching the brush before guiding them back under blankets.",
          { tone: "warning", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [patient.id] }
        );
        patient.energy = clamp(patient.energy - 6, 0, 100);
        patient.condition = clamp(patient.condition - 6, 0, 100);
        ctx.storyState.risk.behind_schedule = true;
        ctx.storyState.risk.low_morale = true;
        recordStoryBeat("affliction", "illness", patient.name + " nearly wandered off in fever", { patient: patient.id });
      },
    },
    {
      id: "weather_prairie_fire",
      kind: "major",
      minTension: 24,
      condition: function (ctx) {
        const region = (ctx.gameState.region || "").toLowerCase();
        const dry = ctx.weather && ctx.weather.precip === "none" && (ctx.weather.windKph || 0) > 10;
        return (region.indexOf("plain") >= 0 || region.indexOf("prairie") >= 0) && dry;
      },
      weight: function () {
        return 3;
      },
      run: function (ctx) {
        addLog(
          "Smoke smudges the horizon. A prairie fire forces a hard detour and frantic shoveling of a firebreak.",
          { tone: "warning", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        gameState.supplies.firewood = Math.max(0, (gameState.supplies.firewood || 0) - 8);
        ctx.storyState.risk.behind_schedule = true;
        ctx.storyState.tension = clamp(ctx.storyState.tension + 4, 0, 100);
        recordStoryBeat("risk_start", "weather", "Prairie fire forced a detour", {});
      },
    },
    {
      id: "weather_blizzard_whiteout",
      kind: "major",
      minTension: 26,
      condition: function (ctx) {
        const region = (ctx.gameState.region || "").toLowerCase();
        const cold = ctx.weather && (ctx.weather.tempC || 0) < -5;
        return cold && (region.indexOf("rock") >= 0 || region.indexOf("blue") >= 0);
      },
      weight: function () {
        return 3;
      },
      run: function (ctx) {
        addLog(
          "A whiteout envelopes the ridge. You hunker down, burning fuel and praying the animals don't bolt.",
          { tone: "warning", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.people.forEach(function (p) {
          p.warmth = clamp(p.warmth - 10, 0, 100);
          addThought(p, { id: "whiteout", label: "Whiteout", value: -6, hoursLeft: 16, source: "weather" });
        });
        ctx.storyState.risk.extended_cold_exposure = true;
        recordStoryBeat("risk_start", "weather", "Blizzard stalled the wagon", {});
      },
    },
    {
      id: "weather_dust_storm",
      kind: "minor",
      minTension: 18,
      condition: function (ctx) {
        const region = (ctx.gameState.region || "").toLowerCase();
        const dry = ctx.weather && ctx.weather.precip === "none";
        return dry && (region.indexOf("plain") >= 0 || region.indexOf("snake") >= 0 || region.indexOf("desert") >= 0);
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        addLog(
          "Dust lifts in sheets, stinging eyes and grinding into gear. Travel slows until the air clears.",
          { tone: "warning", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.people.forEach(function (p) {
          p.energy = clamp(p.energy - 3, 0, 100);
          addThought(p, { id: "dust_grit", label: "Dust-choked", value: -3, hoursLeft: 10, source: "weather" });
        });
        ctx.storyState.risk.behind_schedule = true;
      },
    },
    {
      id: "clinic_visit",
      kind: "lifeline",
      maxTension: 75,
      condition: function (ctx) {
        const loc = (ctx.location || "").toLowerCase();
        const atFort = loc.indexOf("fort") >= 0 || loc.indexOf("mission") >= 0;
        if (!atFort) return false;
        return ctx.people.some(function (p) {
          return activeAfflictions(p).some(function (a) {
            return a.stage === "acute" && !a.resolved;
          });
        });
      },
      weight: function () {
        return 3;
      },
      run: function (ctx) {
        const patient = ctx.people.find(function (p) {
          return activeAfflictions(p).some(function (a) {
            return a.stage === "acute";
          });
        });
        if (!patient) return;
        const cost = Math.min(gameState.money || 0, 8);
        gameState.money = Math.max(0, (gameState.money || 0) - cost);
        addLog(
          "A mission doctor offers to tend " +
            patient.name +
            ". Poultices and rest seem to help, though the clinic expects a few dollars for the trouble.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: [patient.id] }
        );
        patient.condition = clamp(patient.condition + 8, 0, 100);
        patient.energy = clamp(patient.energy + 6, 0, 110);
        recordStoryBeat("clinic", "illness", patient.name + " received treatment at a fort clinic", { patient: patient.id, cost: cost });
      },
    },
    {
      id: "lifeline_gratitude_chain",
      kind: "lifeline",
      maxTension: 70,
      condition: function (ctx) {
        return ctx.storyState.eventFlags.recent_lifeline;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        addLog(
          "Around the fire, the party quietly thanks whoever saved their hide this week. Determination firms.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.people.forEach(function (p) {
          p.optimism = clamp((p.optimism || 50) + 2, 0, 100);
          addThought(p, { id: "gratitude", label: "Grateful to still be here", value: 4, hoursLeft: 14, source: "social" });
        });
        ctx.storyState.eventFlags.recent_lifeline = false;
      },
    },
    // Risk cascade events
    {
      id: "cascade_wagon_chain_failure",
      kind: "major",
      minTension: 22,
      condition: function (ctx) {
        return ctx.storyState.risk.overloaded_wagon && (ctx.storyState.riskDurations.overloaded_wagon || 0) > 10;
      },
      weight: function () {
        return 6;
      },
      run: function (ctx) {
        ctx.storyState.cascadeLog = ctx.storyState.cascadeLog || [];
        ctx.storyState.cascadeLog.push({ type: "wagon_failure", location: ctx.location, day: ctx.dayTag });
        gameState.wagonCondition = clamp(gameState.wagonCondition - 12, 0, 100);
        addLog(
          "Another axle creaks and gives. You spend half a day patching spokes and tossing gear to lighten the load.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.storyState.risk.behind_schedule = true;
      },
    },
    {
      id: "cascade_snowbound",
      kind: "major",
      minTension: 26,
      condition: function (ctx) {
        return ctx.storyState.risk.extended_cold_exposure && ctx.storyState.risk.behind_schedule;
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        ctx.storyState.cascadeLog = ctx.storyState.cascadeLog || [];
        ctx.storyState.cascadeLog.push({ type: "snowbound", location: ctx.location, day: ctx.dayTag });
        addLog(
          "Snow piles against the wagon wheels. You huddle in place for a day, burning fuel and nerves.",
          { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.people.forEach(function (p) {
          p.warmth = clamp(p.warmth - 8, 0, 100);
          addThought(p, { id: "snowbound", label: "Snowbound", value: -6, hoursLeft: 12, source: "weather" });
        });
      },
    },
    {
      id: "cascade_starvation_spiral",
      kind: "major",
      minTension: 28,
      condition: function (ctx) {
        return ctx.storyState.risk.extended_starvation;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        ctx.storyState.cascadeLog = ctx.storyState.cascadeLog || [];
        ctx.storyState.cascadeLog.push({ type: "starvation", location: ctx.location, day: ctx.dayTag });
        addLog(
          "Hollow eyes and shaking hands tell the story: the party is wasting. No miles today, only fitful rest.",
          { tone: "morale", tag: "DAY " + ctx.dayTag, location: ctx.location }
        );
        ctx.storyState.risk.low_morale = true;
        ctx.people.forEach(function (p) {
          p.energy = clamp(p.energy - 6, 0, 100);
          p.morale = clamp(p.morale - 6, 0, 100);
        });
      },
    },
    {
      id: "setpiece_open_eye_revival",
      kind: "major",
      condition: function (ctx) {
        const step = getEventFlag("open_eye_revival_step") || 0;
        const miles = gameState.milesTraveled || 0;
        const mileOk = miles >= 400 && miles <= 1600;
        const regionOk =
          ctx.regionKey === "central_plains" ||
          ctx.regionKey === "high_plains" ||
          ctx.regionKey === "snake_plain";
        const cooldownOk = hoursSinceFlag("open_eye_revival_last") >= 240;
        return step === 0 && mileOk && ctx.block === "evening" && !ctx.weather.storm && regionOk && cooldownOk;
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const selection = await presentEncounter({
          id: "setpiece_open_eye_revival",
          title: "Open Eye Revival",
          subtitle: ctx.location,
          body: [
            "A ring of wagons glows ahead. Voices rise in a low hymn while a banner with an inked eye sways in the dusk breeze.",
          ],
          tags: ["camp", "cult"],
          options: [
            { id: "stop", label: "Stop and warm by their fires", tone: "warm", hint: "Rest with the revival." },
            { id: "donate", label: "Donate and move on", tone: "neutral", hint: "Spend a little; gain medicine." },
            { id: "avoid", label: "Avoid the circle", tone: "danger", hint: "Keep distance." },
          ],
          defaultId: "stop",
        });
        const nowHour = getCurrentTrailHour(gameState);
        let logText = "You skirt the revival, keeping your fires low as their songs fade behind you.";
        if (selection === "stop") {
          ctx.storyState.eventFlags = ctx.storyState.eventFlags || {};
          ctx.storyState.eventFlags.forcedCampHours = Math.max(
            2,
            ctx.storyState.eventFlags.forcedCampHours || 0
          );
          getAllPeople().forEach(function (p) {
            adjustPersonStat(p, "morale", 2);
          });
          adjustFactionRep("open_eye", 5, null, ctx);
          setEventFlag("open_eye_seen", true);
          if (ctx.storyState.mythicEnabled !== false) {
            ctx.storyState.mythicRumor = clamp((ctx.storyState.mythicRumor || 0) + 1, 0, 100);
          }
          logText = "You join the circle for a night. Hymns and hot broth leave the party calmer before turning in.";
        } else if (selection === "donate") {
          ctx.storyState.eventFlags = ctx.storyState.eventFlags || {};
          ctx.storyState.eventFlags.forcedCampHours = Math.max(
            2,
            ctx.storyState.eventFlags.forcedCampHours || 0
          );
          gameState.money = Math.max(0, (gameState.money || 0) - 6);
          gameState.supplies.med_kits = (gameState.supplies.med_kits || 0) + 1;
          adjustFactionRep("open_eye", 10, null, ctx);
          setEventFlag("open_eye_seen", true);
          logText = "You leave a donation and receive a wrapped bundle of herbs and tonics before moving on.";
        } else if (selection === "avoid") {
          ctx.storyState.tension = clamp((ctx.storyState.tension || 0) + 3, 0, 100);
          adjustFactionRep("open_eye", -5, null, ctx);
          logText = "You steer wide of the revival. Curious eyes follow until the hymns are lost to distance.";
        }
        setEventFlag("open_eye_revival_choice", selection);
        advanceChain("open_eye_revival", 1);
        setEventFlag("open_eye_revival_last", nowHour);
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("setpiece", "open_eye_revival", "Encountered Open Eye Revival", { choice: selection });
      },
    },
    {
      id: "setpiece_open_eye_revival_followup",
      kind: "minor",
      condition: function () {
        const step = getEventFlag("open_eye_revival_step");
        const waited = hoursSinceFlag("open_eye_revival_time");
        return step === 1 && waited >= 48 && waited <= 240;
      },
      weight: function () {
        return 4;
      },
      run: async function (ctx) {
        const initial = getEventFlag("open_eye_revival_choice");
        const selection = await presentEncounter({
          id: "setpiece_open_eye_revival_followup",
          title: "Open Eye runner",
          subtitle: ctx.location,
          body: [
            "A runner from the Open Eye catches up, parched and carrying a sealed crate bound for the next fort.",
          ],
          tags: ["cult", "favor"],
          options: [
            { id: "help", label: "Share water and help", tone: "warm", hint: "Aid the courier." },
            { id: "refuse", label: "Refuse politely", tone: "neutral", hint: "Hold your supplies." },
            { id: "threaten", label: "Run them off", tone: "danger", hint: "Risk harm; strain reputation." },
          ],
          defaultId: "help",
        });
        let logText = "You send the runner on their way, keeping to your own path.";
        if (selection === "help") {
          if ((gameState.supplies.water || 0) >= 1) {
            gameState.supplies.water = Math.max(0, (gameState.supplies.water || 0) - 1);
          } else if ((gameState.supplies.flour || 0) >= 2) {
            gameState.supplies.flour = Math.max(0, (gameState.supplies.flour || 0) - 2);
          }
          adjustFactionRep("open_eye", 5, null, ctx);
          adjustReputation(1, "Helped the Open Eye");
          logText = "You pass over water and a little flour. The runner thanks you and hurries toward the fort.";
        } else if (selection === "refuse") {
          adjustFactionRep("open_eye", -4, null, ctx);
          if (Math.random() < 0.35) {
            gameState.supplies.meal_simple = Math.max(0, (gameState.supplies.meal_simple || 0) - 2);
            ctx.storyState.tension = clamp((ctx.storyState.tension || 0) + 1, 0, 100);
            logText = "You turn the runner away. Later, two meals are missing and faint tracks lead off the road.";
          } else {
            logText = "You refuse the favor. The runner bows stiffly and jogs toward the horizon.";
          }
        } else if (selection === "threaten") {
          gameState.supplies.ammo = Math.max(0, (gameState.supplies.ammo || 0) - 1);
          adjustFactionRep("open_eye", -10, null, ctx);
          adjustReputation(-2, "Threatened the Open Eye");
          if (Math.random() < 0.3) {
            const target = choice(ctx.people || getAllPeople());
            if (target) target.condition = clamp((target.condition || 50) - 5, 0, 100);
          }
          logText = "You level a rifle and send the runner packing. They vanish between sagebrush with the crate.";
        }
        advanceChain("open_eye_revival", 2);
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("setpiece", "open_eye_revival", "Open Eye follow-up", {
          initial: initial,
          choice: selection,
        });
      },
    },
    {
      id: "setpiece_bone_valley",
      kind: "major",
      condition: function (ctx) {
        const mythic = ctx.storyState.mythicEnabled !== false;
        const step = getEventFlag("bone_valley_step") || 0;
        const miles = gameState.milesTraveled || 0;
        const midRun = miles > 500 && miles < 1700;
        const regionOk =
          ctx.regionKey === "central_plains" || ctx.regionKey === "snake_plain" || ctx.regionKey === "blue_mountains";
        const cooldownOk = hoursSinceFlag("bone_valley_last") >= 240;
        return mythic && step === 0 && midRun && regionOk && cooldownOk;
      },
      weight: function () {
        return 2;
      },
      run: async function (ctx) {
        const selection = await presentEncounter({
          id: "setpiece_bone_valley",
          title: "Bone Valley",
          subtitle: ctx.location,
          body: [
            "You crest a ridge to find a shallow valley littered with bleached bones. Sunlight glints off old tools and horn cores half-buried in dust.",
          ],
          tags: ["mythic", "trade"],
          options: [
            { id: "harvest", label: "Harvest the trove", tone: "danger", hint: "Big payout; risk accidents." },
            { id: "pocket", label: "Take a small piece", tone: "neutral", hint: "Modest gain, safer." },
            { id: "leave", label: "Leave it undisturbed", tone: "warm", hint: "Walk away." },
          ],
          defaultId: "pocket",
        });
        const nowHour = getCurrentTrailHour(gameState);
        let logText = "You leave the valley quiet, respecting what lies there.";
        if (selection === "harvest") {
          const target = choice(ctx.people || getAllPeople());
          const hurt = Math.random() < 0.35 && target;
          gameState.money = (gameState.money || 0) + 14;
          if (hurt) {
            target.condition = clamp((target.condition || 50) - 10, 0, 100);
            addAffliction(target, "sprain", { severity: 1 });
            logText = target.name + " slips hauling a load of horns, but the trove sells well down the road.";
          } else {
            logText = "You strip horns and curios into crates, certain traders will pay well.";
          }
          setEventFlag("bone_valley_variant", "big");
        } else if (selection === "pocket") {
          gameState.money = (gameState.money || 0) + 5;
          if (Math.random() < 0.15) {
            const picker = choice(ctx.people || getAllPeople());
            if (picker) picker.condition = clamp((picker.condition || 50) - 4, 0, 100);
          }
          logText = "You pocket a few curious pieces—enough to sell without lingering.";
          setEventFlag("bone_valley_variant", "small");
        } else {
          adjustReputation(1, "Respected the Bone Valley");
          setEventFlag("bone_valley_variant", "leave");
        }
        advanceChain("bone_valley", 1);
        setEventFlag("bone_valley_last", nowHour);
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("setpiece", "bone_valley", "Encountered Bone Valley", { choice: selection });
      },
    },
    {
      id: "setpiece_bone_valley_followup",
      kind: "minor",
      condition: function () {
        const step = getEventFlag("bone_valley_step");
        const waited = hoursSinceFlag("bone_valley_time");
        return step === 1 && waited >= 72 && waited <= 240;
      },
      weight: function () {
        return 4;
      },
      run: function (ctx) {
        const variant = getEventFlag("bone_valley_variant");
        let logText = "You think back on the valley of bones and move on.";
        if (variant === "big") {
          if (Math.random() < 0.5) {
            gameState.money = (gameState.money || 0) + 10;
            logText = "A trader recognizes the horn cache and pays handsomely, glad you braved the valley.";
          } else {
            gameState.supplies.flour = Math.max(0, (gameState.supplies.flour || 0) - 4);
            const target = choice(ctx.people || getAllPeople());
            if (target && Math.random() < 0.4) {
              target.condition = clamp((target.condition || 50) - 7, 0, 100);
              addAffliction(target, "sprain", { severity: 1 });
            }
            logText = "Shadows linger from Bone Valley. Something rustles your wagons at night, leaving supplies scattered.";
          }
        } else if (variant === "small") {
          gameState.money = (gameState.money || 0) + 4;
          logText = "The small curios fetch a tidy sum at a roadside camp, no fuss raised.";
        }
        advanceChain("bone_valley", 2);
        addLog(logText, { tone: "event", tag: "DAY " + ctx.dayTag, location: ctx.location });
        recordStoryBeat("setpiece", "bone_valley", "Bone Valley follow-up", { variant: variant });
      },
    },
    {
      id: "chain_ration_missing",
      kind: "minor",
      minTension: 10,
      condition: function (ctx) {
        const step = getEventFlag("ration_chain_step") || 0;
        return ctx.mode === "camp" && ctx.block === "evening" && step === 0 && ctx.storyState.risk.starvation;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        const lost = Math.min(6, gameState.supplies.meal_simple || 0);
        if (lost > 0) gameState.supplies.meal_simple = Math.max(0, (gameState.supplies.meal_simple || 0) - lost);
        advanceChain("ration_chain", 1);
        addLog(
          "A bundle of cooked rations goes missing. Voices in the dark blame hunger and careless watch.",
          { tone: "warning", tag: "DAY " + ctx.dayTag, location: ctx.location, characters: ctx.people.slice(0, 2).map(function (p) { return p.id; }) }
        );
      },
    },
    {
      id: "chain_ration_confront",
      kind: "minor",
      condition: function (ctx) {
        return getEventFlag("ration_chain_step") === 1 && hoursSinceFlag("ration_chain_time") > 4;
      },
      weight: function () {
        return 6;
      },
      run: async function (ctx) {
        const people = ctx.people || [];
        const accuser = people[0];
        const accused = people[1] || accuser;
        const choice = await presentEncounter({
          id: "ration_confront",
          title: "Missing rations",
          subtitle: formatDateTime(gameState.date) + " · " + ctx.location,
          body: [
            "Supper comes up light. " +
              accuser.name +
              " insists someone skimmed the pot. Eyes drift toward " +
              accused.name +
              " and the quieter wagons.",
          ],
          options: [
            { id: "search", label: "Search packs", tone: "danger", hint: "May mend or strain trust." },
            { id: "share", label: "Share from your own stores", tone: "warm" },
            { id: "warn", label: "Let it slide but warn everyone", tone: "neutral" },
          ],
          defaultId: "warn",
        });
        setEventFlag("ration_chain_choice", choice);
        advanceChain("ration_chain", 2);
        if (choice === "search") {
          adjustOpinion(accuser, accused, -6, "accusation");
          adjustOpinion(accused, accuser, -4, "accusation");
          addThought(accused, { id: "searched", label: "Searched", value: -3, hoursLeft: 12, source: "social" });
          addLog("Bags are turned out by lantern light. Tempers cool but trust frays.", { tone: "warning", characters: [accuser.id, accused.id] });
        } else if (choice === "share") {
          gameState.supplies.meal_simple = Math.max(0, (gameState.supplies.meal_simple || 0) - 2);
          adjustOpinion(accused, accuser, 4, "forgiven");
          adjustOpinion(accuser, accused, 2, "forgiven");
          addLog(accuser.name + " offers their own portion. Grumbling eases.", { tone: "social", characters: [accuser.id, accused.id] });
        } else {
          addLog("You warn the camp to mind the larder. No names given, but suspicions linger.", { tone: "event" });
        }
      },
    },
    {
      id: "chain_ration_resolution",
      kind: "breather",
      condition: function (ctx) {
        return getEventFlag("ration_chain_step") === 2 && hoursSinceFlag("ration_chain_time") > 6;
      },
      weight: function () {
        return 5;
      },
      run: function (ctx) {
        const choice = getEventFlag("ration_chain_choice");
        if (choice === "share") {
          ctx.people.forEach(function (p) {
            addThought(p, { id: "generous_meal", label: "Shared meal", value: 3, hoursLeft: 10, source: "social" });
          });
        } else if (choice === "search") {
          ctx.storyState.risk.low_morale = true;
        }
        addLog("The missing rations become a story, not a wound. Camp talk shifts back to miles ahead.", { tone: "social", tag: "DAY " + ctx.dayTag, location: ctx.location });
        setEventFlag("ration_chain_step", 0);
        setEventFlag("ration_chain_choice", null);
      },
    },
    {
      id: "mythic_wanderer_glow",
      kind: "major",
      minTension: 8,
      condition: function (ctx) {
        const step = getEventFlag("mythic_wanderer_step") || 0;
        return (
          (ctx.storyState.mythicEnabled !== false && gameState.mythicEnabled !== false) &&
          ctx.mode === "travel" &&
          ctx.block === "night" &&
          step === 0 &&
          Math.random() < 0.03
        );
      },
      weight: function () {
        return 1;
      },
      run: async function (ctx) {
        const follower = ctx.people[0];
        const choice = await presentEncounter({
          id: "mythic_glow",
          title: "Lantern on the ridge",
          subtitle: formatDateTime(gameState.date) + " · " + ctx.location,
          body: [
            "A pale lantern bobs along a ridge parallel to the train. Some say wandering traveler, others say no one walks that fast.",
          ],
          options: [
            { id: "follow", label: "Follow the light", tone: "danger" },
            { id: "hail", label: "Hail it from the trail", tone: "neutral" },
            { id: "ignore", label: "Ignore and make camp", tone: "warm" },
          ],
          defaultId: "ignore",
        });
        setEventFlag("mythic_wanderer_choice", choice);
        advanceChain("mythic_wanderer", 1);
        if (choice === "follow") {
          addLog(follower.name + " leads a few up the ridge toward the strange light.", { tone: "warning", characters: [follower.id] });
        } else if (choice === "hail") {
          addLog("You hail the light. It pauses, then glides ahead as if beckoning.", { tone: "event" });
        } else {
          addLog("You shake off the tale and focus on camp chores.", { tone: "event" });
        }
      },
    },
    {
      id: "mythic_wanderer_payoff",
      kind: "breather",
      condition: function (ctx) {
        return getEventFlag("mythic_wanderer_step") === 1 && hoursSinceFlag("mythic_wanderer_time") > 3;
      },
      weight: function () {
        return 2;
      },
      run: function (ctx) {
        const choice = getEventFlag("mythic_wanderer_choice") || "ignore";
        if (choice === "follow") {
          gameState.guardLevel = (gameState.guardLevel || 0) + 1;
          addThought(ctx.people[0], { id: "ridge_path", label: "Saw a ridge path", value: 4, hoursLeft: 18, source: "mythic" });
          addLog("The light leads to an old hunter's track. You mark it for rough weather routes.", { tone: "event" });
        } else if (choice === "hail") {
          gameState.supplies.water = (gameState.supplies.water || 0) + 2;
          addLog("A voice in the dark calls back with a warning about bad water downstream. You fill casks here instead.", { tone: "warning" });
        } else {
          ctx.people.forEach(function (p) {
            addThought(p, { id: "grounded", label: "Ignored the tall tale", value: 1, hoursLeft: 6, source: "camp" });
          });
        }
        setEventFlag("mythic_wanderer_step", 0);
        setEventFlag("mythic_wanderer_choice", null);
      },
    },
    ...DREAMWEST_B_SEEDS,
  ];

  function weightedPick(items) {
    const total = items.reduce(function (sum, item) {
      return sum + (item.weight || 1);
    }, 0);
    let roll = Math.random() * total;
    for (let i = 0; i < items.length; i++) {
      roll -= items[i].weight;
      if (roll <= 0) return items[i];
    }
    return items[items.length - 1];
  }

  function setEventFlag(key, value) {
    const ss = ensureStoryState();
    if (!ss.eventFlags) ss.eventFlags = {};
    ss.eventFlags[key] = value;
  }

  function getEventFlag(key) {
    const ss = ensureStoryState();
    return ss.eventFlags ? ss.eventFlags[key] : null;
  }

  function hoursSinceFlag(key) {
    const mark = getEventFlag(key);
    if (mark == null) return Infinity;
    return getCurrentTrailHour(gameState) - mark;
  }

  function advanceChain(key, step) {
    setEventFlag(key + "_step", step);
    setEventFlag(key + "_time", getCurrentTrailHour(gameState));
  }

  function runHasEnded() {
    const arrived = (gameState.milesTraveled || 0) >= (gameState.targetMiles || 0);
    const anyAlive = getAllPeople().some(function (p) {
      return p && p.alive;
    });
    const ended = arrived || !anyAlive || !!gameState.runEnded;
    if (ended && !gameState.runEnded) {
      gameState.runEnded = { reason: arrived ? "arrival" : "loss" };
    }
    return ended;
  }

  function buildStoryContext() {
    const ss = ensureStoryState();
    const weather = gameState.weatherState || {};
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    const rivalPair = (function () {
      for (let i = 0; i < people.length; i++) {
        for (let j = i + 1; j < people.length; j++) {
          const a = people[i];
          const b = people[j];
          const rel = a.relationships && a.relationships[b.id];
          if (rel && rel.opinion <= -30) return [a, b];
        }
      }
      return null;
    })();
    const strongBondPair = (function () {
      for (let i = 0; i < people.length; i++) {
        for (let j = i + 1; j < people.length; j++) {
          const a = people[i];
          const b = people[j];
          const rel = a.relationships && a.relationships[b.id];
          if (rel && rel.opinion >= 70) return [a, b];
        }
      }
      return null;
    })();
    const pendingKey = Object.keys(ss.eventFlags).find(function (k) {
      return k.indexOf("pending_break_") === 0 && ss.eventFlags[k];
    });
    const pendingBreakPerson = pendingKey
      ? people.find(function (p) {
          return p && "pending_break_" + p.id === pendingKey;
        })
      : null;
    const dayTag =
      gameState.startDayOfYear != null
        ? Math.max(1, getDayOfYear(gameState.date) - gameState.startDayOfYear + 1)
        : getDayOfYear(gameState.date);

    const regionKey = gameState.region || "plains";
    const seasonTag = getSeasonTagForDate(gameState.date);

    const riskKeys = Object.keys(ss.risk || {}).filter(function (k) {
      return ss.risk[k];
    });

    const loveTriangle = (function () {
      if (!strongBondPair) return null;
      const a = strongBondPair[0];
      const b = strongBondPair[1];
      for (let i = 0; i < people.length; i++) {
        const c = people[i];
        if (!c || c.id === a.id || c.id === b.id) continue;
        const relAC = a.relationships && a.relationships[c.id];
        const relBC = b.relationships && b.relationships[c.id];
        if ((relAC && relAC.opinion >= 60) || (relBC && relBC.opinion >= 60)) {
          return { a: a, b: b, c: c };
        }
      }
      return null;
    })();

    const leadershipDisputePair = (function () {
      const leader = gameState.leader;
      if (!leader) return null;
      let avgOpinion = 0;
      let count = 0;
      people.forEach(function (p) {
        if (!p || p.id === leader.id) return;
        const rel = p.relationships && p.relationships[leader.id];
        if (rel) {
          avgOpinion += rel.opinion || 0;
          count++;
        }
      });
      const mean = count > 0 ? avgOpinion / count : 0;
      const challenger = people.find(function (p) {
        if (!p || p.id === leader.id) return false;
        const rel = p.relationships && p.relationships[leader.id];
        return rel && (rel.opinion || 0) < mean - 12;
      });
      return challenger ? { challenger: challenger, leader: leader } : null;
    })();

    const guardBonus = (ss.eventFlags && ss.eventFlags.caravan_guard_bonus) || 0;

    return {
      gameState: gameState,
      storyState: ss,
      risk: ss.risk || {},
      riskCount: riskKeys.length,
      weather: weather,
      people: people,
      location: gameState.locationName || "On the trail",
      mode: gameState.mode,
      block: getScheduleBlock(gameState.date),
      guardCoverage:
        (gameState.campPlan && gameState.campPlan.guardCoverage != null
          ? gameState.campPlan.guardCoverage
          : gameState.guardLevel || 0) + guardBonus,
      campPlan: gameState.campPlan,
      avgMorale: gameState.lastAvgMorale || 60,
      rivalPair: rivalPair,
      strongBondPair: strongBondPair,
      pendingBreakPerson: pendingBreakPerson,
      dayTag: dayTag,
      socialArcs: ss.socialArcs || {},
      regionKey: regionKey,
      seasonTag: seasonTag,
      loveTriangle: loveTriangle,
      leadershipDisputePair: leadershipDisputePair,
      lastHourCampTasks: ss.lastHourCampTasks || {},
      lastHourTaskFailures: ss.lastHourTaskFailures || {},
    };
  }

  async function eventDirectorTick() {
    const ss = ensureStoryState();
    ss.hoursSinceMajorEvent += 1;
    ss.hoursSinceMinorEvent += 1;
    updateRiskFlags();

    const ctx = buildStoryContext();
    updateStoryTension(ss, ctx);
    renderTensionDebug(ss, ctx);

    const preset =
      STORYTELLER_PRESETS[ss.presetId || gameState.storytellerPresetId] ||
      STORYTELLER_PRESETS.classic;

    const eligible = EVENT_DEFS.map(function (def) {
      const okMin = def.minTension == null || ss.tension >= def.minTension;
      const okMax = def.maxTension == null || ss.tension <= def.maxTension;
      const cond = def.condition ? def.condition(ctx) : true;
      const isSeed = def.id && def.id.indexOf("seed_") === 0;
      const seedOk = !isSeed || hoursSinceFlag("seed_lastHour") >= 8;
      if (def.kind === "major" && ss.hoursSinceMajorEvent < preset.minHoursBetweenMajor)
        return null;
      if (def.kind !== "major" && ss.hoursSinceMinorEvent < preset.minHoursBetweenMinor)
        return null;
      return okMin && okMax && cond && seedOk
        ? {
            def: def,
            weight: (function () {
              let w = def.weight ? def.weight(ctx) : 1;
              if (def.kind === "breather") w *= preset.breatherBias || 1;
              if (def.kind === "lifeline") w *= preset.lifelineBias || 1;
              if (def.kind === "major" && preset.id === "harsh") w *= 1.2;
              return w;
            })(),
          }
        : null;
    })
      .filter(Boolean)
      .filter(function (obj) {
        return obj.weight > 0;
      });

    if (eligible.length) {
      const pick = weightedPick(eligible);
      if (pick && pick.def && pick.def.run) {
        await pick.def.run(ctx);
        if (pick.def.id && pick.def.id.indexOf("seed_") === 0) {
          setEventFlag("seed_lastHour", getCurrentTrailHour(gameState));
        }
        ss.recentEvents.push({ id: pick.def.id, kind: pick.def.kind });
        if (ss.recentEvents.length > 6) ss.recentEvents.shift();
        if (gameState.tensionDebug) {
          console.log("[tension]", Math.round(ss.tension), pick.def.id);
        }
        if (pick.def.kind === "major") {
          ss.hoursSinceMajorEvent = 0;
          ss.tension = clamp(
            ss.tension - preset.tensionAfterMajorDrop,
            0,
            100
          );
        } else {
          ss.hoursSinceMinorEvent = 0;
          ss.tension = clamp(
            ss.tension - preset.tensionAfterMinorDrop,
            0,
            100
          );
        }
        renderTensionDebug(ss, buildStoryContext());
        return;
      }
    }

    maybeRandomEvent();
  }

  /* ========= RENDERING ===================================================== */

  function barColorForValue(value) {
    const v = clamp(typeof value === "number" ? value : 0, 0, 100);
    const hue = (v / 100) * 120; // 120 = green, 0 = red
    return `hsl(${hue}, 70%, ${v > 60 ? 48 : 50}%)`;
  }

  function applyBarFill(fillEl, value, type) {
    if (!fillEl) return;
    const v = clamp(typeof value === "number" ? value : 0, 0, 100);
    fillEl.style.width = v + "%";
    fillEl.style.background = barColorForValue(v);
    if (type === "warmth" && v < 35) {
      fillEl.style.boxShadow = "0 0 0 1px rgba(120, 180, 255, 0.35)";
    } else {
      fillEl.style.boxShadow = "";
    }
  }

  function renderBars(container, person) {
    function row(label, value, type) {
      const wrap = document.createElement("div");
      wrap.className = "ot-bar-row";

      const lab = document.createElement("div");
      lab.className = "ot-bar-label";
      lab.textContent = label;
      wrap.appendChild(lab);

      const shell = document.createElement("div");
      shell.className = "ot-bar-shell";

      const bar = document.createElement("div");
      bar.className = "ot-bar";
      const fill = document.createElement("div");
      fill.className = "ot-bar-fill";
      applyBarFill(fill, value, type);
      bar.appendChild(fill);
      shell.appendChild(bar);

      const val = document.createElement("div");
      val.className = "ot-bar-value";
      val.textContent = Math.round(clamp(value, 0, 100)) + "%";
      shell.appendChild(val);

      wrap.appendChild(shell);
      container.appendChild(wrap);
    }

    row("Condition", person.condition, "condition");
    row("Hunger", person.hunger);
    row("Thirst", person.thirst);
    row("Warmth", person.warmth, "warmth");
    row("Energy", person.energy);
    row("Morale", person.morale);
  }

  function renderLeaderStatus() {
    dom.leaderStatus.innerHTML = "";
    const activeLeader = getActiveLeader();
    if (!activeLeader) return;
    renderBars(dom.leaderStatus, activeLeader);
    const acute = [];
    getAllPeople().forEach(function (p) {
      activeAfflictions(p).forEach(function (a) {
        if (a.stage === "acute") acute.push(a.label + " (" + p.name + ")");
      });
    });
    if (acute.length) {
      const div = document.createElement("div");
      div.className = "ot-panel-body-sm ot-text-warning";
      div.style.marginTop = "4px";
      div.textContent = "Illness in camp: " + acute.slice(0, 3).join(", ");
      dom.leaderStatus.appendChild(div);
    }
  }

  function renderCascadeSummary() {
    if (!dom.cascadeSummary || !dom.cascadePanel) return;
    const ended = runHasEnded();
    dom.cascadePanel.style.display = ended ? "block" : "none";
    if (!ended) return;
    const ss = ensureStoryState();
    const timeline = buildCascadeTimeline(ss);
    const grouped = {
      hunger: [],
      illness: [],
      weather: [],
      social: [],
      wagon: [],
      route: [],
      loss: [],
    };
    const labels = {
      hunger: "Hunger & Supplies",
      illness: "Illness & Injury",
      weather: "Weather & Route",
      social: "Social & Morale",
      wagon: "Wagon & Oxen",
      route: "Pace & Schedule",
      loss: "Losses",
    };
    (ss.cascadeLog || []).forEach(function (entry) {
      const cat = entry.category || entry.kind || "route";
      if (!grouped[cat]) grouped[cat] = [];
      grouped[cat].push(entry);
    });
    dom.cascadeSummary.innerHTML = "";
    if (dom.cascadeHighlights) {
      const highlights = (ss.cascadeLog || []).slice(-6).reverse();
      dom.cascadeHighlights.innerHTML = highlights
        .map(function (entry) {
          const day = entry.day ? "Day " + entry.day + " – " : "";
          return "<div class=\"ot-panel-body-sm\">" + day + (entry.message || entry.kind || "Story beat") + "</div>";
        })
        .join("");
    }
    Object.keys(labels).forEach(function (cat) {
      const list = grouped[cat] || [];
      if (!list.length) return;
      const section = document.createElement("div");
      section.className = "ot-panel-body-sm";
      const title = document.createElement("div");
      title.style.fontWeight = "bold";
      title.style.marginBottom = "4px";
      title.textContent = labels[cat];
      section.appendChild(title);
      const ul = document.createElement("ul");
      ul.style.paddingLeft = "16px";
      list.slice(0, 6).forEach(function (entry) {
        const li = document.createElement("li");
        const day = entry.day ? "Day " + entry.day + " – " : "";
        li.textContent = day + (entry.message || entry.kind || "Story beat");
        ul.appendChild(li);
      });
      section.appendChild(ul);
      dom.cascadeSummary.appendChild(section);
    });
    renderCascadeTimeline(timeline);
    renderCascadePeopleTracks();
  }

  function renderPartyManifest() {
    dom.partyManifest.innerHTML = "";
    const people = [gameState.leader].concat(gameState.companions);
    people.forEach(function (p, idx) {
      if (!p) return;
      const row = document.createElement("div");
      row.className = "ot-manifest-row";
      if (idx === gameState.selectedIndex) {
        row.classList.add("ot-manifest-selected");
      }
      row.addEventListener("click", function () {
        gameState.selectedIndex = idx;
        renderPartyManifest();
        renderCompanionDetail();
      });

      const left = document.createElement("div");
      const name = document.createElement("div");
      name.className = "ot-manifest-name";
      name.textContent = p.name;
      if (
        p.hiddenTraits &&
        p.hiddenTraits.length &&
        p.secret &&
        p.secret.suspicion >= 35 &&
        (!p.secret.revealed || p.secret.revealed.length < p.hiddenTraits.length)
      ) {
        const badge = document.createElement("span");
        badge.className = "ot-manifest-suspect";
        badge.textContent = "? secret";
        name.appendChild(badge);
      }
      left.appendChild(name);
      const role = document.createElement("div");
      role.className = "ot-manifest-role";
      const isActing = gameState.actingLeaderId && p.id === gameState.actingLeaderId;
      const isLeader = idx === 0;
      role.textContent = isActing ? "Acting leader" : isLeader ? "Leader" : "Companion";
      const affs = activeAfflictions(p);
      if (affs.length) {
        name.textContent = p.name + " ✶";
        name.classList.add("ot-text-warning");
        role.textContent += " · sick";
      }
      left.appendChild(role);

      row.appendChild(left);

      const meter = document.createElement("div");
      meter.className = "ot-manifest-meter";
      const bar = document.createElement("div");
      bar.className = "ot-bar";
      const fill = document.createElement("div");
      fill.className = "ot-bar-fill";
      applyBarFill(fill, p.condition, "condition");
      bar.appendChild(fill);
      meter.appendChild(bar);
      const val = document.createElement("div");
      val.className = "ot-bar-value";
      val.textContent = Math.round(clamp(p.condition, 0, 100)) + "%";
      meter.appendChild(val);
      row.appendChild(meter);

      dom.partyManifest.appendChild(row);
    });
  }

  function renderHourTasks() {
    dom.hourTasks.innerHTML = "";
    const table = document.createElement("table");
    table.className = "ot-tasks-table";
    const tbody = document.createElement("tbody");

    function rowFor(person) {
      const tr = document.createElement("tr");
      const tdName = document.createElement("td");
      tdName.textContent = person.name;
      tr.appendChild(tdName);

      const tdSelect = document.createElement("td");
      const select = document.createElement("select");
      select.className = "ot-task-select";
      TASKS.forEach(function (t) {
        const opt = document.createElement("option");
        opt.value = t.id;
        opt.textContent = t.label;
        select.appendChild(opt);
      });
      select.value = person.task || "travel";
      select.addEventListener("change", function () {
        person.task = select.value;
        renderCampRolesSummary();
      });
      tdSelect.appendChild(select);
      tr.appendChild(tdSelect);
      tbody.appendChild(tr);
    }

    if (gameState.leader) rowFor(gameState.leader);
    gameState.companions.forEach(rowFor);

    table.appendChild(tbody);
    dom.hourTasks.appendChild(table);
  }

  function pickSceneImage() {
    const miles = gameState.milesTraveled;
    const w = gameState.weatherState || {};
    let band = SCENE_BANDS[0];
    SCENE_BANDS.forEach(function (b) {
      if (miles >= b.from && miles <= b.to) band = b;
    });

    let key = "clear";
    if (w.precip === "rain") key = "storm";
    else if (w.precip === "snow") key = "cold";
    else if (w.tempC >= 26) key = "heat";

    const arr =
      (band[key] && band[key].length ? band[key] : band.clear) || [
        IMAGE_URLS.leaving_independence,
      ];
    return { url: choice(arr), label: band.label };
  }

  function renderScene() {
    const s = pickSceneImage();
    dom.scene.style.backgroundImage =
      "linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0.05)), url('" +
      s.url +
      "')";
    const w = gameState.weatherState || {};
    const regionKey = regionToWeatherRegion(gameState.region || "plains");
    const flavor = describeWeatherFlavor(regionKey, w) || s.label;
    const seasonRisk = describeSeasonRisk(
      regionKey,
      gameState.date,
      gameState.startProfile
    );
    const captionLines = [
      formatDateTime(gameState.date) + " · " + gameState.locationName,
      "Weather: " + formatWeatherSummary(w),
      seasonRisk,
      flavor,
      s.label !== flavor ? s.label : "",
    ].filter(Boolean);
    dom.sceneCaption.innerHTML = captionLines
      .map(function (line) {
        return "<div>" + line + "</div>";
      })
      .join("");
  }

  function renderTrailHeader() {
    const mouths = mouthsCount();
    const w = gameState.weatherState || {};
    const regionKey = regionToWeatherRegion(gameState.region || "plains");
    const fallbackProfile =
      START_PROFILES[gameState.startProfileId || "late_april"] ||
      START_PROFILES.late_april;
    const profileLabel = gameState.startProfile
      ? gameState.startProfile.label
      : fallbackProfile.label;
    const seasonal = describeSeasonRisk(regionKey, gameState.date, gameState.startProfile);
    const mainLine =
      formatDateTime(gameState.date) +
      " · " +
      gameState.locationName +
      " · Region: " +
      regionKey;
    const subLine =
      formatWeatherSummary(w) +
      " · Departure: " +
      profileLabel +
      " · " +
      mouths +
      " people";
    dom.trailHeader.innerHTML =
      "<div>" +
      mainLine +
      "</div><div class=\"ot-text-muted\">" +
      subLine +
      "</div>" +
      (seasonal
        ? "<div class=\"ot-text-warning\">" + seasonal + "</div>"
        : "");
  }

  function renderExplorerChip() {
    if (!dom.explorerChip) return;
    const view = ensureExplorerViewState();
    const lines = [formatDateTime(gameState.date), gameState.locationName];
    const weatherLine = formatWeatherSummary(gameState.weatherState || {});
    if (weatherLine) lines.push(weatherLine);
    const controls =
      '<div class="ot-explorer-controls">' +
      `<button class="ot-mini-btn${view.showMinimap ? " ot-active" : ""}" data-action="toggle-minimap">${
        view.showMinimap ? "Minimap On" : "Minimap Off"
      }</button>` +
      `<button class="ot-mini-btn${view.inspect ? " ot-active" : ""}" data-action="toggle-inspect">${
        view.inspect ? "Inspect On" : "Inspect Off"
      }</button>` +
      "</div>";
    dom.explorerChip.innerHTML =
      lines
        .filter(Boolean)
        .map(function (line) {
          return "<div>" + line + "</div>";
        })
        .join("") + controls;
  }

  function updateMapListVisibility() {
    if (!dom.trailMap) return;
    dom.trailMap.style.display = gameState.mapListVisible ? "block" : "none";
    if (dom.btnToggleMapList) {
      dom.btnToggleMapList.textContent = gameState.mapListVisible
        ? "Hide waypoints"
        : "Show waypoints";
    }
  }

  function renderMilestoneList(container, miles, seenMile) {
    if (!container) return;
    container.innerHTML = "";
    const milestones = getActiveRouteMilestones();
    if (!milestones.length) return;
    let currentIdx = 0;
    milestones.forEach(function (m, idx) {
      if (m && typeof m.mile === "number" && miles >= m.mile) {
        currentIdx = idx;
      }
    });
    milestones.forEach(function (m, idx) {
      if (!m) return;
      const row = document.createElement("div");
      row.className = "ot-trail-dot-row";
      const dot = document.createElement("div");
      dot.className = "ot-trail-dot";
      const next = milestones[idx + 1];
      let isCurrent = idx === currentIdx;
      if (typeof m.mile === "number" && next && typeof next.mile === "number") {
        isCurrent = miles >= m.mile && miles < next.mile;
      } else if (typeof m.mile === "number" && !next) {
        isCurrent = miles >= m.mile;
      }
      if (isCurrent) {
        dot.classList.add("ot-trail-dot-current");
      }
      if (typeof m.mile === "number" && seenMile >= m.mile) {
        dot.classList.add("ot-trail-dot-seen");
      }
      row.appendChild(dot);
      const label = document.createElement("div");
      label.textContent = m.name || "Waypoint";
      row.appendChild(label);
      container.appendChild(row);
    });
  }

  function renderTrailMap() {
    if (dom.mapViewport) {
      // background set via CSS; JS hook left in case we later want region-aware tinting
    }

    dom.trailMap.innerHTML = "";
    const miles = gameState.milesTraveled;
    const seenMile = (gameState.traillines && gameState.traillines.fogMaxMile) || 0;
    const mapSub = document.getElementById("ot-map-sub");
    if (mapSub) {
      mapSub.textContent =
        "Miles traveled: " +
        Math.round(miles) +
        " / " +
        Math.round(gameState.targetMiles || 0);
    }

    renderTravelTargetUI();

    renderMilestoneList(dom.trailMap, miles, seenMile);

    updateMapListVisibility();
  }

  function syncMapModalState() {
    if (!dom.mapModal) return;
    if (gameState.mapOpen) {
      dom.mapModal.classList.add("active");
    } else {
      dom.mapModal.classList.remove("active");
    }
  }

  function isMapModalOpen() {
    return !!(gameState.mapOpen && dom.mapModal && dom.mapModal.classList.contains("active"));
  }

  function openMapModal() {
    if (gameState.mapOpen) {
      syncMapModalState();
      return;
    }
    gameState.mapOpen = true;
    renderTrailMap();
    syncMapModalState();
    saveGame();
  }

  function closeMapModal() {
    if (!gameState.mapOpen) {
      syncMapModalState();
      return;
    }
    gameState.mapOpen = false;
    HEX_HOVER_KEY = null;
    syncMapModalState();
    saveGame();
  }

  /* ========= EXPLORER WORLD CAMERA ========================================= */

  // A lightweight explorer view driven by real gameState + advanceOneHour.
  // Uses the trail canvas as a tile-based camera and advances time per step.
  const EXPLORER_VIEWPORT = { width: 15, height: 10 };
  const EXPLORER_WORLD = createExplorerWorld();

  const explorerRuntime = {
    canvas: null,
    ctx: null,
    dragPointerId: null,
    lastDragX: 0,
    lastDragY: 0,
    hover: null,
    dragMode: null,
    dragMoved: false,
    dragStartX: 0,
    dragStartY: 0,
    terrainCache: null,
    minimapRect: null,
    pinnedInspect: null,
  };

  function createExplorerWorld() {
    const width = 64;
    const height = 32;
    const map = Array.from({ length: height }, function () {
      return Array.from({ length: width }, function () {
        return "grass";
      });
    });

    const path = [];
    const pathIndex = {};
    let y = Math.floor(height * 0.65);
    for (let x = 2; x < width - 4; x++) {
      if (x % 7 === 0) y -= 1;
      if (x % 11 === 0) y += 1;
      y = clamp(y, 6, height - 6);
      map[y][x] = "trail";
      path.push({ x: x, y: y });
      pathIndex[`${x},${y}`] = path.length - 1;
      if (x % 10 === 0 && y + 1 < height) {
        map[y + 1][x] = "trail";
      }
    }

    // River winding near the center
    for (let r = 0; r < height; r++) {
      const riverX = 18 + Math.floor(Math.sin(r * 0.35) * 2);
      map[r][riverX] = "water";
      if (riverX + 1 < width) map[r][riverX + 1] = "water";
    }

    // Forest and hill patches
    for (let i = 10; i < 26; i++) {
      map[8][i] = "forest";
      if (i % 3 === 0) map[9][i] = "forest";
    }
    for (let i = 38; i < 54; i++) {
      map[height - 10][i] = "hill";
      if (i % 2 === 0 && height - 11 >= 0) map[height - 11][i] = "hill";
    }

    const nearestPathIdx = [];
    const pathLen = path.length;
    for (let ty = 0; ty < height; ty++) {
      const row = [];
      for (let tx = 0; tx < width; tx++) {
        let bestIdx = 0;
        let bestDist = Infinity;
        for (let i = 0; i < pathLen; i++) {
          const p = path[i];
          const dx = p.x - tx;
          const dy = p.y - ty;
          const dist2 = dx * dx + dy * dy;
          if (dist2 < bestDist) {
            bestDist = dist2;
            bestIdx = i;
            if (dist2 === 0) break;
          }
        }
        row.push(bestIdx);
      }
      nearestPathIdx.push(row);
    }

    return {
      width: width,
      height: height,
      map: map,
      path: path,
      pathIndex: pathIndex,
      nearestPathIdx: nearestPathIdx,
    };
  }

  function resizeTrailCanvas() {
    if (!explorerRuntime.canvas) return;
    const dpr = window.devicePixelRatio || 1;
    const rect = explorerRuntime.canvas.getBoundingClientRect();
    explorerRuntime.canvas.width = rect.width * dpr;
    explorerRuntime.canvas.height = rect.height * dpr;
    if (explorerRuntime.ctx) {
      explorerRuntime.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  }

  function initExplorerWorldIfNeeded() {
    if (!dom.trailCanvas) return;
    ensureTraillinesState();
    ensureExplorerState();
    ensureExplorerViewState();

    if (!explorerRuntime.canvas) {
      explorerRuntime.canvas = dom.trailCanvas;
      explorerRuntime.ctx = dom.trailCanvas.getContext("2d");
      wireExplorerCanvasInteractions(dom.trailCanvas);
      window.addEventListener("resize", function () {
        resizeTrailCanvas();
        renderExplorerWorld();
      });
    }

    resizeTrailCanvas();

    renderExplorerWorld();
  }

  function wireExplorerCanvasInteractions(canvas) {
    if (!canvas || canvas.dataset.explorerWired) return;
    canvas.dataset.explorerWired = "1";

    canvas.addEventListener("pointerdown", function (evt) {
      if (gameState.travelView !== "explorer" || canvas !== dom.trailCanvas) return;
      const view = ensureExplorerViewState();
      view.follow = false;
      explorerRuntime.dragPointerId = evt.pointerId;
      explorerRuntime.lastDragX = evt.clientX;
      explorerRuntime.lastDragY = evt.clientY;
      explorerRuntime.dragStartX = evt.clientX;
      explorerRuntime.dragStartY = evt.clientY;
      explorerRuntime.dragMoved = false;
      explorerRuntime.dragMode = "pan";
      const rect = canvas.getBoundingClientRect();
      const mm = explorerRuntime.minimapRect;
      if (view.showMinimap && mm) {
        const px = evt.clientX - rect.left;
        const py = evt.clientY - rect.top;
        if (px >= mm.x && px <= mm.x + mm.w && py >= mm.y && py <= mm.y + mm.h) {
          explorerRuntime.dragMode = "minimap";
          explorerRuntime.hover = null;
          view.camX = (px - mm.x) / mm.scaleX;
          view.camY = (py - mm.y) / mm.scaleY;
          clampExplorerCamera(view);
          renderExplorerWorld();
        }
      }
      if (canvas.setPointerCapture) canvas.setPointerCapture(evt.pointerId);
    });

    canvas.addEventListener("pointermove", function (evt) {
      if (gameState.travelView !== "explorer" || canvas !== dom.trailCanvas) return;
      const rect = canvas.getBoundingClientRect();
      const view = ensureExplorerViewState();
      const baseTileSize = Math.min(
        rect.width / EXPLORER_VIEWPORT.width,
        rect.height / EXPLORER_VIEWPORT.height
      );
      const tileSize = baseTileSize * (view.zoom || 1);
      if (!tileSize) return;

      if (
        explorerRuntime.dragPointerId != null &&
        explorerRuntime.dragPointerId === evt.pointerId
      ) {
        const dx = evt.clientX - explorerRuntime.lastDragX;
        const dy = evt.clientY - explorerRuntime.lastDragY;
        explorerRuntime.lastDragX = evt.clientX;
        explorerRuntime.lastDragY = evt.clientY;
        const mm = explorerRuntime.minimapRect;
        if (explorerRuntime.dragMode === "minimap" && mm) {
          const px = evt.clientX - rect.left;
          const py = evt.clientY - rect.top;
          view.follow = false;
          view.camX = (px - mm.x) / mm.scaleX;
          view.camY = (py - mm.y) / mm.scaleY;
          explorerRuntime.dragMoved =
            explorerRuntime.dragMoved ||
            Math.abs(evt.clientX - explorerRuntime.dragStartX) +
              Math.abs(evt.clientY - explorerRuntime.dragStartY) >
              3;
          clampExplorerCamera(view);
          renderExplorerWorld();
        } else {
          view.follow = false;
          view.camX -= dx / tileSize;
          view.camY -= dy / tileSize;
          explorerRuntime.hover = null;
          explorerRuntime.dragMoved =
            explorerRuntime.dragMoved ||
            Math.abs(evt.clientX - explorerRuntime.dragStartX) +
              Math.abs(evt.clientY - explorerRuntime.dragStartY) >
              3;
          clampExplorerCamera(view);
          renderExplorerWorld();
        }
        return;
      }

      if (!view.inspect) {
        if (explorerRuntime.hover) {
          explorerRuntime.hover = null;
          renderExplorerWorld();
        }
        return;
      }

      const hoverResult = getExplorerHoverFromClient(evt.clientX, evt.clientY);
      const hover = hoverResult && hoverResult.hover;
      if (!hover) {
        if (explorerRuntime.hover) {
          explorerRuntime.hover = null;
          renderExplorerWorld();
        }
        return;
      }

      if (!explorerRuntime.hover || explorerRuntime.hover._k !== hover._k) {
        explorerRuntime.hover = hover;
        renderExplorerWorld();
      }
    });

    canvas.addEventListener("pointerleave", function () {
      if (explorerRuntime.hover) {
        explorerRuntime.hover = null;
        renderExplorerWorld();
      }
    });

    function endDrag(evt) {
      if (evt && explorerRuntime.dragPointerId !== evt.pointerId) return;
      const wasMode = explorerRuntime.dragMode;
      const wasMoved = explorerRuntime.dragMoved;
      explorerRuntime.dragMode = null;
      explorerRuntime.dragMoved = false;
      if (canvas.releasePointerCapture && explorerRuntime.dragPointerId != null) {
        try {
          canvas.releasePointerCapture(explorerRuntime.dragPointerId);
        } catch (e) {}
      }
      explorerRuntime.dragPointerId = null;
      if (evt && evt.type === "pointerup") {
        const view = ensureExplorerViewState();
        if (view.inspect && wasMode === "pan" && !wasMoved) {
          const hoverResult = getExplorerHoverFromClient(evt.clientX, evt.clientY);
          const hover = hoverResult && hoverResult.hover;
          if (hover) {
            explorerRuntime.pinnedInspect = {
              hover: hover,
              clientX: evt.clientX,
              clientY: evt.clientY,
            };
            showExplorerTooltipAt(evt.clientX, evt.clientY, hover);
          }
        }
      }
    }

    canvas.addEventListener("pointerup", endDrag);
    canvas.addEventListener("pointercancel", endDrag);

    canvas.addEventListener(
      "wheel",
      function (evt) {
        if (gameState.travelView !== "explorer" || canvas !== dom.trailCanvas) return;
        evt.preventDefault();
        const view = ensureExplorerViewState();
        const delta = evt.deltaY;
        const step = delta > 0 ? -0.1 : 0.1;
        view.zoom = clamp((view.zoom || 1) + step, 0.75, 2.5);
        renderExplorerWorld();
      },
      { passive: false }
    );
  }

  function explorerPalette(region) {
    return {
      plains: { sky: "#324f7d", ground: "#5d4732", trail: "#c29f71", water: "#2b3f66", forest: "#35503c" },
      central_plains: { sky: "#3c5c87", ground: "#6a5038", trail: "#cbb27f", water: "#2f466f", forest: "#3d5d41" },
      high_plains: { sky: "#2f4e75", ground: "#5a4b3b", trail: "#c7a16c", water: "#2b4d72", forest: "#3b5a44" },
      mountains: { sky: "#2d3f63", ground: "#4b3f3a", trail: "#b39976", water: "#25405f", forest: "#355245" },
      snake_plain: { sky: "#34506d", ground: "#514234", trail: "#c2a175", water: "#2d4865", forest: "#3d5d49" },
      blue_mountains: { sky: "#243553", ground: "#4d4036", trail: "#b29472", water: "#233f5e", forest: "#305244" },
      columbia: { sky: "#2c3f5c", ground: "#3f3a33", trail: "#a88a65", water: "#23435f", forest: "#2f4d45" },
      willamette: { sky: "#2a4f53", ground: "#324136", trail: "#9d8f6e", water: "#234b5e", forest: "#2f5b4b" },
    }[region || "plains"] || {
      sky: "#324f7d",
      ground: "#5d4732",
      trail: "#c29f71",
      water: "#2b3f66",
      forest: "#35503c",
    };
  }

  const EXPLORER_ART = {
    prairie: { url: "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/prairie_orig.png" },
    river_bottom: { url: "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/river-bottom_orig.png" },
    steppe: { url: "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/steppe_orig.png" },
    alpine: { url: "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/alpine_orig.png" },
    desert_sage: { url: "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/desert-sage_orig.png" },
    conifer_forest: { url: "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/conifer-forest_orig.png" },
    river_gorge: { url: "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/river-gorge_orig.png" },
    valley: { url: "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/valley_orig.png" },
    great_basin_desert: { url: "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/great-basin-desert_orig.png" },
    alkali_flat: { url: "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/alkali-flat_orig.png" },
    icon_fort_stockade: { url: "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/fort-stockade_orig.png" },
    icon_town: { url: "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/icon-town_orig.png" },
  };

  const explorerArtCache = { images: {}, canvases: {} };

  const PAWN_SHEET_URL = "https://www.kylesalaya.com/uploads/9/3/7/0/93707764/pawns_orig.png";
  const pawnSheet = { status: "idle", img: null, frameW: 0, frameH: 0 };

  function getArtCanvas(key, size) {
    const art = EXPLORER_ART[key];
    if (!art) return null;
    const canvasKey = `${key}:${size}`;
    if (explorerArtCache.canvases[canvasKey]) return explorerArtCache.canvases[canvasKey];

    let record = explorerArtCache.images[key];
    if (!record) {
      const img = new Image();
      record = { img: img, status: "loading" };
      explorerArtCache.images[key] = record;
      img.crossOrigin = "anonymous";
      img.onload = function () {
        record.status = "loaded";
        const c = document.createElement("canvas");
        c.width = size;
        c.height = size;
        const cctx = c.getContext("2d");
        cctx.drawImage(img, 0, 0, size, size);
        explorerArtCache.canvases[canvasKey] = c;
        explorerRuntime.terrainCache = null;
        if (gameState.travelView === "explorer") {
          renderExplorerWorld();
        }
      };
      img.onerror = function () {
        record.status = "error";
      };
      img.src = art.url;
    }

    if (record.status === "loaded" && record.img && record.img.complete) {
      const c = document.createElement("canvas");
      c.width = size;
      c.height = size;
      const cctx = c.getContext("2d");
      cctx.drawImage(record.img, 0, 0, size, size);
      explorerArtCache.canvases[canvasKey] = c;
      return c;
    }

    return null;
  }

  function ensurePawnSheetLoaded() {
    if (pawnSheet.status === "idle") {
      const img = new Image();
      pawnSheet.img = img;
      pawnSheet.status = "loading";
      img.crossOrigin = "anonymous";
      img.onload = function () {
        pawnSheet.status = "loaded";
        pawnSheet.frameW = img.naturalWidth / 16;
        pawnSheet.frameH = img.naturalHeight / 2;
        renderExplorerWorld();
      };
      img.onerror = function () {
        pawnSheet.status = "error";
      };
      img.src = PAWN_SHEET_URL;
    }
    return pawnSheet;
  }

  function shadeColor(hex, delta) {
    const num = parseInt(hex.replace("#", ""), 16);
    const r = clamp(((num >> 16) & 0xff) + Math.round(255 * delta), 0, 255);
    const g = clamp(((num >> 8) & 0xff) + Math.round(255 * delta), 0, 255);
    const b = clamp((num & 0xff) + Math.round(255 * delta), 0, 255);
    return "#" + [r, g, b]
      .map(function (c) {
        const s = c.toString(16);
        return s.length === 1 ? "0" + s : s;
      })
      .join("");
  }

  function getRegionBaseArtKey(region) {
    return (
      {
        plains: "prairie",
        central_plains: "river_bottom",
        high_plains: "steppe",
        mountains: "alpine",
        great_basin: "great_basin_desert",
        snake_plain: "desert_sage",
        blue_mountains: "conifer_forest",
        columbia: "river_gorge",
        willamette: "valley",
      }[region] || "prairie"
    );
  }

  function getTileArtKey(tile, regionKey) {
    if (tile === "forest") return "conifer_forest";
    if (tile === "water") return "river_bottom";
    if (tile === "void") return "alkali_flat";
    return regionKey || "prairie";
  }

  function getExplorerTile(x, y) {
    if (y < 0 || y >= EXPLORER_WORLD.height) return "void";
    if (x < 0 || x >= EXPLORER_WORLD.width) return "void";
    return EXPLORER_WORLD.map[y][x] || "grass";
  }

  function regionForWorldX(tx) {
    const totalMiles = gameState.totalTrailMiles || gameState.targetMiles || 1;
    const worldWidth = Math.max(1, EXPLORER_WORLD.width - 1);
    const mileAlong = (clamp(tx, 0, worldWidth) / worldWidth) * Math.max(totalMiles, 1);
    let bandRegion = gameState.region || "plains";
    for (let i = 0; i < ROUTE_MILESTONES.length; i++) {
      const m = ROUTE_MILESTONES[i];
      if (m && m.mile <= mileAlong && m.region) {
        bandRegion = m.region;
      }
    }
    return bandRegion || "plains";
  }

  function getActiveRouteGeoAnchors() {
    const anchors = [];
    const milestones = getActiveRouteMilestones();
    milestones.forEach(function (m) {
      if (m == null || typeof m.mile !== "number" || !isFinite(m.mile)) return;
      const poi = m.poiId ? HEX_WORLD.poiById[m.poiId] : null;
      if (!poi || typeof poi.lat !== "number" || typeof poi.lon !== "number") return;
      if (!isFinite(poi.lat) || !isFinite(poi.lon)) return;
      anchors.push({ mile: m.mile, lat: poi.lat, lon: poi.lon });
    });
    anchors.sort(function (a, b) {
      return a.mile - b.mile;
    });
    return anchors;
  }

  function latLonAtMile(mile, anchors) {
    if (!anchors || !anchors.length) return null;
    if (mile <= anchors[0].mile) return { lat: anchors[0].lat, lon: anchors[0].lon };
    const last = anchors[anchors.length - 1];
    if (mile >= last.mile) return { lat: last.lat, lon: last.lon };
    for (let i = 0; i < anchors.length - 1; i++) {
      const a = anchors[i];
      const b = anchors[i + 1];
      if (mile >= a.mile && mile <= b.mile) {
        const span = Math.max(b.mile - a.mile, 1e-6);
        const t = clamp((mile - a.mile) / span, 0, 1);
        return { lat: a.lat + (b.lat - a.lat) * t, lon: a.lon + (b.lon - a.lon) * t };
      }
    }
    return { lat: anchors[0].lat, lon: anchors[0].lon };
  }

  function biomeAtMile(mile, anchors) {
    const ll = latLonAtMile(mile, anchors);
    if (!ll) return null;
    return hexBiomeForLatLon(ll.lat, ll.lon);
  }

  function clampExplorerCamera(view) {
    view.camX = clamp(view.camX, 0, Math.max(EXPLORER_WORLD.width - 1, 0));
    view.camY = clamp(view.camY, 0, Math.max(EXPLORER_WORLD.height - 1, 0));
  }

  function ensureExplorerTerrainCache(force, options) {
    const tilePx = 24;
    const builtKey =
      "v1:" +
      EXPLORER_WORLD.width +
      "x" +
      EXPLORER_WORLD.height +
      ":tilePx=" +
      tilePx;
    if (!force && explorerRuntime.terrainCache && explorerRuntime.terrainCache.builtKey === builtKey) {
      return explorerRuntime.terrainCache;
    }

    const palette = (options && options.palette) || explorerPalette(gameState.region || "plains");
    const totalMiles = (options && options.totalMiles) || gameState.totalTrailMiles || gameState.targetMiles || 1;
    const geoAnchors = (options && options.geoAnchors) || getActiveRouteGeoAnchors();
    const regionKey = (options && options.region) || gameState.region || "plains";
    const fallbackColors = {
      trail: palette.trail,
      grass: palette.ground,
      hill: shadeColor(palette.ground, 0.12),
      forest: palette.forest,
      water: palette.water,
      void: "#111519",
    };

    const canvas = document.createElement("canvas");
    canvas.width = EXPLORER_WORLD.width * tilePx;
    canvas.height = EXPLORER_WORLD.height * tilePx;
    const cacheCtx = canvas.getContext("2d");
    cacheCtx.imageSmoothingEnabled = false;

    for (let ty = 0; ty < EXPLORER_WORLD.height; ty++) {
      for (let tx = 0; tx < EXPLORER_WORLD.width; tx++) {
        const tile = getExplorerTile(tx, ty);
        const mileAtTile = getExplorerMileForTile(tx, ty, totalMiles);
        const bio = biomeAtMile(mileAtTile, geoAnchors);
        const baseArtKey = bio && bio.biome ? bio.biome : getRegionBaseArtKey(regionKey);
        const tileArtKey = getTileArtKey(tile, baseArtKey);
        const tileArt = getArtCanvas(tileArtKey, tilePx);
        const px = tx * tilePx;
        const py = ty * tilePx;
        if (tileArt) {
          cacheCtx.drawImage(tileArt, px, py, tilePx + 1, tilePx + 1);
        } else {
          cacheCtx.fillStyle = fallbackColors[tile] || palette.ground;
          cacheCtx.fillRect(px, py, tilePx + 1, tilePx + 1);
        }
        if (tile === "trail") {
          cacheCtx.fillStyle = "rgba(0,0,0,0.18)";
          cacheCtx.fillRect(px, py, tilePx + 1, tilePx * 0.12);
        }
      }
    }

    explorerRuntime.terrainCache = {
      canvas: canvas,
      ctx: cacheCtx,
      tilePx: tilePx,
      builtKey: builtKey,
    };
    return explorerRuntime.terrainCache;
  }

  function buildExplorerInspectHTML(hover) {
    if (!hover) return "";
    const lines = [];
    if (hover.milestoneName) lines.push("Milestone: " + hover.milestoneName);
    if (hover.biome || hover.region)
      lines.push("Biome: " + (hover.biome || "?") + " (" + (hover.region || "?") + ")");
    lines.push("Terrain: " + (hover.tile || "?"));
    if (hover.tx != null && hover.ty != null) lines.push("Tile: " + hover.tx + ", " + hover.ty);
    if (hover.mile != null) lines.push("Mile: ~" + Math.round(hover.mile));
    return (
      "<header><span>Inspect</span><button data-action=\"close-inspect\" type=\"button\">×</button></header>" +
      lines.map(function (line) {
        return "<div>" + line + "</div>";
      }).join("")
    );
  }

  function hideExplorerTooltip() {
    if (dom.explorerTooltip) dom.explorerTooltip.style.display = "none";
  }

  function showExplorerTooltipAt(clientX, clientY, hover) {
    if (!dom.explorerTooltip || !hover) return;
    const rect = dom.trailCanvas ? dom.trailCanvas.getBoundingClientRect() : null;
    if (!rect) return;
    dom.explorerTooltip.innerHTML = buildExplorerInspectHTML(hover);
    dom.explorerTooltip.style.display = "block";
    const localX = clientX - rect.left;
    const localY = clientY - rect.top;
    const margin = 8;
    const width = rect.width;
    const height = rect.height;
    let posX = clamp(localX, margin, width - margin);
    let posY = clamp(localY, margin, height - margin);
    dom.explorerTooltip.style.left = posX + "px";
    dom.explorerTooltip.style.top = posY + "px";
  }

  function getExplorerHoverFromClient(clientX, clientY) {
    if (!dom.trailCanvas) return null;
    const rect = dom.trailCanvas.getBoundingClientRect();
    const view = ensureExplorerViewState();
    const baseTileSize = Math.min(
      rect.width / EXPLORER_VIEWPORT.width,
      rect.height / EXPLORER_VIEWPORT.height
    );
    const tileSize = baseTileSize * (view.zoom || 1);
    if (!tileSize) return null;

    const visibleTilesX = Math.max(1, Math.ceil(rect.width / tileSize) + 1);
    const visibleTilesY = Math.max(1, Math.ceil(rect.height / tileSize) + 1);
    const startX = clamp(
      Math.floor(view.camX - visibleTilesX / 2),
      0,
      Math.max(EXPLORER_WORLD.width - visibleTilesX, 0)
    );
    const startY = clamp(
      Math.floor(view.camY - visibleTilesY / 2),
      0,
      Math.max(EXPLORER_WORLD.height - visibleTilesY, 0)
    );

    const px = clientX - rect.left;
    const py = clientY - rect.top;
    const localX = Math.floor(px / tileSize);
    const localY = Math.floor((py - tileSize * 0.3) / tileSize);
    if (localX < 0 || localY < 0 || localX >= visibleTilesX || localY >= visibleTilesY)
      return { hover: null };

    const tx = startX + localX;
    const ty = startY + localY;
    const tile = getExplorerTile(tx, ty);
    const totalMiles = gameState.totalTrailMiles || gameState.targetMiles || 1;
    const mileAtTile = getExplorerMileForTile(tx, ty, totalMiles);
    const geoAnchors = getActiveRouteGeoAnchors();
    const bio = biomeAtMile(mileAtTile, geoAnchors);

    const fogMiles =
      (gameState.traillines && gameState.traillines.fogMaxMile) ||
      gameState.milesTraveled ||
      0;
    const fogProgress = clamp(
      fogMiles / Math.max(gameState.targetMiles || 1, 1),
      0,
      1
    );
    const frontierIdx = Math.floor(
      fogProgress * Math.max(EXPLORER_WORLD.path.length - 1, 0)
    );

    let milestoneName = null;
    const milestones = getActiveRouteMilestones();
    milestones.forEach(function (m) {
      if (milestoneName || m.mile == null) return;
      const fraction = clamp(m.mile / Math.max(totalMiles, 1), 0, 1);
      const idx = Math.round(
        fraction * Math.max(EXPLORER_WORLD.path.length - 1, 0)
      );
      const pt = EXPLORER_WORLD.path[idx];
      if (!pt || pt.x !== tx || pt.y !== ty) return;
      const pathIdx = EXPLORER_WORLD.pathIndex[`${pt.x},${pt.y}`];
      const seen = pathIdx == null || pathIdx <= frontierIdx + 1;
      if (!seen) return;
      const poi = HEX_WORLD.poiById[m.poiId];
      if (!poi) return;
      milestoneName = poi.name || poi.id || null;
    });

    const biomeKey = bio ? bio.biome : "";
    const hoverKey = `${tx},${ty}:${milestoneName || ""}:${tile}:${biomeKey}:${Math.round(
      mileAtTile || 0
    )}`;
    return {
      hover: {
        tx: tx,
        ty: ty,
        tile: tile,
        mile: mileAtTile,
        biome: bio && bio.biome,
        region: bio && bio.region,
        milestoneName: milestoneName,
        _k: hoverKey,
      },
      startX: startX,
      startY: startY,
      visibleTilesX: visibleTilesX,
      visibleTilesY: visibleTilesY,
      tileSize: tileSize,
    };
  }

  function getExplorerWagonProgress() {
    const totalMiles = gameState.totalTrailMiles || gameState.targetMiles || 1;
    const traveled = Math.max(0, gameState.milesTraveled || 0);
    const progressFrac = clamp(traveled / Math.max(totalMiles, 1), 0, 1);
    const pathLen = Math.max(EXPLORER_WORLD.path.length - 1, 0);
    const idx = clamp(Math.floor(progressFrac * pathLen), 0, pathLen);
    const tile = EXPLORER_WORLD.path[idx] || EXPLORER_WORLD.path[pathLen] || { x: 0, y: 0 };
    return { tile: tile, idx: idx };
  }

  function getExplorerMileForTile(tx, ty, totalMiles) {
    const key = `${tx},${ty}`;
    const pathLen = Math.max(EXPLORER_WORLD.path.length - 1, 0);
    if (pathLen <= 0) return 0;
    let idx = EXPLORER_WORLD.pathIndex[key];
    if (idx == null && EXPLORER_WORLD.nearestPathIdx) {
      if (ty >= 0 && ty < EXPLORER_WORLD.nearestPathIdx.length) {
        const row = EXPLORER_WORLD.nearestPathIdx[ty];
        if (row && tx >= 0 && tx < row.length) idx = row[tx];
      }
    }
    if (idx == null) {
      const frac = clamp(tx / Math.max(EXPLORER_WORLD.width - 1, 1), 0, 1);
      idx = Math.round(frac * pathLen);
    }
    const miles = (idx / Math.max(pathLen, 1)) * Math.max(totalMiles || 1, 1);
    return clamp(miles, 0, Math.max(totalMiles || 1, 1));
  }

  function renderExplorerWorld() {
    if (!explorerRuntime.canvas || !explorerRuntime.ctx) return;
    const exploring =
      gameState.phase === "travel" && gameState.travelView === "explorer";
    if (!exploring) {
      explorerRuntime.ctx.clearRect(
        0,
        0,
        explorerRuntime.canvas.width,
        explorerRuntime.canvas.height
      );
      hideExplorerTooltip();
      explorerRuntime.minimapRect = null;
      return;
    }

    const renderStart = performance.now();
    ensureExplorerState();
    const view = ensureExplorerViewState();
    const rect = explorerRuntime.canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const width = rect.width;
    const height = rect.height;
    const ctx = explorerRuntime.ctx;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, width, height);

    const wagonProgress = getExplorerWagonProgress();
    const wagonTile = wagonProgress.tile;
    if (view.follow) {
      view.camX = wagonTile.x;
      view.camY = wagonTile.y;
    }
    view.zoom = clamp(view.zoom || 1, 0.75, 2.5);
    clampExplorerCamera(view);

    const region = gameState.region || "plains";
    const w = gameState.weatherState || {};
    const palette = explorerPalette(region);

    const skyTop = palette.sky;
    const skyBottom = w.tempC && w.tempC > 28 ? "#5b3d2a" : palette.sky;
    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, skyTop);
    gradient.addColorStop(1, skyBottom);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    const haze = Math.min(Math.max((w.clouds || 0) / 100, 0), 1);
    if (haze > 0) {
      ctx.fillStyle = `rgba(120, 140, 170, ${0.18 * haze})`;
      ctx.fillRect(0, 0, width, height);
    }

    const totalMiles = gameState.totalTrailMiles || gameState.targetMiles || 1;
    const geoAnchors = getActiveRouteGeoAnchors();

    const baseTileSize = Math.min(
      width / EXPLORER_VIEWPORT.width,
      height / EXPLORER_VIEWPORT.height
    );
    const tileSize = baseTileSize * view.zoom;
    if (!isFinite(tileSize) || tileSize <= 0) return;
    const visibleTilesX = Math.max(1, Math.ceil(width / tileSize) + 1);
    const visibleTilesY = Math.max(1, Math.ceil(height / tileSize) + 1);
    const startX = clamp(
      Math.floor(view.camX - visibleTilesX / 2),
      0,
      Math.max(EXPLORER_WORLD.width - visibleTilesX, 0)
    );
    const startY = clamp(
      Math.floor(view.camY - visibleTilesY / 2),
      0,
      Math.max(EXPLORER_WORLD.height - visibleTilesY, 0)
    );

    const fogMiles =
      (gameState.traillines && gameState.traillines.fogMaxMile) ||
      gameState.milesTraveled ||
      0;
    const fogProgress = clamp(
      fogMiles / Math.max(gameState.targetMiles || 1, 1),
      0,
      1
    );
    const frontierIdx = Math.floor(
      fogProgress * Math.max(EXPLORER_WORLD.path.length - 1, 0)
    );

    const fallbackColors = {
      trail: palette.trail,
      grass: palette.ground,
      hill: shadeColor(palette.ground, 0.12),
      forest: palette.forest,
      water: palette.water,
      void: "#111519",
    };

    let tileCount = 0;
    const terrainCache = ensureExplorerTerrainCache(false, {
      palette: palette,
      totalMiles: totalMiles,
      geoAnchors: geoAnchors,
      region: region,
    });

    if (terrainCache && terrainCache.canvas) {
      const prevSmoothing = ctx.imageSmoothingEnabled;
      ctx.imageSmoothingEnabled = false;
      const tilePx = terrainCache.tilePx || 1;
      const sx = startX * tilePx;
      const sy = startY * tilePx;
      const sw = visibleTilesX * tilePx;
      const sh = visibleTilesY * tilePx;
      const dx = 0;
      const dy = tileSize * 0.3;
      const dw = visibleTilesX * tileSize;
      const dh = visibleTilesY * tileSize;
      ctx.drawImage(terrainCache.canvas, sx, sy, sw, sh, dx, dy, dw, dh);
      ctx.imageSmoothingEnabled = prevSmoothing;
      tileCount = visibleTilesX * visibleTilesY;
    } else {
      for (let vy = 0; vy < visibleTilesY; vy++) {
        for (let vx = 0; vx < visibleTilesX; vx++) {
          const tx = startX + vx;
          const ty = startY + vy;
          const tile = getExplorerTile(tx, ty);
          const mileAtTile = getExplorerMileForTile(tx, ty, totalMiles);
          const bio = biomeAtMile(mileAtTile, geoAnchors);
          const baseArtKey =
            bio && bio.biome ? bio.biome : getRegionBaseArtKey(gameState.region || "plains");

          const px = vx * tileSize;
          const py = vy * tileSize + tileSize * 0.3;
          const tileArtKey = getTileArtKey(tile, baseArtKey);
          const tileArt = getArtCanvas(tileArtKey, 32);
          if (tileArt) {
            ctx.drawImage(tileArt, px, py, tileSize + 1, tileSize + 1);
          } else {
            ctx.fillStyle = fallbackColors[tile] || palette.ground;
            ctx.fillRect(px, py, tileSize + 1, tileSize + 1);
          }

          tileCount++;

          if (tile === "trail") {
            ctx.fillStyle = "rgba(0,0,0,0.18)";
            ctx.fillRect(px, py, tileSize + 1, tileSize * 0.12);
          }
        }
      }
    }

    for (let vy = 0; vy < visibleTilesY; vy++) {
      for (let vx = 0; vx < visibleTilesX; vx++) {
        const tx = startX + vx;
        const ty = startY + vy;
        const key = `${tx},${ty}`;
        const pathIdx = EXPLORER_WORLD.pathIndex[key];
        const seen = pathIdx == null || pathIdx <= frontierIdx + 1;
        if (!seen) {
          const px = vx * tileSize;
          const py = vy * tileSize + tileSize * 0.3;
          ctx.fillStyle = "rgba(8, 10, 14, 0.45)";
          ctx.fillRect(px, py, tileSize + 1, tileSize + 1);
        }
      }
    }

    // Horizon band to echo painterly viewport
    ctx.fillStyle = "rgba(0, 0, 0, 0.18)";
    ctx.fillRect(0, tileSize * 0.2, width, tileSize * 0.18);

    const milestones = getActiveRouteMilestones();
    milestones.forEach(function (m) {
      if (m.mile == null || !EXPLORER_WORLD.path.length) return;
      const fraction = clamp(m.mile / Math.max(totalMiles, 1), 0, 1);
      const idx = Math.round(
        fraction * Math.max(EXPLORER_WORLD.path.length - 1, 0)
      );
      const pt = EXPLORER_WORLD.path[idx];
      if (!pt) return;
      const pathIdx = EXPLORER_WORLD.pathIndex[`${pt.x},${pt.y}`];
      const seen = pathIdx == null || pathIdx <= frontierIdx + 1;
      if (!seen) return;
      if (
        pt.x < startX ||
        pt.x >= startX + visibleTilesX ||
        pt.y < startY ||
        pt.y >= startY + visibleTilesY
      ) {
        return;
      }
      const poi = HEX_WORLD.poiById[m.poiId];
      if (!poi) return;
      const iconKey = poi.type && poi.type.indexOf("fort") !== -1 ? "icon_fort_stockade" : "icon_town";
      const iconCanvas = getArtCanvas(iconKey, 24);
      if (!iconCanvas) return;
      const vx = pt.x - startX + 0.5;
      const vy = pt.y - startY + 0.8;
      const cx = vx * tileSize;
      const cy = vy * tileSize;
      ctx.save();
      ctx.shadowColor = "rgba(0, 0, 0, 0.35)";
      ctx.shadowBlur = 6;
      ctx.drawImage(
        iconCanvas,
        cx - (tileSize * 0.6) / 2,
        cy - (tileSize * 0.6) / 2,
        tileSize * 0.6,
        tileSize * 0.6
      );
      ctx.restore();

      if (
        view.inspect &&
        explorerRuntime.hover &&
        explorerRuntime.hover.tx === pt.x &&
        explorerRuntime.hover.ty === pt.y &&
        explorerRuntime.hover.milestoneName === poi.name
      ) {
        ctx.save();
        ctx.font = `${Math.max(10, tileSize * 0.28)}px 'Trebuchet MS', 'Segoe UI', sans-serif`;
        ctx.fillStyle = "#f7f3e9";
        ctx.strokeStyle = "rgba(0, 0, 0, 0.6)";
        ctx.lineWidth = 3;
        ctx.textBaseline = "bottom";
        ctx.textAlign = "center";
        ctx.strokeText(poi.name, cx, cy - tileSize * 0.5);
        ctx.fillText(poi.name, cx, cy - tileSize * 0.5);
        ctx.restore();
      }
    });

    const wagonX = (wagonTile.x - startX + 0.5) * tileSize;
    const wagonY = (wagonTile.y - startY + 0.9) * tileSize;
    const prevPt = EXPLORER_WORLD.path[wagonProgress.idx - 1];
    const nextPt = EXPLORER_WORLD.path[wagonProgress.idx + 1];
    let dirX = 0;
    let dirY = 0;
    if (nextPt) {
      dirX = nextPt.x - wagonTile.x;
      dirY = nextPt.y - wagonTile.y;
    } else if (prevPt) {
      dirX = wagonTile.x - prevPt.x;
      dirY = wagonTile.y - prevPt.y;
    }
    const absX = Math.abs(dirX);
    const absY = Math.abs(dirY);
    let facing = "south";
    if (absX > absY && dirX !== 0) facing = dirX > 0 ? "east" : "west";
    else if (absY > 0) facing = dirY > 0 ? "south" : "north";
    const oxenCount = Math.max(
      0,
      Math.floor((gameState.supplies && gameState.supplies.oxen) || 0)
    );
    const visualOxen = Math.min(6, oxenCount);
    if (visualOxen > 0) {
      const pairCount = Math.ceil(visualOxen / 2);
      const yokeSpacing = tileSize * 0.32;
      const laneOffset = tileSize * 0.14;
      const hitchStartX = wagonX + tileSize * 0.32;
      const oxBodyColor = "rgba(133, 96, 66, 0.95)";
      const oxOutline = "#3a2a1c";
      for (let i = 0; i < pairCount; i++) {
        const pairX = wagonX + tileSize * 0.45 + i * yokeSpacing;
        const hitchEndX = pairX - tileSize * 0.14;
        ctx.strokeStyle = "rgba(90, 70, 48, 0.8)";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(hitchStartX + i * 0.06 * tileSize, wagonY);
        ctx.lineTo(hitchEndX, wagonY);
        ctx.stroke();

        for (let lane = 0; lane < 2; lane++) {
          const idx = i * 2 + lane;
          if (idx >= visualOxen) break;
          const offsetY = lane === 0 ? -laneOffset : laneOffset;
          const oxX = pairX;
          const oxY = wagonY + offsetY;
          ctx.fillStyle = oxBodyColor;
          ctx.strokeStyle = oxOutline;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(
            oxX,
            oxY,
            tileSize * 0.24,
            tileSize * 0.12,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.stroke();

          ctx.beginPath();
          ctx.ellipse(
            oxX + tileSize * 0.16,
            oxY - tileSize * 0.02,
            tileSize * 0.07,
            tileSize * 0.07,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.stroke();

          ctx.strokeStyle = "#2d1d12";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(oxX + tileSize * 0.21, oxY - tileSize * 0.06);
          ctx.lineTo(oxX + tileSize * 0.25, oxY - tileSize * 0.1);
          ctx.moveTo(oxX + tileSize * 0.21, oxY + tileSize * 0.02);
          ctx.lineTo(oxX + tileSize * 0.25, oxY + tileSize * 0.06);
          ctx.stroke();
        }
      }
    }

    ctx.fillStyle = "#cdb89a";
    ctx.strokeStyle = "#4a321a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    if (ctx.roundRect) {
      ctx.roundRect(
        wagonX - tileSize * 0.35,
        wagonY - tileSize * 0.55,
        tileSize * 0.7,
        tileSize * 0.55,
        tileSize * 0.18
      );
    } else {
      ctx.rect(
        wagonX - tileSize * 0.35,
        wagonY - tileSize * 0.55,
        tileSize * 0.7,
        tileSize * 0.55
      );
    }
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "#7a5a3c";
    ctx.fillRect(
      wagonX - tileSize * 0.4,
      wagonY - tileSize * 0.05,
      tileSize * 0.8,
      tileSize * 0.15
    );

    ctx.fillStyle = "#f7e7cb";
    ctx.beginPath();
    ctx.ellipse(
      wagonX - tileSize * 0.22,
      wagonY + tileSize * 0.08,
      tileSize * 0.15,
      tileSize * 0.15,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(
      wagonX + tileSize * 0.22,
      wagonY + tileSize * 0.08,
      tileSize * 0.15,
      tileSize * 0.15,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();

    ctx.fillStyle = "rgba(245, 233, 210, 0.65)";
    ctx.fillRect(
      wagonX - tileSize * 0.18,
      wagonY - tileSize * 0.5,
      tileSize * 0.36,
      tileSize * 0.16
    );

    const pawns = getAllPeople()
      .filter(function (p) {
        return p && p.alive;
      })
      .slice(0, 3);
    const sheet = ensurePawnSheetLoaded();
    if (
      pawns.length &&
      sheet.status === "loaded" &&
      sheet.img &&
      sheet.frameW &&
      sheet.frameH
    ) {
      const dirIndex = { south: 0, west: 1, east: 2, north: 3 }[facing] || 0;
      const moving = gameState.mode === "travel" && (gameState.lastHourMiles || 0) > 0;
      const frame = moving ? 1 + (Math.floor(Date.now() / 180) % 3) : 0;
      const offsets = [
        { x: -0.18, y: -0.3 },
        { x: 0.16, y: -0.24 },
        { x: -0.02, y: -0.46 },
      ];
      const drawW = tileSize * 0.72;
      const drawH = drawW * (sheet.frameH / sheet.frameW);
      pawns.forEach(function (person, idx) {
        const offset = offsets[idx] || offsets[offsets.length - 1];
        const gender = (person && person.genderHint) || "";
        const row = /female|woman|girl/i.test(gender) ? 1 : 0;
        const sx = (dirIndex * 4 + frame) * sheet.frameW;
        const sy = row * sheet.frameH;
        const px = wagonX + offset.x * tileSize - drawW / 2;
        const py = wagonY + offset.y * tileSize - drawH * 0.1;
        ctx.drawImage(sheet.img, sx, sy, sheet.frameW, sheet.frameH, px, py, drawW, drawH);
      });
    }

    if (w.precip === "rain") {
      ctx.strokeStyle = "rgba(160, 200, 255, 0.35)";
      ctx.lineWidth = 1.2;
      for (let i = 0; i < width / 8; i++) {
        const x = (i * 11 + (Date.now() / 20) % 11) % width;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x + 4, 14);
        ctx.stroke();
      }
    } else if (w.precip === "snow") {
      ctx.fillStyle = "rgba(240, 240, 255, 0.55)";
      for (let i = 0; i < width / 12; i++) {
        const x = (i * 13 + (Date.now() / 40) % 13) % width;
        const y = (i * 17 + (Date.now() / 30) % 17) % height;
        ctx.beginPath();
        ctx.arc(x, y, 1.1, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if ((w.tempC || 0) > 28) {
      ctx.fillStyle = "rgba(210, 160, 80, 0.12)";
      ctx.fillRect(0, 0, width, height);
    }

    if (view.showMinimap) {
      const mmMargin = Math.max(6, width * 0.01);
      const mmWidth = Math.max(90, Math.min(180, width * 0.3));
      const mmHeight = mmWidth * (EXPLORER_WORLD.height / EXPLORER_WORLD.width);
      const mmX = width - mmWidth - mmMargin;
      const mmY = mmMargin;
      const scaleX = mmWidth / EXPLORER_WORLD.width;
      const scaleY = mmHeight / EXPLORER_WORLD.height;
      explorerRuntime.minimapRect = { x: mmX, y: mmY, w: mmWidth, h: mmHeight, scaleX: scaleX, scaleY: scaleY };
      ctx.save();
      ctx.fillStyle = "rgba(8, 10, 14, 0.35)";
      ctx.strokeStyle = "rgba(255, 255, 255, 0.25)";
      ctx.lineWidth = 1;
      ctx.fillRect(mmX, mmY, mmWidth, mmHeight);
      ctx.strokeRect(mmX, mmY, mmWidth, mmHeight);

      ctx.save();
      ctx.translate(mmX, mmY);

      ctx.strokeStyle = "rgba(240, 235, 220, 0.25)";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      EXPLORER_WORLD.path.forEach(function (p, idx) {
        const px = p.x * scaleX;
        const py = p.y * scaleY;
        if (idx === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      });
      ctx.stroke();

      ctx.strokeStyle = "rgba(255, 240, 200, 0.65)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      EXPLORER_WORLD.path.forEach(function (p, idx) {
        if (idx > frontierIdx + 1) return;
        const px = p.x * scaleX;
        const py = p.y * scaleY;
        if (idx === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      });
      ctx.stroke();

      const minimapMilestones = getActiveRouteMilestones();
      minimapMilestones.forEach(function (m) {
        if (m.mile == null) return;
        const fraction = clamp(m.mile / Math.max(totalMiles, 1), 0, 1);
        const idx = Math.round(fraction * Math.max(EXPLORER_WORLD.path.length - 1, 0));
        const pt = EXPLORER_WORLD.path[idx];
        if (!pt) return;
        const pathIdx = EXPLORER_WORLD.pathIndex[`${pt.x},${pt.y}`];
        const seen = pathIdx == null || pathIdx <= frontierIdx + 1;
        const poi = m.poiId ? HEX_WORLD.poiById[m.poiId] : null;
        const px = pt.x * scaleX;
        const py = pt.y * scaleY;
        const alpha = seen ? 0.85 : 0.35;
        const type = poi && poi.type ? poi.type : "";
        ctx.save();
        ctx.translate(px, py);
        ctx.fillStyle = `rgba(245, 215, 161, ${alpha})`;
        ctx.strokeStyle = `rgba(20, 12, 8, ${alpha})`;
        ctx.lineWidth = 1;
        if (/fort|town|post/i.test(type)) {
          ctx.fillRect(-2.5, -2.5, 5, 5);
          ctx.strokeRect(-2.5, -2.5, 5, 5);
        } else if (/river|crossing|ford|spring/i.test(type)) {
          ctx.beginPath();
          ctx.moveTo(0, -3);
          ctx.lineTo(3, 0);
          ctx.lineTo(0, 3);
          ctx.lineTo(-3, 0);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.arc(0, 0, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }
        ctx.restore();
      });

      ctx.fillStyle = "#f5d7a1";
      ctx.beginPath();
      ctx.arc(wagonTile.x * scaleX, wagonTile.y * scaleY, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
      ctx.lineWidth = 1;
      ctx.strokeRect(
        startX * scaleX,
        startY * scaleY,
        visibleTilesX * scaleX,
        visibleTilesY * scaleY
      );

      ctx.restore();
      ctx.restore();
    } else {
      explorerRuntime.minimapRect = null;
    }

    const renderMs = performance.now() - renderStart;

    if (view.showPerf) {
      const perfText = `render: ${renderMs.toFixed(1)} ms | tiles: ${tileCount}`;
      ctx.save();
      ctx.font = "12px 'Trebuchet MS', 'Segoe UI', sans-serif";
      ctx.textBaseline = "top";
      ctx.textAlign = "right";
      ctx.fillStyle = "rgba(8, 10, 14, 0.65)";
      const perfWidth = ctx.measureText(perfText).width;
      ctx.fillRect(width - 6 - perfWidth - 8, 6, perfWidth + 8, 18);
      ctx.fillStyle = "#f4f2ec";
      ctx.fillText(perfText, width - 10, 8);
      ctx.restore();
    }

    if (view.inspect && explorerRuntime.hover) {
      const hover = explorerRuntime.hover;
      const lines = [];
      if (hover.milestoneName) lines.push(`Milestone: ${hover.milestoneName}`);
      if (hover.biome || hover.region) lines.push(`Biome: ${hover.biome || "?"} (${hover.region || "?"})`);
      lines.push(`Terrain: ${hover.tile || "?"}`);
      lines.push(`Tile: ${hover.tx}, ${hover.ty}`);
      if (hover.mile != null) lines.push(`Mile: ~${Math.round(hover.mile)}`);
      const padding = 8;
      const lineHeight = 16;
      ctx.save();
      ctx.font = "12px 'Trebuchet MS', 'Segoe UI', sans-serif";
      const panelWidth =
        Math.max.apply(
          null,
          lines.map(function (l) {
            return ctx.measureText(l).width;
          })
        ) +
        padding * 2;
      const panelHeight = lineHeight * lines.length + padding * 2;
      const panelX = 10;
      const panelY = height - panelHeight - 10;
      ctx.fillStyle = "rgba(8, 10, 14, 0.75)";
      ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
      ctx.lineWidth = 1;
      ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
      ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
      ctx.fillStyle = "#f5f0e6";
      ctx.textBaseline = "top";
      lines.forEach(function (line, idx) {
        ctx.fillText(line, panelX + padding, panelY + padding + idx * lineHeight);
      });
      ctx.restore();
    }

    if (!view.inspect) {
      explorerRuntime.pinnedInspect = null;
      hideExplorerTooltip();
    } else if (explorerRuntime.pinnedInspect && explorerRuntime.pinnedInspect.hover) {
      showExplorerTooltipAt(
        explorerRuntime.pinnedInspect.clientX,
        explorerRuntime.pinnedInspect.clientY,
        explorerRuntime.pinnedInspect.hover
      );
    } else {
      hideExplorerTooltip();
    }
  }

  /* Validation checklist (Explorer view updates)
    - Start new run → go to Travel → toggle Explorer.
    - Explorer canvas spans full embed width; layout doesn’t break Journal view.
    - Canvas resizes sharply when toggling views and when resizing the browser (no blur).
    - Tile images load progressively; if they fail, fallback colors still render.
    - Oxen count changes wagon team visuals (try buying/selling oxen); clamp works.
    - No new trail log spam during rendering.
    - Save/load still works (best effort).
    - Any “mythic/secret” content never appears in normal logs/events as a side effect.
  */

  function tickExplorerTimeForStep() {
    ensureExplorerState();
    const ex = gameState.explorer;
    const STEP_HOURS = 0.25;
    ex.hourBuffer = (ex.hourBuffer || 0) + STEP_HOURS;

    while (ex.hourBuffer >= 1) {
      advanceOneHour({ reason: "explorer_step" });
      ex.hourBuffer -= 1;
    }
  }

  function handleExplorerStep(dx, dy) {
    const view = ensureExplorerViewState();
    view.follow = false;
    view.camX += dx;
    view.camY += dy;
    clampExplorerCamera(view);
    renderExplorerWorld();
  }

  function recenterExplorerCameraOnWagon(options) {
    const view = ensureExplorerViewState();
    const progress = getExplorerWagonProgress();
    view.camX = progress.tile.x;
    view.camY = progress.tile.y;
    if (options && options.follow != null) {
      view.follow = options.follow;
    }
    clampExplorerCamera(view);
    renderExplorerWorld();
  }

  /* ========= OREGON TRAIL HEX MAP ===================================== */

  const HEX_FLAT_WIDTH_MI = 4;
  const HEX_RADIUS_MI = HEX_FLAT_WIDTH_MI / Math.sqrt(3);
  const HEX_MILES_PER_STEP = HEX_FLAT_WIDTH_MI;
  const OT_MID_LAT_RAD = (43 * Math.PI) / 180;
  const milesPerDegLat = 69;
  const milesPerDegLon = 69 * Math.cos(OT_MID_LAT_RAD);
  const OT_LAT0 = 37.5;
  const OT_LON0 = -124.0;
  const OT_LAT_MAX = 47;
  const OT_LON_MAX = -93;

  function latLonToMilesXY(lat, lon) {
    return {
      xMi: (lon - OT_LON0) * milesPerDegLon,
      yMi: (lat - OT_LAT0) * milesPerDegLat,
    };
  }

  function milesXYToLatLon(xMi, yMi) {
    return {
      lat: OT_LAT0 + yMi / milesPerDegLat,
      lon: OT_LON0 + xMi / milesPerDegLon,
    };
  }

  function axialToMilesXY(q, r) {
    const xMi = HEX_RADIUS_MI * Math.sqrt(3) * (q + r / 2);
    const yMi = HEX_RADIUS_MI * 1.5 * r;
    return { xMi: xMi, yMi: yMi };
  }

  function axialToPixel(q, r, pxPerMi) {
    const miles = axialToMilesXY(q, r);
    return { xPx: miles.xMi * pxPerMi, yPx: miles.yMi * pxPerMi };
  }

  function axialToCube(q, r) {
    return { x: q, z: r, y: -q - r };
  }

  function cubeToAxial(c) {
    return { q: c.x, r: c.z };
  }

  function cubeRound(c) {
    let rx = Math.round(c.x);
    let ry = Math.round(c.y);
    let rz = Math.round(c.z);

    const xDiff = Math.abs(rx - c.x);
    const yDiff = Math.abs(ry - c.y);
    const zDiff = Math.abs(rz - c.z);

    if (xDiff > yDiff && xDiff > zDiff) {
      rx = -ry - rz;
    } else if (yDiff > zDiff) {
      ry = -rx - rz;
    } else {
      rz = -rx - ry;
    }
    return { x: rx, y: ry, z: rz };
  }

  function milesXYToAxial(xMi, yMi) {
    const q = ((Math.sqrt(3) / 3) * xMi - (1 / 3) * yMi) / HEX_RADIUS_MI;
    const r = ((2 / 3) * yMi) / HEX_RADIUS_MI;
    const rounded = cubeRound(axialToCube(q, r));
    return { q: rounded.x, r: rounded.z };
  }

  function latLonToAxial(lat, lon) {
    const miles = latLonToMilesXY(lat, lon);
    return milesXYToAxial(miles.xMi, miles.yMi);
  }

  function axialKey(q, r) {
    return q + "," + r;
  }

  function hexNeighbors(q, r) {
    return [
      { q: q + 1, r: r },
      { q: q - 1, r: r },
      { q: q, r: r + 1 },
      { q: q, r: r - 1 },
      { q: q + 1, r: r - 1 },
      { q: q - 1, r: r + 1 },
    ];
  }

  const HEX_FEATURE_POLYLINES = {
    snakeRiver: [
      { lat: 42.3, lon: -110.9 },
      { lat: 42.55, lon: -111.3 },
      { lat: 42.8, lon: -111.7 },
      { lat: 42.98, lon: -112.2 },
      { lat: 43.2, lon: -112.6 },
      { lat: 43.35, lon: -112.95 },
      { lat: 43.45, lon: -113.2 },
      { lat: 43.55, lon: -113.55 },
      { lat: 43.7, lon: -113.9 },
      { lat: 43.85, lon: -114.25 },
      { lat: 43.96, lon: -114.6 },
      { lat: 43.9, lon: -115.0 },
      { lat: 43.82, lon: -115.3 },
      { lat: 43.76, lon: -115.6 },
      { lat: 43.7, lon: -115.9 },
      { lat: 43.65, lon: -116.2 },
      { lat: 43.62, lon: -116.5 },
      { lat: 43.58, lon: -116.8 },
      { lat: 43.55, lon: -117.05 },
      { lat: 43.5, lon: -117.3 },
      { lat: 43.4, lon: -117.55 },
      { lat: 43.25, lon: -117.8 },
    ],
    columbiaRiver: [
      { lat: 46.3, lon: -117.6 },
      { lat: 46.2, lon: -117.9 },
      { lat: 46.05, lon: -118.35 },
      { lat: 45.98, lon: -118.7 },
      { lat: 45.9, lon: -119.1 },
      { lat: 45.85, lon: -119.6 },
      { lat: 45.9, lon: -120.15 },
      { lat: 45.86, lon: -120.55 },
      { lat: 45.82, lon: -120.9 },
      { lat: 45.78, lon: -121.25 },
      { lat: 45.75, lon: -121.5 },
      { lat: 45.72, lon: -121.75 },
      { lat: 45.68, lon: -121.95 },
      { lat: 45.65, lon: -122.2 },
      { lat: 45.63, lon: -122.4 },
      { lat: 45.62, lon: -122.66 },
    ],
    bigSandy: [
      { lat: 42.6, lon: -109.55 },
      { lat: 42.58, lon: -109.45 },
      { lat: 42.56, lon: -109.35 },
      { lat: 42.54, lon: -109.25 },
      { lat: 42.53, lon: -109.15 },
      { lat: 42.52, lon: -109.05 },
      { lat: 42.51, lon: -108.9 },
      { lat: 42.52, lon: -108.75 },
      { lat: 42.54, lon: -108.6 },
      { lat: 42.56, lon: -108.5 },
    ],
    subletteDesert: [
      { lat: 42.6, lon: -110.55 },
      { lat: 42.55, lon: -110.35 },
      { lat: 42.52, lon: -110.2 },
      { lat: 42.5, lon: -110.05 },
      { lat: 42.47, lon: -109.9 },
      { lat: 42.45, lon: -109.75 },
      { lat: 42.44, lon: -109.6 },
      { lat: 42.45, lon: -109.45 },
      { lat: 42.47, lon: -109.3 },
      { lat: 42.5, lon: -109.18 },
      { lat: 42.54, lon: -109.05 },
      { lat: 42.57, lon: -108.95 },
    ],
    humboldtRiver: [
      { lat: 41.12, lon: -114.96 },
      { lat: 41.02, lon: -115.35 },
      { lat: 41.0, lon: -115.7 },
      { lat: 40.95, lon: -116.1 },
      { lat: 40.9, lon: -116.5 },
      { lat: 40.82, lon: -116.9 },
      { lat: 40.76, lon: -117.3 },
      { lat: 40.72, lon: -117.6 },
      { lat: 40.68, lon: -117.9 },
      { lat: 40.63, lon: -118.15 },
      { lat: 40.6, lon: -118.35 },
    ],
    applegateBlackRockHighRock: [
      { lat: 40.46, lon: -118.31 },
      { lat: 40.66, lon: -118.55 },
      { lat: 40.82, lon: -118.78 },
      { lat: 40.97, lon: -118.98 },
      { lat: 41.12, lon: -119.25 },
      { lat: 41.22, lon: -119.45 },
      { lat: 41.32, lon: -119.62 },
      { lat: 41.4, lon: -119.74 },
      { lat: 41.49, lon: -119.9 },
      { lat: 41.58, lon: -120.05 },
      { lat: 41.66, lon: -120.18 },
      { lat: 41.53, lon: -120.18 },
    ],
  };

  function addHexToSet(set, hex) {
    set.add(axialKey(hex.q, hex.r));
  }

  function expandHexSet(baseSet, radius) {
    if (!radius || radius <= 0) return baseSet;
    const expanded = new Set(baseSet);
    baseSet.forEach(function (key) {
      const parts = key.split(",");
      const q = parseInt(parts[0], 10);
      const r = parseInt(parts[1], 10);
      const frontier = [{ q: q, r: r, d: 0 }];
      while (frontier.length) {
        const node = frontier.pop();
        if (node.d >= radius) continue;
        hexNeighbors(node.q, node.r).forEach(function (n) {
          const nKey = axialKey(n.q, n.r);
          if (!expanded.has(nKey)) {
            expanded.add(nKey);
            frontier.push({ q: n.q, r: n.r, d: node.d + 1 });
          }
        });
      }
    });
    return expanded;
  }

  function samplePolylineToHexes(polyline, spacingMi) {
    const set = new Set();
    if (!Array.isArray(polyline) || polyline.length < 2) return set;
    for (let i = 0; i < polyline.length - 1; i++) {
      const a = polyline[i];
      const b = polyline[i + 1];
      const aMiles = latLonToMilesXY(a.lat, a.lon);
      const bMiles = latLonToMilesXY(b.lat, b.lon);
      const dx = bMiles.xMi - aMiles.xMi;
      const dy = bMiles.yMi - aMiles.yMi;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const steps = Math.max(1, Math.ceil(dist / Math.max(0.01, spacingMi)));
      for (let s = 0; s <= steps; s++) {
        const t = s / steps;
        const mx = aMiles.xMi + dx * t;
        const my = aMiles.yMi + dy * t;
        const hex = milesXYToAxial(mx, my);
        addHexToSet(set, hex);
      }
    }
    return set;
  }

  function featureCorridorChoiceKey() {
    const choices = gameState.routeChoices || {};
    const ordered = {};
    Object.keys(choices)
      .sort()
      .forEach(function (key) {
        ordered[key] = choices[key];
      });
    return JSON.stringify(ordered);
  }

  function ensureFeatureCorridors() {
    const cacheKey = featureCorridorChoiceKey();
    if (
      LAST_FEATURE_BRANCH === cacheKey &&
      HEX_WORLD.featureHex.snakeRiver.size &&
      HEX_WORLD.featureHex.columbiaRiver.size &&
      HEX_WORLD.featureHex.humboldtRiver.size &&
      HEX_WORLD.featureHex.bigSandy.size &&
      HEX_WORLD.featureHex.applegateDesert
    ) {
      return;
    }
    const spacing = HEX_MILES_PER_STEP / 3;
    const snake = samplePolylineToHexes(HEX_FEATURE_POLYLINES.snakeRiver, spacing);
    const columbia = samplePolylineToHexes(
      HEX_FEATURE_POLYLINES.columbiaRiver,
      spacing
    );
    const humboldt = samplePolylineToHexes(HEX_FEATURE_POLYLINES.humboldtRiver, spacing);
    const bigSandy = samplePolylineToHexes(HEX_FEATURE_POLYLINES.bigSandy, spacing);
    const sublette =
      branchChoiceValue("sublette_or_bridger") === "sublette"
        ? samplePolylineToHexes(HEX_FEATURE_POLYLINES.subletteDesert, spacing)
        : new Set();
    const applegate =
      branchChoiceValue("applegate_cutoff") === "applegate"
        ? samplePolylineToHexes(
            HEX_FEATURE_POLYLINES.applegateBlackRockHighRock,
            spacing
          )
        : new Set();

    HEX_WORLD.featureHex.snakeRiver = expandHexSet(snake, 2);
    HEX_WORLD.featureHex.columbiaRiver = expandHexSet(columbia, 2);
    HEX_WORLD.featureHex.humboldtRiver = expandHexSet(humboldt, 2);
    HEX_WORLD.featureHex.bigSandy = expandHexSet(bigSandy, 1);
    HEX_WORLD.featureHex.subletteDesert = expandHexSet(sublette, 2);
    HEX_WORLD.featureHex.applegateDesert = expandHexSet(applegate, 2);
    LAST_FEATURE_BRANCH = cacheKey;
  }

  function drawHex(ctx, xPx, yPx, radiusPx) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI / 180) * (60 * i - 30);
      const px = xPx + radiusPx * Math.cos(angle);
      const py = yPx + radiusPx * Math.sin(angle);
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
  }

  const OT_POIS = [
    { id: "independence_mo", name: "Independence, MO", type: "town", lat: 39.0911, lon: -94.4155, region: "plains", tags: [] },
    { id: "st_joseph_mo", name: "St. Joseph, MO", type: "town", lat: 39.76685, lon: -94.83415, region: "plains", tags: [] },
    { id: "council_bluffs_ia", name: "Council Bluffs, IA", type: "town", lat: 41.25085, lon: -95.88204, region: "plains", tags: [] },
    { id: "kansas_river_pappans_ferry", name: "Pappan's Ferry (Kansas River)", type: "river_crossing", lat: 39.06385, lon: -95.68312, region: "plains", tags: ["kansas_river"] },
    { id: "alcove_springs_ks", name: "Alcove Springs", type: "springs", lat: 39.68882, lon: -96.63438, region: "plains", tags: [] },
    { id: "big_blue_independence_xing", name: "Big Blue Independence Crossing", type: "river_crossing", lat: 39.74972, lon: -96.6878, region: "plains", tags: ["big_blue_river"] },
    { id: "fort_kearny_ne", name: "Fort Kearny", type: "fort", lat: 40.65, lon: -99.0, region: "central_plains", tags: [] },
    { id: "courthouse_jail_rocks", name: "Courthouse & Jail Rocks", type: "landmark", lat: 41.59694, lon: -103.11583, region: "central_plains", tags: [] },
    { id: "chimney_rock_ne", name: "Chimney Rock", type: "landmark", lat: 41.70361, lon: -103.34833, region: "central_plains", tags: [] },
    { id: "scotts_bluff", name: "Scotts Bluff", type: "landmark", lat: 41.83472, lon: -103.70722, region: "central_plains", tags: [] },
    { id: "fort_laramie_wy", name: "Fort Laramie", type: "fort", lat: 42.20917, lon: -104.53586, region: "high_plains", tags: [] },
    { id: "register_cliff_wy", name: "Register Cliff", type: "landmark", lat: 42.24747, lon: -104.70552, region: "high_plains", tags: [] },
    { id: "independence_rock_wy", name: "Independence Rock", type: "landmark", lat: 42.49398, lon: -107.13259, region: "high_plains", tags: [] },
    { id: "devils_gate_wy", name: "Devil's Gate", type: "landmark", lat: 42.44889, lon: -107.21028, region: "high_plains", tags: [] },
    { id: "split_rock_wy", name: "Split Rock", type: "landmark", lat: 42.45358, lon: -107.5458, region: "high_plains", tags: [] },
    { id: "south_pass_wy", name: "South Pass", type: "mountain_pass", lat: 42.37, lon: -108.91361, region: "high_plains", tags: [] },
    { id: "lander_cutoff_turnoff_wy", name: "Lander Cutoff Turnoff", type: "junction", lat: 42.626, lon: -109.658, region: "high_plains", tags: ["lander_road", "cutoff", "junction"] },
    { id: "big_piney_wy", name: "Big Piney", type: "landmark", lat: 42.539768, lon: -110.11535, region: "high_plains", tags: ["lander_road"] },
    { id: "salt_river_pass_wy", name: "Salt River Pass", type: "pass", lat: 42.506154, lon: -110.908256, region: "mountains", tags: ["lander_road", "pass"] },
    { id: "afton_star_valley_wy", name: "Star Valley (Afton)", type: "landmark", lat: 42.724928, lon: -110.931869, region: "mountains", tags: ["lander_road"] },
    { id: "lander_idaho_junction_id", name: "Lander Road Junction (near Fort Hall)", type: "junction", lat: 43.0, lon: -112.26, region: "snake_plain", tags: ["lander_road", "junction"] },
    { id: "raft_river_parting_id", name: "Raft River Parting of the Ways", type: "junction", lat: 42.2846, lon: -113.4245, region: "snake_plain", tags: ["california_trail", "junction"] },
    { id: "city_of_rocks_id", name: "City of Rocks", type: "landmark", lat: 42.06988, lon: -113.71241, region: "snake_plain", tags: ["california_trail", "landmark"] },
    { id: "granite_pass_id", name: "Granite Pass", type: "pass", lat: 41.9926, lon: -113.856, region: "snake_plain", tags: ["california_trail", "pass"] },
    { id: "thousand_springs_valley_nv", name: "Thousand Springs Valley", type: "landmark", lat: 41.57297, lon: -114.43586, region: "snake_plain", tags: ["california_trail"] },
    { id: "wells_nv", name: "Wells", type: "landmark", lat: 41.112, lon: -114.964, region: "snake_plain", tags: ["california_trail"] },
    { id: "elko_nv", name: "Elko", type: "landmark", lat: 40.8324, lon: -115.7631, region: "snake_plain", tags: ["california_trail"] },
    { id: "battle_mountain_nv", name: "Battle Mountain", type: "landmark", lat: 40.6421, lon: -116.9343, region: "snake_plain", tags: ["california_trail"] },
    { id: "humboldt_corridor_nv", name: "Humboldt River Corridor", type: "river", lat: 40.6924, lon: -118.204, region: "snake_plain", tags: ["california_trail", "river"] },
    { id: "lassen_meadows_nv", name: "Lassen Meadows (Applegate Junction)", type: "junction", lat: 40.4617, lon: -118.3083, region: "snake_plain", tags: ["applegate_trail", "junction"] },
    { id: "black_rock_desert_nv", name: "Black Rock Desert", type: "landmark", lat: 40.910733, lon: -119.05601, region: "snake_plain", tags: ["applegate_trail", "desert"] },
    { id: "high_rock_canyon_nv", name: "High Rock Canyon", type: "landmark", lat: 41.3563, lon: -119.6107, region: "snake_plain", tags: ["applegate_trail"] },
    { id: "cedarville_ca", name: "Surprise Valley (Cedarville)", type: "landmark", lat: 41.53, lon: -120.1792, region: "snake_plain", tags: ["applegate_trail"] },
    { id: "goose_lake_border", name: "Goose Lake", type: "river", lat: 41.99433, lon: -120.32329, region: "snake_plain", tags: ["applegate_trail", "water"] },
    { id: "klamath_falls_or", name: "Klamath Basin (Klamath Falls)", type: "landmark", lat: 42.2249, lon: -121.7817, region: "blue_mountains", tags: ["applegate_trail"] },
    { id: "siskiyou_pass_caor", name: "Siskiyou Pass", type: "pass", lat: 42.050414, lon: -122.602806, region: "columbia", tags: ["applegate_trail", "pass"] },
    { id: "medford_or", name: "Rogue Valley (Medford)", type: "landmark", lat: 42.3265, lon: -122.8756, region: "columbia", tags: ["applegate_trail"] },
    { id: "willamette_entry_or", name: "Willamette Valley Entry", type: "landmark", lat: 44.0531, lon: -122.9911, region: "willamette", tags: ["applegate_trail", "valley"] },
    { id: "parting_of_ways_wy", name: "Parting of the Ways", type: "junction", lat: 42.2575, lon: -109.22833, region: "high_plains", tags: [] },
    { id: "green_river_lombard_ferry", name: "Green River Ferry", type: "river_crossing", lat: 42.87978, lon: -109.80752, region: "mountains", tags: ["green_river"] },
    { id: "fort_bridger_wy", name: "Fort Bridger", type: "fort", lat: 41.31872, lon: -110.38642, region: "mountains", tags: [] },
    { id: "soda_springs_id", name: "Soda Springs", type: "springs", lat: 42.65806, lon: -111.59611, region: "snake_plain", tags: [] },
    { id: "fort_hall_id", name: "Fort Hall", type: "fort", lat: 42.98833, lon: -112.48167, region: "snake_plain", tags: [] },
    { id: "register_rock_id", name: "Register Rock", type: "landmark", lat: 42.65278, lon: -113.01611, region: "snake_plain", tags: [] },
    { id: "three_island_crossing_id", name: "Three Island Crossing", type: "river_crossing", lat: 42.9447, lon: -115.3181, region: "snake_plain", tags: ["snake_river"] },
    { id: "fort_boise_id", name: "Fort Boise", type: "fort", lat: 43.82364, lon: -117.02038, region: "snake_plain", tags: [] },
    { id: "burnt_river_or", name: "Burnt River", type: "river", lat: 44.57183, lon: -117.52103, region: "snake_plain", tags: [] },
    { id: "la_grande_or", name: "La Grande Valley", type: "valley", lat: 45.32722, lon: -118.09333, region: "blue_mountains", tags: [] },
    { id: "meacham_or", name: "Meacham Pass", type: "mountain_pass", lat: 45.50652, lon: -118.42135, region: "blue_mountains", tags: [] },
    { id: "fort_walla_walla_wa", name: "Fort Walla Walla", type: "fort", lat: 46.04819, lon: -118.36413, region: "columbia", tags: [] },
    { id: "whitman_mission_wa", name: "Whitman Mission", type: "mission", lat: 46.04, lon: -118.46139, region: "columbia", tags: [] },
    { id: "the_dalles_or", name: "The Dalles", type: "town", lat: 45.60167, lon: -121.175, region: "columbia", tags: [] },
    { id: "government_camp_or", name: "Government Camp", type: "barlow_road_node", lat: 45.30222, lon: -121.7525, region: "mountains", tags: [] },
    { id: "fort_vancouver_wa", name: "Fort Vancouver", type: "fort", lat: 45.62233, lon: -122.66169, region: "columbia", tags: [] },
    { id: "oregon_city_or", name: "Oregon City", type: "town", lat: 45.35694, lon: -122.60667, region: "willamette", tags: [] },
    // filler to keep registers
  ];

  const OT_ROUTE_GRAPH = {
    starts: {
      independence: "independence_mo",
      st_joseph: "st_joseph_mo",
      council_bluffs: "council_bluffs_ia",
    },
    destination: "oregon_city_or",
    edges: [
      { id: "independence_kansas", from: "independence_mo", to: "kansas_river_pappans_ferry" },
      { id: "stjoseph_kansas", from: "st_joseph_mo", to: "kansas_river_pappans_ferry" },
      { id: "kansas_alcove", from: "kansas_river_pappans_ferry", to: "alcove_springs_ks" },
      { id: "alcove_bigblue", from: "alcove_springs_ks", to: "big_blue_independence_xing" },
      { id: "bigblue_kearny", from: "big_blue_independence_xing", to: "fort_kearny_ne" },
      { id: "council_kearny", from: "council_bluffs_ia", to: "fort_kearny_ne" },
      { id: "kearny_courthouse", from: "fort_kearny_ne", to: "courthouse_jail_rocks" },
      { id: "courthouse_chimney", from: "courthouse_jail_rocks", to: "chimney_rock_ne" },
      { id: "chimney_scotts", from: "chimney_rock_ne", to: "scotts_bluff" },
      { id: "scotts_laramie", from: "scotts_bluff", to: "fort_laramie_wy" },
      { id: "laramie_register", from: "fort_laramie_wy", to: "register_cliff_wy" },
      { id: "register_independence", from: "register_cliff_wy", to: "independence_rock_wy" },
      { id: "independence_devils", from: "independence_rock_wy", to: "devils_gate_wy" },
      { id: "devils_split", from: "devils_gate_wy", to: "split_rock_wy" },
      { id: "split_south", from: "split_rock_wy", to: "south_pass_wy" },
      { id: "south_parting", from: "south_pass_wy", to: "parting_of_ways_wy" },
      {
        id: "south_lander",
        from: "south_pass_wy",
        to: "lander_cutoff_turnoff_wy",
        branchKey: "lander_route",
        branchValue: "lander",
        routeKey: "lander",
      },
      {
        id: "lander_big_piney",
        from: "lander_cutoff_turnoff_wy",
        to: "big_piney_wy",
        routeKey: "lander",
      },
      {
        id: "big_piney_salt_river",
        from: "big_piney_wy",
        to: "salt_river_pass_wy",
        routeKey: "lander",
      },
      {
        id: "salt_river_afton",
        from: "salt_river_pass_wy",
        to: "afton_star_valley_wy",
        routeKey: "lander",
      },
      {
        id: "afton_soda",
        from: "afton_star_valley_wy",
        to: "soda_springs_id",
        routeKey: "lander",
      },
      {
        id: "soda_lander_junction",
        from: "soda_springs_id",
        to: "lander_idaho_junction_id",
        routeKey: "lander",
      },
      {
        id: "lander_junction_forthall",
        from: "lander_idaho_junction_id",
        to: "fort_hall_id",
        routeKey: "lander",
      },
      {
        id: "parting_bridger",
        from: "parting_of_ways_wy",
        to: "fort_bridger_wy",
        branchKey: "sublette_or_bridger",
        branchValue: "bridger",
      },
      {
        id: "bridger_soda",
        from: "fort_bridger_wy",
        to: "soda_springs_id",
        branchKey: "sublette_or_bridger",
        branchValue: "bridger",
      },
      {
        id: "parting_green",
        from: "parting_of_ways_wy",
        to: "green_river_lombard_ferry",
        branchKey: "sublette_or_bridger",
        branchValue: "sublette",
      },
      {
        id: "green_soda",
        from: "green_river_lombard_ferry",
        to: "soda_springs_id",
        branchKey: "sublette_or_bridger",
        branchValue: "sublette",
      },
      { id: "soda_forthall", from: "soda_springs_id", to: "fort_hall_id" },
      {
        id: "hall_raft_river",
        from: "fort_hall_id",
        to: "raft_river_parting_id",
        branchKey: "california_branch",
        branchValue: "california",
        routeKey: "california",
      },
      { id: "hall_register", from: "fort_hall_id", to: "register_rock_id" },
      {
        id: "raft_city_of_rocks",
        from: "raft_river_parting_id",
        to: "city_of_rocks_id",
        routeKey: "california",
      },
      { id: "city_of_rocks_granite", from: "city_of_rocks_id", to: "granite_pass_id", routeKey: "california" },
      { id: "granite_thousand_springs", from: "granite_pass_id", to: "thousand_springs_valley_nv", routeKey: "california" },
      { id: "thousand_wells", from: "thousand_springs_valley_nv", to: "wells_nv", routeKey: "california" },
      { id: "wells_elko", from: "wells_nv", to: "elko_nv", routeKey: "california" },
      { id: "elko_battle_mountain", from: "elko_nv", to: "battle_mountain_nv", routeKey: "california" },
      { id: "battle_humboldt_corridor", from: "battle_mountain_nv", to: "humboldt_corridor_nv", routeKey: "california" },
      { id: "humboldt_lassen", from: "humboldt_corridor_nv", to: "lassen_meadows_nv", routeKey: "california" },
      {
        id: "lassen_black_rock",
        from: "lassen_meadows_nv",
        to: "black_rock_desert_nv",
        branchKey: "applegate_cutoff",
        branchValue: "applegate",
        routeKey: "applegate",
      },
      {
        id: "black_rock_high_rock",
        from: "black_rock_desert_nv",
        to: "high_rock_canyon_nv",
        branchKey: "applegate_cutoff",
        branchValue: "applegate",
        routeKey: "applegate",
      },
      {
        id: "high_rock_cedarville",
        from: "high_rock_canyon_nv",
        to: "cedarville_ca",
        branchKey: "applegate_cutoff",
        branchValue: "applegate",
        routeKey: "applegate",
      },
      {
        id: "cedarville_goose_lake",
        from: "cedarville_ca",
        to: "goose_lake_border",
        branchKey: "applegate_cutoff",
        branchValue: "applegate",
        routeKey: "applegate",
      },
      {
        id: "goose_lake_klamath",
        from: "goose_lake_border",
        to: "klamath_falls_or",
        branchKey: "applegate_cutoff",
        branchValue: "applegate",
        routeKey: "applegate",
      },
      {
        id: "klamath_siskiyou",
        from: "klamath_falls_or",
        to: "siskiyou_pass_caor",
        branchKey: "applegate_cutoff",
        branchValue: "applegate",
        routeKey: "applegate",
      },
      {
        id: "siskiyou_medford",
        from: "siskiyou_pass_caor",
        to: "medford_or",
        branchKey: "applegate_cutoff",
        branchValue: "applegate",
        routeKey: "applegate",
      },
      {
        id: "medford_willamette_entry",
        from: "medford_or",
        to: "willamette_entry_or",
        branchKey: "applegate_cutoff",
        branchValue: "applegate",
        routeKey: "applegate",
      },
      {
        id: "willamette_entry_oregon_city",
        from: "willamette_entry_or",
        to: "oregon_city_or",
        branchKey: "applegate_cutoff",
        branchValue: "applegate",
        routeKey: "applegate",
      },
      { id: "register_threeisland", from: "register_rock_id", to: "three_island_crossing_id" },
      { id: "threeisland_boise", from: "three_island_crossing_id", to: "fort_boise_id" },
      { id: "boise_burnt", from: "fort_boise_id", to: "burnt_river_or" },
      { id: "burnt_lagrande", from: "burnt_river_or", to: "la_grande_or" },
      { id: "lagrande_meacham", from: "la_grande_or", to: "meacham_or" },
      { id: "meacham_walla", from: "meacham_or", to: "fort_walla_walla_wa" },
      { id: "walla_whitman", from: "fort_walla_walla_wa", to: "whitman_mission_wa" },
      { id: "whitman_dalles", from: "whitman_mission_wa", to: "the_dalles_or" },
      {
        id: "dalles_vancouver",
        from: "the_dalles_or",
        to: "fort_vancouver_wa",
        branchKey: "dalles_route",
        branchValue: "columbia",
      },
      {
        id: "vancouver_oregon",
        from: "fort_vancouver_wa",
        to: "oregon_city_or",
        branchKey: "dalles_route",
        branchValue: "columbia",
      },
      {
        id: "dalles_barlow",
        from: "the_dalles_or",
        to: "government_camp_or",
        branchKey: "dalles_route",
        branchValue: "barlow",
      },
      {
        id: "barlow_oregon",
        from: "government_camp_or",
        to: "oregon_city_or",
        branchKey: "dalles_route",
        branchValue: "barlow",
      },
    ],
  };

  const HEX_WORLD = {
    poiById: {},
    poiHex: {},
    poiByHex: {},
    trailHex: new Set(),
    activeRouteMilestones: [],
    activePath: [],
    activePathMiles: [],
    activePathIndex: {},
    featureHex: {
      snakeRiver: new Set(),
      columbiaRiver: new Set(),
      humboldtRiver: new Set(),
      subletteDesert: new Set(),
      bigSandy: new Set(),
      applegateDesert: new Set(),
    },
  };

  let HEX_HOVER_KEY = null;
  const LAST_HEX_CLICK = { key: null, ts: 0 };
  let LAST_FEATURE_BRANCH = null;

  function preparePoiCaches() {
    HEX_WORLD.poiById = {};
    HEX_WORLD.poiHex = {};
    HEX_WORLD.poiByHex = {};
    OT_POIS.forEach(function (p) {
      HEX_WORLD.poiById[p.id] = p;
      const h = latLonToAxial(p.lat, p.lon);
      HEX_WORLD.poiHex[p.id] = h;
      const key = axialKey(h.q, h.r);
      if (!HEX_WORLD.poiByHex[key]) HEX_WORLD.poiByHex[key] = [];
      HEX_WORLD.poiByHex[key].push(p.id);
    });
  }

  function hexDistance(a, b) {
    const ac = axialToCube(a.q, a.r);
    const bc = axialToCube(b.q, b.r);
    return Math.max(Math.abs(ac.x - bc.x), Math.abs(ac.y - bc.y), Math.abs(ac.z - bc.z));
  }

  function hexLerp(a, b, t) {
    const ac = axialToCube(a.q, a.r);
    const bc = axialToCube(b.q, b.r);
    return {
      x: ac.x + (bc.x - ac.x) * t,
      y: ac.y + (bc.y - ac.y) * t,
      z: ac.z + (bc.z - ac.z) * t,
    };
  }

  function hexLine(a, b) {
    const n = hexDistance(a, b);
    const results = [];
    for (let i = 0; i <= n; i++) {
      const t = n === 0 ? 0 : i / n;
      const c = cubeRound(hexLerp(a, b, t));
      results.push(cubeToAxial(c));
    }
    return results;
  }

  function branchChoiceValue(branchKey) {
    if (!branchKey) return null;
    if (!gameState.routeChoices) gameState.routeChoices = {};
    if (
      branchKey === "applegate_cutoff" &&
      gameState.routeChoices.california_branch === "california" &&
      !gameState.routeChoices.applegate_cutoff
    ) {
      return "applegate";
    }
    if (branchKey === "dalles_route" && gameState.routeChoices.blue_cutoff) {
      return gameState.routeChoices.blue_cutoff === "toll"
        ? "barlow"
        : "columbia";
    }
    if (gameState.routeChoices[branchKey]) return gameState.routeChoices[branchKey];
    if (branchKey === "sublette_or_bridger") return "bridger";
    if (branchKey === "dalles_route") return "barlow";
    return null;
  }

  function edgeMatchesBranch(edge) {
    if (!edge.branchKey) return true;
    const val = branchChoiceValue(edge.branchKey);
    if (!val) return false;
    return val === edge.branchValue;
  }

  function pickEdgeForCursor(edges) {
    if (!edges || !edges.length) return null;
    const matchingBranch = edges.find(function (edge) {
      return edge.branchKey && branchChoiceValue(edge.branchKey) === edge.branchValue;
    });
    if (matchingBranch) return matchingBranch;
    const defaultEdge = edges.find(function (edge) {
      return !edge.branchKey;
    });
    if (defaultEdge) return defaultEdge;
    return edges[0] || null;
  }

  function buildEdgesByFrom() {
    const edgesByFrom = {};
    OT_ROUTE_GRAPH.edges.forEach(function (e) {
      if (!edgesByFrom[e.from]) edgesByFrom[e.from] = [];
      edgesByFrom[e.from].push(e);
    });
    return edgesByFrom;
  }

  function getActiveRoutePoiSequence(edgesByFromOverride, startOverride, destOverride) {
    preparePoiCaches();
    const startId =
      startOverride ||
      OT_ROUTE_GRAPH.starts[gameState.startingPoint || "independence"] ||
      OT_ROUTE_GRAPH.starts.independence;
    const destination = destOverride || OT_ROUTE_GRAPH.destination;
    const edgesByFrom = edgesByFromOverride || buildEdgesByFrom();
    const sequence = [];
    const visited = new Set();
    let cursor = startId;
    let safety = 0;
    while (cursor && safety < 300) {
      sequence.push(cursor);
      visited.add(cursor);
      if (cursor === destination) break;
      const edge = pickEdgeForCursor(edgesByFrom[cursor]);
      if (!edge) break;
      if (visited.has(edge.to)) {
        sequence.push(edge.to);
        break;
      }
      cursor = edge.to;
      safety++;
    }
    return sequence;
  }

  function buildActiveRouteMilestones(edgesByFromOverride, startOverride, destOverride) {
    if (!HEX_WORLD.activePath.length) rebuildActiveRoutePath();
    const poiIds = getActiveRoutePoiSequence(
      edgesByFromOverride,
      startOverride,
      destOverride
    );
    const milestones = [];
    poiIds.forEach(function (poiId) {
      const poi = HEX_WORLD.poiById[poiId];
      if (!poi) return;
      const h = HEX_WORLD.poiHex[poiId];
      const key = h ? axialKey(h.q, h.r) : null;
      let idx = key != null ? HEX_WORLD.activePathIndex[key] : null;
      if (idx == null && h) {
        const foundIdx = HEX_WORLD.activePath.findIndex(function (hex) {
          return hex.q === h.q && hex.r === h.r;
        });
        if (foundIdx >= 0) {
          idx = foundIdx;
          HEX_WORLD.activePathIndex[key] = foundIdx;
        }
      }
      let mile = idx != null ? HEX_WORLD.activePathMiles[idx] : null;
      if (mile == null && idx != null) {
        mile = idx * HEX_MILES_PER_STEP;
      }
      milestones.push({
        poiId: poiId,
        name: poi.name,
        mile: mile != null ? mile : null,
        region: poi.region || "plains",
      });
    });
    HEX_WORLD.activeRouteMilestones = milestones;
    return milestones;
  }

  function getActiveRouteMilestones() {
    if (!HEX_WORLD.activeRouteMilestones || !HEX_WORLD.activeRouteMilestones.length) {
      buildActiveRouteMilestones();
    }
    return HEX_WORLD.activeRouteMilestones || [];
  }

  function rebuildActiveRoutePath() {
    preparePoiCaches();
    HEX_WORLD.trailHex = new Set();
    HEX_WORLD.activeRouteMilestones = [];
    HEX_WORLD.activePathIndex = {};
    const startId =
      OT_ROUTE_GRAPH.starts[gameState.startingPoint || "independence"] ||
      OT_ROUTE_GRAPH.starts.independence;
    const destination = OT_ROUTE_GRAPH.destination;
    const edgesByFrom = buildEdgesByFrom();
    const path = [];
    const pathMiles = [];
    let cursor = startId;
    let safety = 0;
    let miles = 0;
    while (cursor && safety < 200) {
      const poi = HEX_WORLD.poiById[cursor];
      const h = HEX_WORLD.poiHex[cursor];
      let key = null;
      if (h) {
        key = axialKey(h.q, h.r);
        if (!HEX_WORLD.poiByHex[key]) HEX_WORLD.poiByHex[key] = [];
        if (HEX_WORLD.poiByHex[key].indexOf(cursor) === -1) {
          HEX_WORLD.poiByHex[key].push(cursor);
        }
      }
      if (path.length === 0 || path[path.length - 1].q !== h.q || path[path.length - 1].r !== h.r) {
        path.push({ q: h.q, r: h.r });
        pathMiles.push(miles);
        HEX_WORLD.activePathIndex[key] = path.length - 1;
      }
      if (cursor === destination) break;
      const edge = pickEdgeForCursor(edgesByFrom[cursor], cursor);
      if (!edge) break;
      const nextPoi = HEX_WORLD.poiHex[edge.to];
      const segment = hexLine(h, nextPoi);
      for (let i = 1; i < segment.length; i++) {
        const hex = segment[i];
        const key = axialKey(hex.q, hex.r);
        HEX_WORLD.trailHex.add(key);
        miles += HEX_MILES_PER_STEP;
        path.push({ q: hex.q, r: hex.r });
        pathMiles.push(miles);
        HEX_WORLD.activePathIndex[key] = path.length - 1;
      }
      cursor = edge.to;
      safety++;
    }
    HEX_WORLD.activePath = path;
    HEX_WORLD.activePathMiles = pathMiles;
    const totalMiles = pathMiles.length ? pathMiles[pathMiles.length - 1] : miles;
    gameState.targetMiles = totalMiles;
    if (gameState.milesTraveled > totalMiles) {
      gameState.milesTraveled = totalMiles;
    }
    path.forEach(function (h) {
      HEX_WORLD.trailHex.add(axialKey(h.q, h.r));
    });
    ensureFeatureCorridors();
    buildActiveRouteMilestones(edgesByFrom, startId, destination);
    updateRegionAndLocation();
  }

  function ensureExplorerState(gs) {
    const state = gs || gameState;
    ensureHexMapState();
    if (!state.explorer) state.explorer = { x: 0, y: 0 };
    if (!HEX_WORLD.activePath.length) rebuildActiveRoutePath();
    const playerHex = getPlayerHexFromMiles();
    state.explorer.x = playerHex.q;
    state.explorer.y = playerHex.r;
    state.explorer.initializedFromProgress = true;
    return state.explorer;
  }

  function ensureExplorerViewState(gs) {
    const state = gs || gameState;
    if (!state.explorerView) {
      state.explorerView = {
        camX: 0,
        camY: 0,
        zoom: 1,
        follow: true,
        inspect: false,
        showMinimap: true,
        showPerf: false,
      };
    }
    const view = state.explorerView;
    if (typeof view.camX !== "number" || !isFinite(view.camX)) view.camX = 0;
    if (typeof view.camY !== "number" || !isFinite(view.camY)) view.camY = 0;
    if (typeof view.zoom !== "number" || !isFinite(view.zoom) || view.zoom <= 0)
      view.zoom = 1;
    view.zoom = clamp(view.zoom, 0.75, 2.5);
    if (view.inspect == null) view.inspect = false;
    if (view.showMinimap == null) view.showMinimap = true;
    if (view.showPerf == null) view.showPerf = false;
    view.inspect = !!view.inspect;
    view.showMinimap = !!view.showMinimap;
    view.showPerf = !!view.showPerf;
    if (view.follow == null) view.follow = true;
    view.camX = clamp(view.camX, 0, Math.max(EXPLORER_WORLD.width - 1, 0));
    view.camY = clamp(view.camY, 0, Math.max(EXPLORER_WORLD.height - 1, 0));
    return view;
  }

  function ensureHexMapState() {
    if (!gameState.hexMap) {
      gameState.hexMap = {
        follow: true,
        camQ: 0,
        camR: 0,
        zoom: 1,
        seen: {},
        plannedPath: [],
        plannedPathKeys: [],
        plannedDistanceMiles: 0,
        plannedEtaHours: 0,
        fogEnabled: false,
        silhouettesEnabled: true,
      };
    }
    if (!gameState.hexMap.seen) gameState.hexMap.seen = {};
    if (!gameState.hexMap.zoom) gameState.hexMap.zoom = 1;
    if (gameState.hexMap.follow == null) gameState.hexMap.follow = true;
    if (!gameState.hexMap.plannedPath) gameState.hexMap.plannedPath = [];
    if (!gameState.hexMap.plannedPathKeys) gameState.hexMap.plannedPathKeys = [];
    if (gameState.hexMap.plannedDistanceMiles == null)
      gameState.hexMap.plannedDistanceMiles = 0;
    if (gameState.hexMap.plannedEtaHours == null)
      gameState.hexMap.plannedEtaHours = 0;
    if (gameState.hexMap.fogEnabled == null) gameState.hexMap.fogEnabled = false;
    if (gameState.hexMap.silhouettesEnabled == null)
      gameState.hexMap.silhouettesEnabled = true;
    if (!gameState.hexMap.destination)
      gameState.hexMap.destination = { destKey: null, destQ: null, destR: null };
    if (!gameState.hexMap.lastHexModifiers)
      gameState.hexMap.lastHexModifiers = {};
    return gameState.hexMap;
  }

  function getPlayerHexFromMiles() {
    if (!HEX_WORLD.activePath.length) rebuildActiveRoutePath();
    const miles = Math.max(0, gameState.milesTraveled || 0);
    const idx = clamp(Math.floor(miles / HEX_MILES_PER_STEP), 0, HEX_WORLD.activePath.length - 1);
    return HEX_WORLD.activePath[idx] || { q: 0, r: 0 };
  }

  function getCurrentActivePathIndex() {
    if (!HEX_WORLD.activePath.length) rebuildActiveRoutePath();
    const miles = Math.max(0, gameState.milesTraveled || 0);
    return clamp(
      Math.floor(miles / HEX_MILES_PER_STEP),
      0,
      HEX_WORLD.activePath.length - 1
    );
  }

  function markSeenAroundPlayer(radius) {
    ensureHexMapState();
    const hm = gameState.hexMap;
    const r = Math.max(1, radius || 2);
    const center = getPlayerHexFromMiles();
    const frontier = [{ q: center.q, r: center.r, d: 0 }];
    const visited = new Set();
    while (frontier.length) {
      const node = frontier.pop();
      const key = axialKey(node.q, node.r);
      if (visited.has(key)) continue;
      visited.add(key);
      hm.seen[key] = true;
      if (node.d >= r) continue;
      hexNeighbors(node.q, node.r).forEach(function (n) {
        frontier.push({ q: n.q, r: n.r, d: node.d + 1 });
      });
    }
  }

  function moveHexCamera(dq, dr) {
    ensureHexMapState();
    const hm = gameState.hexMap;
    hm.follow = false;
    hm.camQ += dq;
    hm.camR += dr;
    const bound = 220;
    hm.camQ = clamp(hm.camQ, -bound, bound);
    hm.camR = clamp(hm.camR, -bound, bound);
    renderExplorer();
  }

  function recenterCameraOnPlayer() {
    const playerHex = getPlayerHexFromMiles();
    ensureHexMapState();
    const hm = gameState.hexMap;
    hm.camQ = playerHex.q;
    hm.camR = playerHex.r;
  }

  function getHexMapMetrics(rect) {
    ensureHexMapState();
    const cam = gameState.hexMap;
    const milesCenter = axialToMilesXY(cam.camQ, cam.camR);
    const pxPerMi = (rect.width / 14) / HEX_FLAT_WIDTH_MI * (cam.zoom || 1);
    const radiusPx = HEX_RADIUS_MI * pxPerMi;
    return { cam: cam, milesCenter: milesCenter, pxPerMi: pxPerMi, radiusPx: radiusPx };
  }

  function pixelToAxialOnCanvas(canvas, clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const metrics = getHexMapMetrics(rect);
    const px = clientX - rect.left;
    const py = clientY - rect.top;
    const dxMi = (px - rect.width / 2) / metrics.pxPerMi;
    const dyMi = (py - rect.height / 2) / metrics.pxPerMi;
    const miles = {
      xMi: metrics.milesCenter.xMi + dxMi,
      yMi: metrics.milesCenter.yMi + dyMi,
    };
    return milesXYToAxial(miles.xMi, miles.yMi);
  }

  function hexBiomeForLatLon(lat, lon) {
    const inGreatBasin = lon < -112 && lon > -121 && lat > 39 && lat < 43.8;
    if (inGreatBasin) {
      const noise = Math.sin((lat * 12.3 + lon * 7.7) * Math.PI * 0.07) * 0.5 + 0.5;
      if (noise < 0.32) return { region: "great_basin", biome: "alkali_flat" };
      return { region: "great_basin", biome: "great_basin_desert" };
    }
    if (lon > -97) return { region: "plains", biome: "prairie" };
    if (lon > -102) return { region: "central_plains", biome: "river_bottom" };
    if (lon > -108) return { region: "high_plains", biome: "steppe" };
    if (lon > -111) return { region: "mountains", biome: "alpine" };
    if (lon > -118) return { region: "snake_plain", biome: "desert_sage" };
    if (lon > -120) return { region: "blue_mountains", biome: "conifer_forest" };
    if (lon > -122.4) return { region: "columbia", biome: "river_gorge" };
    return { region: "willamette", biome: "valley" };
  }

  function getHexWorldModifiers(hex) {
    ensureFeatureCorridors();
    const key = axialKey(hex.q, hex.r);
    return {
      nearSnakeRiver: HEX_WORLD.featureHex.snakeRiver.has(key),
      nearColumbiaRiver: HEX_WORLD.featureHex.columbiaRiver.has(key),
      nearHumboldtRiver: HEX_WORLD.featureHex.humboldtRiver.has(key),
      inSubletteDesert: HEX_WORLD.featureHex.subletteDesert.has(key),
      atBigSandy: HEX_WORLD.featureHex.bigSandy.has(key),
      inApplegateDesert: HEX_WORLD.featureHex.applegateDesert.has(key),
      key: key,
    };
  }

  function resourceProfileForBiome(biome) {
    const base = {
      water: 0.3,
      wood: 0.3,
      game: 0.3,
      forage: 0.25,
    };
    switch (biome) {
      case "prairie":
        return { water: 0.35, wood: 0.1, game: 0.4, forage: 0.3 };
      case "river_bottom":
        return { water: 0.7, wood: 0.3, game: 0.4, forage: 0.45 };
      case "steppe":
        return { water: 0.3, wood: 0.15, game: 0.5, forage: 0.3 };
      case "desert_sage":
        return { water: 0.2, wood: 0.1, game: 0.3, forage: 0.2 };
      case "alpine":
        return { water: 0.6, wood: 0.45, game: 0.4, forage: 0.25 };
      case "conifer_forest":
        return { water: 0.55, wood: 0.65, game: 0.45, forage: 0.4 };
      case "river_gorge":
        return { water: 0.8, wood: 0.45, game: 0.35, forage: 0.3 };
      case "valley":
        return { water: 0.65, wood: 0.55, game: 0.35, forage: 0.55 };
      case "great_basin_desert":
        return { water: 0.18, wood: 0.08, game: 0.28, forage: 0.18 };
      case "alkali_flat":
        return { water: 0.08, wood: 0.05, game: 0.2, forage: 0.12 };
      default:
        return base;
    }
  }

  function getLocalResourceProfile(hexOverride) {
    const playerHex = hexOverride || getPlayerHexFromMiles();
    const miles = axialToMilesXY(playerHex.q, playerHex.r);
    const latlon = milesXYToLatLon(miles.xMi, miles.yMi);
    const regionBiome = hexBiomeForLatLon(latlon.lat, latlon.lon);
    const profile = resourceProfileForBiome(regionBiome.biome);
    const key = axialKey(playerHex.q, playerHex.r);
    const poiHere = HEX_WORLD.poiByHex[key] || [];
    const mods = getHexWorldModifiers(playerHex);
    const tags = [];
    let waterQualityHint = "mixed";

    const nearPoiWater = poiHere.some(function (id) {
      const p = HEX_WORLD.poiById[id];
      return p && p.type && p.type.indexOf("river") !== -1;
    });

    const hasRiverWater =
      mods.nearSnakeRiver || mods.nearColumbiaRiver || mods.nearHumboldtRiver || nearPoiWater;

    if (hasRiverWater) {
      profile.water = Math.min(1, profile.water + 0.3);
      profile.game = Math.min(1, profile.game + 0.12);
      profile.forage = Math.min(1, profile.forage + 0.1);
      waterQualityHint = "river";
      if (mods.nearSnakeRiver) tags.push("Snake corridor");
      if (mods.nearColumbiaRiver) tags.push("Columbia corridor");
      if (mods.nearHumboldtRiver) tags.push("Humboldt corridor");
    }

    if (mods.inSubletteDesert) {
      profile.water = Math.max(0.05, profile.water * 0.35);
      profile.forage = Math.max(0.05, profile.forage * 0.45);
      profile.game = Math.max(0.05, profile.game * 0.55);
      waterQualityHint = "alkali";
      tags.push("Sublette desert stretch");
    }

    if (mods.inApplegateDesert) {
      profile.water = Math.max(0.04, profile.water * 0.28);
      profile.forage = Math.max(0.04, profile.forage * 0.4);
      profile.game = Math.max(0.04, profile.game * 0.45);
      if (!hasRiverWater) waterQualityHint = "alkali";
      tags.push("Black Rock / High Rock waterless stretch");
    }

    if (mods.atBigSandy) {
      profile.water = Math.max(0.12, profile.water * 0.6);
      profile.forage = Math.max(0.08, profile.forage * 0.6);
      profile.game = Math.max(0.08, profile.game * 0.7);
      tags.push("Big Sandy basin");
    }

    profile.water = clamp(profile.water, 0, 1);
    profile.wood = clamp(profile.wood, 0, 1);
    profile.forage = clamp(profile.forage, 0, 1);
    profile.game = clamp(profile.game, 0, 1);

    profile.waterQualityHint = waterQualityHint;
    profile.region = regionBiome.region;
    profile.biome = regionBiome.biome;
    profile.tags = tags;
    return profile;
  }

  function getNearestPOIToPlayerHex(maxHexDistance) {
    const limit = maxHexDistance || 2;
    const playerHex = getPlayerHexFromMiles();
    let best = null;
    OT_POIS.forEach(function (p) {
      const h = HEX_WORLD.poiHex[p.id];
      const d = hexDistance(playerHex, h);
      if (d <= limit && (!best || d < best.dist)) {
        best = { poi: p, dist: d };
      }
    });
    return best ? best.poi : null;
  }

  function getNearbyFortPOI() {
    const p = getNearestPOIToPlayerHex(1);
    return p && p.type === "fort" ? p : null;
  }

  function estimateMilesPerHour() {
    const mph = computeMilesForHour();
    if (mph > 0.05) return mph;
    const paceCfg = PACE_CONFIG[gameState.pace] || PACE_CONFIG.steady;
    return paceCfg.milesPerHour * 0.9;
  }

  function computePlannedPath(startHex, destHex) {
    if (!HEX_WORLD.activePath.length) rebuildActiveRoutePath();
    const startKey = axialKey(startHex.q, startHex.r);
    const destKey = axialKey(destHex.q, destHex.r);
    if (!HEX_WORLD.trailHex.has(destKey)) return [];
    const startIdx = HEX_WORLD.activePathIndex[startKey];
    const destIdx = HEX_WORLD.activePathIndex[destKey];
    if (startIdx != null && destIdx != null && destIdx >= startIdx) {
      return HEX_WORLD.activePath.slice(startIdx, destIdx + 1);
    }

    const visited = new Set();
    const queue = [{ hex: startHex, path: [startHex] }];
    visited.add(startKey);
    while (queue.length) {
      const node = queue.shift();
      const key = axialKey(node.hex.q, node.hex.r);
      if (key === destKey) return node.path;
      hexNeighbors(node.hex.q, node.hex.r).forEach(function (n) {
        const nKey = axialKey(n.q, n.r);
        if (!HEX_WORLD.trailHex.has(nKey) || visited.has(nKey)) return;
        visited.add(nKey);
        queue.push({ hex: n, path: node.path.concat([n]) });
      });
    }
    return [];
  }

  function setTravelDestination(destHex, opts) {
    ensureHexMapState();
    const hm = gameState.hexMap;
    const destKey = axialKey(destHex.q, destHex.r);
    if (!HEX_WORLD.trailHex.has(destKey)) {
      addLog("That point is off the main trail. Pick a highlighted hex.");
      return false;
    }
    const startHex = getPlayerHexFromMiles();
    const path = computePlannedPath(startHex, destHex);
    if (!path.length) {
      addLog("No clear path to that waypoint from here.");
      return false;
    }
    hm.destination = { destKey: destKey, destQ: destHex.q, destR: destHex.r };
    hm.plannedPath = path;
    hm.plannedPathKeys = path.map(function (p) {
      return axialKey(p.q, p.r);
    });
    const steps = Math.max(0, path.length - 1);
    hm.plannedDistanceMiles = steps * HEX_MILES_PER_STEP;
    hm.plannedEtaHours = hm.plannedDistanceMiles / Math.max(0.25, estimateMilesPerHour());
    if (!opts || !opts.silent) {
      addLog("Travel target set.");
    }
    saveGame();
    renderAll();
    return true;
  }

  function clearTravelDestination() {
    ensureHexMapState();
    const hm = gameState.hexMap;
    hm.destination = { destKey: null, destQ: null, destR: null };
    hm.plannedPath = [];
    hm.plannedPathKeys = [];
    hm.plannedDistanceMiles = 0;
    hm.plannedEtaHours = 0;
    saveGame();
    renderAll();
  }

  function remainingMilesToDestination() {
    ensureHexMapState();
    const hm = gameState.hexMap;
    if (!hm.destination || !hm.destination.destKey) return null;
    const destKey = hm.destination.destKey;
    const destIdx = HEX_WORLD.activePathIndex[destKey];
    const currentIdx = getCurrentActivePathIndex();
    if (destIdx != null && destIdx >= currentIdx) {
      const currentBase = currentIdx * HEX_MILES_PER_STEP;
      const remainder = (gameState.milesTraveled || 0) - currentBase;
      const milesLeft = destIdx * HEX_MILES_PER_STEP - currentBase - remainder;
      return Math.max(0, milesLeft);
    }
    const currentKey = axialKey(getPlayerHexFromMiles().q, getPlayerHexFromMiles().r);
    const curPathIdx = hm.plannedPathKeys.indexOf(currentKey);
    const destPathIdx = hm.plannedPathKeys.indexOf(destKey);
    if (curPathIdx >= 0 && destPathIdx >= curPathIdx) {
      return (destPathIdx - curPathIdx) * HEX_MILES_PER_STEP;
    }
    return null;
  }

  function isDestinationReached() {
    ensureHexMapState();
    const hm = gameState.hexMap;
    if (!hm.destination || !hm.destination.destKey) return false;
    const playerKey = axialKey(getPlayerHexFromMiles().q, getPlayerHexFromMiles().r);
    return playerKey === hm.destination.destKey;
  }

  function clampMilesToDestination(beforeMiles) {
    const remaining = remainingMilesToDestination();
    if (remaining == null) return;
    const delta = gameState.milesTraveled - beforeMiles;
    if (delta > remaining) {
      gameState.milesTraveled = beforeMiles + remaining;
    }
  }

  function describeDestinationLabel() {
    ensureHexMapState();
    const hm = gameState.hexMap;
    if (!hm.destination || !hm.destination.destKey) return "No destination";
    const ids = HEX_WORLD.poiByHex[hm.destination.destKey] || [];
    if (ids.length) {
      const poi = HEX_WORLD.poiById[ids[0]];
      if (poi) return poi.name;
    }
    return "Trail waypoint";
  }

  function handleDestinationArrival() {
    if (!isDestinationReached()) return false;
    const label = describeDestinationLabel();
    addLog("You arrive at " + label + ".");
    clearTravelDestination();
    return true;
  }

  function updateRegionAndLocation() {
    if (!HEX_WORLD.activePath.length) rebuildActiveRoutePath();
    const playerHex = getPlayerHexFromMiles();
    const miles = axialToMilesXY(playerHex.q, playerHex.r);
    const latlon = milesXYToLatLon(miles.xMi, miles.yMi);
    const regionBiome = hexBiomeForLatLon(latlon.lat, latlon.lon);
    gameState.region = regionBiome.region;
    const nearby = getNearestPOIToPlayerHex(1);
    if (nearby) {
      gameState.locationName = nearby.name;
    } else {
      gameState.locationName = "On the trail — " + regionBiome.biome.replace(/_/g, " ");
    }
    const mods = getHexWorldModifiers(playerHex);
    handleHexModifierTransitions(mods);
    markSeenAroundPlayer(2);
  }

  function handleHexModifierTransitions(mods) {
    ensureHexMapState();
    const hm = gameState.hexMap;
    const prev = hm.lastHexModifiers || {};
    if (mods.inSubletteDesert && !prev.inSubletteDesert) {
      addLog("You enter the dry Sublette cut-off. Water and forage grow scarce.");
    } else if (!mods.inSubletteDesert && prev.inSubletteDesert) {
      addLog("You leave the worst of the desert behind and find slightly better ground.");
    }

    if (mods.inApplegateDesert && !prev.inApplegateDesert) {
      addLog(
        "You roll into the Black Rock / High Rock waterless stretch—alkali flats and scant graze ahead."
      );
    } else if (!mods.inApplegateDesert && prev.inApplegateDesert) {
      addLog("You emerge from the worst of the Applegate desert corridor and find a hint more graze.");
    }

    if (mods.nearSnakeRiver && !prev.nearSnakeRiver) {
      addLog("The Snake River winds nearby—water and bottomland brush are within reach.");
    }
    if (mods.nearColumbiaRiver && !prev.nearColumbiaRiver) {
      addLog("You travel close to the Columbia; the air smells of damp river wind.");
    }
    if (mods.nearHumboldtRiver && !prev.nearHumboldtRiver) {
      addLog("Wagon ruts bunch toward the Humboldt River corridor, a slim lifeline through the basin.");
    }

    if (mods.atBigSandy && !prev.atBigSandy) {
      addLog("Dry ground near Big Sandy tests the team; keep an eye on water stores.");
    }
    hm.lastHexModifiers = Object.assign({}, mods);
  }

  function getHexColorForBiome(biome) {
    switch (biome) {
      case "prairie":
        return "#4f5b3c";
      case "river_bottom":
        return "#3f4c39";
      case "steppe":
        return "#6b5f3e";
      case "desert_sage":
        return "#6c5b47";
      case "alpine":
        return "#4a585c";
      case "conifer_forest":
        return "#2f3c32";
      case "river_gorge":
        return "#2a3c4a";
      case "valley":
        return "#42533a";
      case "great_basin_desert":
        return "#7a6a4f";
      case "alkali_flat":
        return "#8a7b63";
      default:
        return "#444";
    }
  }

  function renderHexScene(canvas, options) {
    if (!canvas) return;
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, rect.width, rect.height);
    if (!HEX_WORLD.activePath.length) rebuildActiveRoutePath();
    ensureHexMapState();
    const playerHex = getPlayerHexFromMiles();
    if (
      !(options && options.lockCamera) &&
      (gameState.hexMap.follow || gameState.hexMap.camQ == null)
    ) {
      recenterCameraOnPlayer();
    }
    const metrics = getHexMapMetrics(rect);
    const viewRange = 16;
    const hm = gameState.hexMap;
    const fog = !!hm.fogEnabled;
    const silhouettes = !!hm.silhouettesEnabled;
    if (fog && Object.keys(hm.seen || {}).length === 0) markSeenAroundPlayer(2);
    const posByKey = {};

    for (let dq = -viewRange; dq <= viewRange; dq++) {
      for (let dr = -viewRange; dr <= viewRange; dr++) {
        const hq = metrics.cam.camQ + dq;
        const hr = metrics.cam.camR + dr;
        const miles = axialToMilesXY(hq, hr);
        const px = rect.width / 2 + (miles.xMi - metrics.milesCenter.xMi) * metrics.pxPerMi;
        const py = rect.height / 2 + (miles.yMi - metrics.milesCenter.yMi) * metrics.pxPerMi;
        if (px < -metrics.radiusPx * 2 || py < -metrics.radiusPx * 2 || px > rect.width + metrics.radiusPx * 2 || py > rect.height + metrics.radiusPx * 2) {
          continue;
        }
        const latlon = milesXYToLatLon(miles.xMi, miles.yMi);
        const regionBiome = hexBiomeForLatLon(latlon.lat, latlon.lon);
        let color = getHexColorForBiome(regionBiome.biome);
        const key = axialKey(hq, hr);
        const seen = hm.seen[key];
        if (fog && !seen) {
          color = shadeColor(color, -0.32);
        }
        ctx.fillStyle = color;
        drawHex(ctx, px, py, metrics.radiusPx - 0.6);
        ctx.fill();
        const mods = getHexWorldModifiers({ q: hq, r: hr });
        const allowOverlay = !fog || seen || silhouettes;
        if (allowOverlay) {
          if (mods.nearSnakeRiver) {
            ctx.fillStyle = fog && !seen ? "rgba(80,120,160,0.18)" : "rgba(90,150,210,0.28)";
            drawHex(ctx, px, py, metrics.radiusPx - 1.2);
            ctx.fill();
          }
          if (mods.nearColumbiaRiver) {
            ctx.fillStyle = fog && !seen ? "rgba(70,120,180,0.18)" : "rgba(70,140,210,0.26)";
            drawHex(ctx, px, py, metrics.radiusPx - 1.2);
            ctx.fill();
          }
          if (mods.nearHumboldtRiver) {
            ctx.fillStyle = fog && !seen ? "rgba(90,150,150,0.16)" : "rgba(100,170,175,0.26)";
            drawHex(ctx, px, py, metrics.radiusPx - 1.2);
            ctx.fill();
          }
          if (mods.inSubletteDesert) {
            ctx.fillStyle = fog && !seen ? "rgba(180,150,90,0.16)" : "rgba(210,170,100,0.24)";
            drawHex(ctx, px, py, metrics.radiusPx - 1.2);
            ctx.fill();
          }
          if (mods.atBigSandy) {
            ctx.fillStyle = fog && !seen ? "rgba(190,150,110,0.16)" : "rgba(220,180,120,0.25)";
            drawHex(ctx, px, py, metrics.radiusPx - 1.2);
            ctx.fill();
          }
          if (mods.inApplegateDesert) {
            ctx.fillStyle = fog && !seen ? "rgba(200,170,130,0.16)" : "rgba(230,190,140,0.26)";
            drawHex(ctx, px, py, metrics.radiusPx - 1.2);
            ctx.fill();
          }
        }
        posByKey[key] = { px: px, py: py, seen: seen };

        const poiHere = HEX_WORLD.poiByHex[key];
        const drawTrail = !fog || seen || silhouettes;
        if (HEX_WORLD.trailHex.has(key) && drawTrail) {
          ctx.strokeStyle = fog && !seen ? "rgba(245,210,139,0.25)" : "rgba(245,210,139,0.9)";
          ctx.lineWidth = 1.4;
          drawHex(ctx, px, py, metrics.radiusPx * 0.7);
          ctx.stroke();
        }
        if (poiHere && poiHere.length && drawTrail) {
          ctx.fillStyle = fog && !seen ? "rgba(243,209,156,0.45)" : "#f3d19c";
          ctx.beginPath();
          ctx.arc(px, py, Math.max(3, metrics.radiusPx * 0.18), 0, Math.PI * 2);
          ctx.fill();
          if (!fog || seen) {
            const name = HEX_WORLD.poiById[poiHere[0]].name;
            ctx.fillStyle = "#e7e0d2";
            ctx.font = "10px 'Inter', system-ui";
            ctx.fillText(name, px + 8, py - 6);
          }
        }

        if (allowOverlay && HEX_HOVER_KEY === key) {
          ctx.strokeStyle = "rgba(255,255,255,0.8)";
          ctx.lineWidth = 2;
          drawHex(ctx, px, py, metrics.radiusPx - 0.8);
          ctx.stroke();
        }
      }
    }

    if (hm.plannedPathKeys && hm.plannedPathKeys.length) {
      ctx.strokeStyle = "rgba(149, 204, 255, 0.7)";
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      hm.plannedPathKeys.forEach(function (key, idx) {
        const pos = posByKey[key];
        if (!pos) return;
        if (idx === 0) ctx.beginPath();
        if (idx === 0) ctx.moveTo(pos.px, pos.py);
        else ctx.lineTo(pos.px, pos.py);
      });
      ctx.stroke();
      ctx.setLineDash([]);
    }

    if (hm.destination && hm.destination.destKey) {
      const destPos = posByKey[hm.destination.destKey];
      if (destPos) {
        ctx.strokeStyle = "rgba(255, 215, 120, 0.9)";
        ctx.lineWidth = 2.4;
        ctx.beginPath();
        ctx.arc(destPos.px, destPos.py, Math.max(6, metrics.radiusPx * 0.55), 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    const wagon = axialToMilesXY(playerHex.q, playerHex.r);
    const wagonPx = rect.width / 2 + (wagon.xMi - metrics.milesCenter.xMi) * metrics.pxPerMi;
    const wagonPy = rect.height / 2 + (wagon.yMi - metrics.milesCenter.yMi) * metrics.pxPerMi;
    ctx.fillStyle = "#f4e3c2";
    ctx.strokeStyle = "#3a2b1d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(wagonPx, wagonPy, Math.max(4, metrics.radiusPx * 0.25), 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    if (options && options.showHint) {
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(8, rect.height - 26, 240, 20);
      ctx.fillStyle = "#e7e0d2";
      ctx.font = "11px 'Inter', system-ui";
      ctx.fillText(
        "Click to set target, click again to travel (12h) · Arrows pan · F follow",
        14,
        rect.height - 12
      );
    }
  }

  function renderExplorer() {
    renderHexScene(dom.trailCanvas, { showHint: true });
  }

  function buildTooltipHtmlForHex(hex, options) {
    const key = axialKey(hex.q, hex.r);
    const ids = HEX_WORLD.poiByHex[key] || [];
    const miles = axialToMilesXY(hex.q, hex.r);
    const latlon = milesXYToLatLon(miles.xMi, miles.yMi);
    const biome = hexBiomeForLatLon(latlon.lat, latlon.lon);
    const mods = getHexWorldModifiers(hex);
    const profile = getLocalResourceProfile(hex);
    const tags = profile.tags ? profile.tags.slice() : [];
    if (mods.nearSnakeRiver && tags.indexOf("Snake corridor") === -1) tags.push("Snake corridor");
    if (mods.nearColumbiaRiver && tags.indexOf("Columbia corridor") === -1)
      tags.push("Columbia corridor");
    if (mods.inSubletteDesert && tags.indexOf("Sublette desert stretch") === -1)
      tags.push("Sublette desert stretch");
    if (mods.atBigSandy && tags.indexOf("Big Sandy basin") === -1)
      tags.push("Big Sandy basin");
    const idx = HEX_WORLD.activePathIndex[key];
    const mileLabel = idx != null ? "Mile " + Math.round(idx * HEX_MILES_PER_STEP) : "";
    const unseen = options && options.unseen;

    let title = HEX_WORLD.trailHex.has(key) ? "Trail waypoint" : "Off-trail ground";
    let subtitle = biome.biome.replace(/_/g, " ");
    if (ids.length) {
      const poi = HEX_WORLD.poiById[ids[0]];
      title = unseen ? "Unseen landmark" : poi.name;
      subtitle = unseen ? "hidden details" : poi.type || "waypoint";
    }

    const resources = [
      { id: "water", label: "Water", val: profile.water },
      { id: "wood", label: "Wood", val: profile.wood },
      { id: "forage", label: "Forage", val: profile.forage },
      { id: "game", label: "Game", val: profile.game },
    ]
      .map(function (r) {
        const pct = Math.round((r.val || 0) * 100);
        return `<div style="font-size:10px; color:#d4c9b0;">${r.label}: ${pct}%</div>`;
      })
      .join("");

    const parts = [
      `<div style="font-weight:600;">${title}</div>`,
      `<div style="font-size:11px; color:#c7c4bc;">${subtitle}</div>`,
      `<div style="font-size:11px; margin-top:4px;">Biome: ${biome.biome.replace(/_/g, " ")}</div>`,
    ];
    if (tags.length) {
      parts.push(`<div style="font-size:11px; color:#d4c9b0;">${tags.join(" · ")}</div>`);
    }
    if (mileLabel && HEX_WORLD.trailHex.has(key))
      parts.push(`<div style="font-size:10px; color:#b7b3ab;">${mileLabel}</div>`);
    parts.push(`<div style="font-size:11px; margin-top:4px;">Local resources</div>`);
    parts.push(resources);
    if (profile.waterQualityHint) {
      parts.push(
        `<div style="font-size:10px; color:#9ec5ff;">Water: ${profile.waterQualityHint.replace(/_/g, " ")}</div>`
      );
    }
    if (unseen) {
      parts.push(`<div style="font-size:10px; color:#9c8f7a;">Unseen (fog)</div>`);
    }
    return parts.join("");
  }

  function wireHexCanvasInteractions(canvas, options) {
    if (!canvas || canvas.dataset.wired) return;
    canvas.dataset.wired = "1";
    const tooltip = options && options.tooltip;
    canvas.addEventListener("click", function (evt) {
      if (!HEX_WORLD.trailHex.size) rebuildActiveRoutePath();
      const hex = pixelToAxialOnCanvas(canvas, evt.clientX, evt.clientY);
      const key = axialKey(hex.q, hex.r);
      ensureHexMapState();
      if (!HEX_WORLD.trailHex.has(key)) {
        addLog("That point is off the mapped trail. Stick to the highlighted corridor.");
        return;
      }
      const hm = gameState.hexMap;
      const now = Date.now();
      const sameDest = hm.destination && hm.destination.destKey === key;
      const quickRepeat = LAST_HEX_CLICK.key === key && now - LAST_HEX_CLICK.ts < 700;
      const setOk = setTravelDestination(hex);
      LAST_HEX_CLICK.key = key;
      LAST_HEX_CLICK.ts = now;
      if (setOk && (sameDest || quickRepeat)) {
        withAdvanceLock(function () {
          return beginAutoTravelToDestination();
        });
      }
    });
    if (tooltip) {
      canvas.addEventListener("mousemove", function (evt) {
        ensureHexMapState();
        const hex = pixelToAxialOnCanvas(canvas, evt.clientX, evt.clientY);
        const key = axialKey(hex.q, hex.r);
        const hm = gameState.hexMap;
        HEX_HOVER_KEY = key;
        if (hm.fogEnabled && !hm.silhouettesEnabled && !hm.seen[key]) {
          tooltip.style.display = "none";
          HEX_HOVER_KEY = null;
          return;
        }
        const html = buildTooltipHtmlForHex(hex, {
          unseen: hm.fogEnabled && !hm.seen[key] && hm.silhouettesEnabled,
        });
        if (!html) {
          tooltip.style.display = "none";
          return;
        }
        tooltip.innerHTML = html;
        const rect = dom.mapViewport ? dom.mapViewport.getBoundingClientRect() : canvas.getBoundingClientRect();
        tooltip.style.left = evt.clientX - rect.left + "px";
        tooltip.style.top = evt.clientY - rect.top - 8 + "px";
        tooltip.style.display = "block";
        renderHexScene(canvas, { showHint: options && options.showHint, lockCamera: true });
      });
      canvas.addEventListener("mouseleave", function () {
        tooltip.style.display = "none";
        HEX_HOVER_KEY = null;
        renderHexScene(canvas, { showHint: options && options.showHint, lockCamera: true });
      });
    }
  }

  function renderTrailMap() {
    if (dom.mapViewport) {
      if (!dom.mapCanvas) {
        const canvas = document.createElement("canvas");
        canvas.className = "ot-map-canvas";
        dom.mapCanvas = canvas;
        dom.mapViewport.appendChild(canvas);
        if (dom.mapTooltip) dom.mapViewport.appendChild(dom.mapTooltip);
        wireHexCanvasInteractions(canvas, { tooltip: dom.mapTooltip });
      }
      renderHexScene(dom.mapCanvas, { showHint: false });
    }

    dom.trailMap.innerHTML = "";
    const miles = gameState.milesTraveled;
    const seenMile = (gameState.traillines && gameState.traillines.fogMaxMile) || 0;
    const mapSub = document.getElementById("ot-map-sub");
    if (mapSub) {
      mapSub.textContent =
        "Miles traveled: " + Math.round(miles) + " / " + Math.round(gameState.targetMiles || 0);
    }

    renderTravelTargetUI();

    renderMilestoneList(dom.trailMap, miles, seenMile);

    updateMapListVisibility();
  }

  function renderTravelTargetUI() {
    ensureHexMapState();
    if (dom.toggleFog) dom.toggleFog.checked = !!gameState.hexMap.fogEnabled;
    if (dom.toggleSilhouettes)
      dom.toggleSilhouettes.checked = !!gameState.hexMap.silhouettesEnabled;
    if (dom.targetMeta) {
      if (gameState.hexMap.destination && gameState.hexMap.destination.destKey) {
        const label = describeDestinationLabel();
        const remaining = remainingMilesToDestination();
        const milesLeft = remaining != null ? remaining : gameState.hexMap.plannedDistanceMiles || 0;
        const etaHours = milesLeft / Math.max(0.25, estimateMilesPerHour());
        dom.targetMeta.textContent =
          label +
          " — " +
          milesLeft.toFixed(1) +
          " mi · ETA ~" +
          etaHours.toFixed(1) +
          " h";
      } else {
        dom.targetMeta.textContent = "No destination selected";
      }
    }
    renderLocalConditionsReadout();
  }

  function renderLocalConditionsReadout(hexOverride) {
    if (!dom.localConditions) return;
    const profile = getLocalResourceProfile(hexOverride);
    const labels = [
      { key: "water", label: "Water" },
      { key: "wood", label: "Wood" },
      { key: "forage", label: "Forage" },
      { key: "game", label: "Game" },
    ];
    const html = labels
      .map(function (l) {
        const pct = Math.round((profile[l.key] || 0) * 100);
        return `<div class="label">${l.label}</div><div>${pct}%</div>`;
      })
      .join("");
    const tags = profile.tags && profile.tags.length ? profile.tags.join(" · ") : "";
    dom.localConditions.innerHTML =
      html +
      (tags
        ? `<div class="label">Hazards</div><div>${tags}</div>`
        : `<div class="label">Water</div><div>${profile.waterQualityHint || "mixed"}</div>`);
  }

  function getExplorerTile(x, y) {
    return "void";
  }

  function tickExplorerTimeForStep() {}

  function renderCompanionDetail() {
    dom.companionDetail.innerHTML = "";
    const people = [gameState.leader].concat(gameState.companions);
    const person = people[gameState.selectedIndex] || people[0];
    if (!person) return;

    const name = document.createElement("div");
    name.style.fontSize = "13px";
    name.style.marginBottom = "2px";
    name.textContent = person.name;
    dom.companionDetail.appendChild(name);

    const role = document.createElement("div");
    role.className = "ot-panel-body-sm ot-text-muted";
    role.style.marginBottom = "6px";
    role.textContent = person.isLeader ? "Leader" : "Companion";
    dom.companionDetail.appendChild(role);

    renderBars(dom.companionDetail, person);

    const skills = person.skills || {};
    const skillsLine = document.createElement("div");
    skillsLine.className = "ot-panel-body-sm ot-text-muted";
    skillsLine.style.marginTop = "6px";
    skillsLine.textContent =
      "Travel: " +
      (skills.travel || 0) +
      " · Hunting: " +
      (skills.hunting || 0) +
      " · Cooking: " +
      (skills.cooking || 0) +
      " · Woodcutting: " +
      (skills.woodcutting || 0) +
      " · Doctoring: " +
      (skills.doctoring || 0);
    dom.companionDetail.appendChild(skillsLine);

    const bio = document.createElement("div");
    bio.className = "ot-panel-body-sm";
    bio.style.marginTop = "6px";
    bio.textContent = `${person.age || "?"} years · ${person.origin || "Unknown origin"}`;
    dom.companionDetail.appendChild(bio);

    const backstory = document.createElement("div");
    backstory.className = "ot-panel-body-sm ot-text-muted";
    backstory.textContent = person.backstoryLabel
      ? `${person.backstoryLabel} — ${person.backstorySummary || ""}`
      : "";
    dom.companionDetail.appendChild(backstory);

    const traitsRow = document.createElement("div");
    traitsRow.className = "ot-panel-body-sm";
    traitsRow.style.marginTop = "4px";
    traitsRow.innerHTML = (person.traits || [])
      .map(function (t) {
        const def = getTraitDef(t);
        return `<span class="ot-draft-tag">${def ? def.label : t}</span>`;
      })
      .join(" ") || "No quirks noted.";
    dom.companionDetail.appendChild(traitsRow);

    if (
      person.hiddenTraits &&
      person.hiddenTraits.length &&
      (!person.secret || person.secret.revealed.length < person.hiddenTraits.length)
    ) {
      const hint = document.createElement("div");
      hint.className = "ot-panel-body-sm ot-text-muted";
      const suspicion = (person.secret && person.secret.suspicion) || 0;
      hint.textContent = suspicion >= 35 ? "Secret suspected" : "Keeps a few things close";
      dom.companionDetail.appendChild(hint);
    }

    const affs = activeAfflictions(person);
    if (affs.length) {
      const affDiv = document.createElement("div");
      affDiv.className = "ot-panel-body-sm ot-text-warning";
      affDiv.style.marginTop = "4px";
      affDiv.textContent = affs
        .map(function (a) {
          const sev = afflictionSeverityLabel(a.severity || 1);
          return a.label + " (" + a.stage + ", " + sev + ")";
        })
        .join(" · ");
      dom.companionDetail.appendChild(affDiv);
    }

    const relWrap = document.createElement("div");
    relWrap.className = "ot-panel-body-sm";
    relWrap.style.marginTop = "6px";
    relWrap.innerHTML = "<strong>Social</strong>";
    const relList = document.createElement("div");
    Object.keys(person.relationships || {}).forEach(function (rid) {
      const rel = person.relationships[rid];
      const other = getAllPeople().find(function (p) {
        return p && p.id === rid;
      });
      if (!other) return;
      const line = document.createElement("div");
      line.className = "ot-panel-body-sm ot-text-muted";
      line.textContent = `${other.name}: ${relationshipLabel(rel)} (${Math.round(rel.opinion || 0)})`;
      relList.appendChild(line);
    });
    relWrap.appendChild(relList);
    dom.companionDetail.appendChild(relWrap);
  }

  function renderTrailLog() {
    if (!window.ksOldTrailLog || !ksOldTrailLog.clear) return;
    ksOldTrailLog.clear();
    (gameState.log || []).slice(-6).forEach(function (entry) {
      if (!entry) return;
      ksOldTrailLog.add(entry.text, {
        tag:
          entry.tag ||
          ("DAY " +
            (gameState.startDayOfYear != null
              ? Math.max(
                  1,
                  getDayOfYear(entry.date) - gameState.startDayOfYear + 1
                )
              : getDayOfYear(entry.date))),
        location: entry.location || gameState.locationName || "On the trail",
        tone: entry.tone,
        characters: entry.characters,
      });
    });
  }

  function renderSuppliesOverview() {
    const s = gameState.supplies;
    const rawFoodLbs =
      (s.flour || 0) +
      (s.bacon || 0) +
      (s.beans_rice || 0) +
      (s.hardtack || 0) +
      (s.dried_fruit || 0) +
      (s.fresh_meat || 0);
    const cookedMeals =
      (s.meal_simple || 0) +
      (s.meal_hearty || 0) +
      (s.meal_feast || 0) +
      (s.cooked_meals || 0);
    const ammo     = s.ammo || 0;
    const fireFuel = (s.firewood || 0) + (s.buffalo_chips || 0);
    const waterGal = s.water || 0;
    const med      = s.med_kits || 0;

    function blendFreshness(ids) {
      const summary = { total: 0, turning: 0, spoiled: 0 };
      ids.forEach(function (id) {
        const s = summarizeFreshness(id);
        summary.total += s.total;
        summary.turning += s.turning;
        summary.spoiled += s.spoiled;
      });
      if (summary.total <= 0) return null;
      const turningShare = summary.turning / summary.total;
      const spoiledShare = summary.spoiled / summary.total;
      if (spoiledShare > 0.4) return "mostly spoiled";
      if (spoiledShare > 0.1) return "some spoiled";
      if (turningShare > 0.3) return "turning soon";
      if (turningShare > 0.12) return "watch the pots";
      return "fresh";
    }

    const cookedFresh = blendFreshness(["meal_simple", "meal_hearty", "meal_feast"]);
    const meatFresh = blendFreshness(["fresh_meat"]);

    const simple = Math.round(s.meal_simple || 0);
    const hearty = Math.round(s.meal_hearty || 0);
    const feast  = Math.round(s.meal_feast  || 0);

    let html = '<div class="ot-supplies-grid">';

    html +=
      '<div class="ot-supplies-label">Food (raw staples)</div><div class="ot-supplies-value">' +
      Math.round(rawFoodLbs) +
      " lb</div>";

    html +=
      '<div class="ot-supplies-label">Cooked meals available</div><div class="ot-supplies-value">' +
      Math.round(cookedMeals) +
      " servings" +
      (cookedFresh && cookedMeals > 0 ? " · " + cookedFresh : "") +
      "</div>";

    html +=
      '<div class="ot-supplies-label"></div><div class="ot-supplies-value">' +
      (simple || hearty || feast
        ? simple +
          " simple, " +
          hearty +
          " hearty, " +
          feast +
          " feast"
        : "") +
      "</div>";

    if ((s.fresh_meat || 0) > 0) {
      html +=
        '<div class="ot-supplies-label">Fresh meat on hand</div><div class="ot-supplies-value">' +
        Math.round(s.fresh_meat || 0) +
        " lb" +
        (meatFresh ? " · " + meatFresh : "") +
        "</div>";
    }

    html +=
      '<div class="ot-supplies-label">Water on hand</div><div class="ot-supplies-value">' +
      waterGal.toFixed(1) +
      " gal</div>";

    html +=
      '<div class="ot-supplies-label">Animals</div><div class="ot-supplies-value">' +
      (s.oxen || 0) +
      " oxen, " +
      (s.milk_cows || 0) +
      " milk cows</div>";

    html +=
      '<div class="ot-supplies-label">Ammunition</div><div class="ot-supplies-value">' +
      ammo +
      " boxes</div>";

    html +=
      '<div class="ot-supplies-label">Fuel for camp</div><div class="ot-supplies-value">' +
      fireFuel.toFixed(1) +
      " bundles / sacks</div>";

    html +=
      '<div class="ot-supplies-label">Medical supplies</div><div class="ot-supplies-value">' +
      med +
      " kits</div>";

    const ns = gameState.nutritionStatus;
    if (ns) {
      const dietBits = [];

      if (ns.avgFruit < 0.3) {
        dietBits.push("very little fresh food");
      } else if (ns.avgFruit < 0.6) {
        dietBits.push("some fresh food");
      } else {
        dietBits.push("plenty of greens & fruit");
      }

      if (ns.avgMeat < 0.35) {
        dietBits.push("low meat/fat");
      } else {
        dietBits.push("good meat & fat");
      }

      if (ns.avgCoffee < 0.25) {
        dietBits.push("little coffee/tea");
      } else {
        dietBits.push("regular coffee/tea");
      }

      html +=
        '<div class="ot-supplies-label">Diet (last 2 weeks)</div><div class="ot-supplies-value">' +
        dietBits.join(" · ") +
        "</div>";
    }

    html += "</div>";
    dom.suppliesOverview.innerHTML = html;
  }

  function renderTradingPostAccess() {
    if (!dom.btnOpenTrade) return;
    const fort = getNearbyFortPOI();
    const show = gameState.phase === "travel" && !!fort;
    dom.btnOpenTrade.style.display = show ? "inline-flex" : "none";
    if (show) {
      const tradeUi = ensureTradeUiState();
      if (tradeUi.vendorKey === "forts") tradeUi.poiId = fort.id;
    }
  }


  function renderFooter() {
    const miles = gameState.milesTraveled;
    const total = gameState.targetMiles;
    const flour = gameState.supplies.flour || 0;
    const morale =
      (gameState.leader ? gameState.leader.morale : 0) +
      gameState.companions.reduce(function (sum, p) {
        return sum + p.morale;
      }, 0);
    const partyCount = mouthsCount();
    const avgMorale = partyCount > 0 ? Math.round(morale / partyCount) : 0;

    dom.footerStatus.textContent =
      formatDateTime(gameState.date) +
      " · " +
      gameState.locationName +
      " · Weather: " +
      gameState.weather +
      " · Miles: " +
      Math.round(miles) +
      " / " +
      total +
      " · Flour: " +
      Math.round(flour) +
      " lb · Morale: " +
      avgMorale +
      "%";
    refreshCampfireButton();
  }

  function renderInventoryModal() {
    const people = [gameState.leader].concat(gameState.companions);
    const person = people[gameState.selectedIndex] || people[0];
    if (!person) return;
    dom.inventorySub.textContent =
      "Feeding: " +
      person.name +
      ". Click to have them eat or drink from wagon stores.";

    const foods = [
      "meal_feast",
      "meal_hearty",
      "meal_simple",
      "cooked_meals",
      "fresh_meat",
      "bacon",
      "flour",
      "beans_rice",
      "hardtack",
      "dried_fruit",
    ];

    dom.inventoryBody.innerHTML = "";

    foods.forEach(function (id) {
      const cfg = FOOD_VALUES[id];
      const item = SUPPLY_ITEMS.find(function (s) {
        return s.id === id;
      });
      if (!item || !cfg) return;
      const tr = document.createElement("tr");
      const tdName = document.createElement("td");
      tdName.textContent = item.name;
      tr.appendChild(tdName);

      const tdQty = document.createElement("td");
      const qty = gameState.supplies[id] || 0;
      const hint = freshnessHintForSupply(id);
      if (item.category === "FOOD_PREPARED") {
        tdQty.textContent = Math.round(qty) + " meals" + (hint ? " · " + hint : "");
      } else {
        tdQty.textContent = Math.round(qty) + " " + item.unit + (hint && id === "fresh_meat" ? " · " + hint : "");
      }
      tr.appendChild(tdQty);

      const tdUse = document.createElement("td");
      const btn = document.createElement("button");
      btn.className = "ot-inv-btn";
      btn.textContent =
        id === "meal_feast"
          ? "Eat feast"
          : id === "meal_hearty"
          ? "Eat hearty meal"
          : id === "meal_simple" || id === "cooked_meals"
          ? "Eat a meal"
          : "Eat some";
      btn.addEventListener("click", async function () {
        const ok = useFood(id, person);
        if (ok) {
          renderAll();
        } else {
          await presentEncounter({
            id: "food_shortage_notice",
            title: "Stores are bare",
            body: [
              "There isn't enough " + item.name.toLowerCase() + " left to share.",
            ],
            options: [{ id: "close", label: "Close" }],
            defaultId: "close",
          });
        }
      });
      tdUse.appendChild(btn);
      tr.appendChild(tdUse);

      dom.inventoryBody.appendChild(tr);
    });

    const trW = document.createElement("tr");
    const tdWName = document.createElement("td");
    tdWName.textContent = "Water";
    trW.appendChild(tdWName);
    const tdWQty = document.createElement("td");
    tdWQty.textContent = (gameState.supplies.water || 0).toFixed(1) + " gal";
    trW.appendChild(tdWQty);
    const tdWUse = document.createElement("td");
    const wBtn = document.createElement("button");
    wBtn.className = "ot-inv-btn";
    wBtn.textContent = "Drink";
    wBtn.addEventListener("click", async function () {
      if (gameState.supplies.water <= 0) {
        await presentEncounter({
          id: "water_empty_notice",
          title: "The keg is dry",
          body: ["No drinkable water remains right now."],
          options: [{ id: "close", label: "Close" }],
          defaultId: "close",
        });
        return;
      }
      drinkUntil(person, 90);
      renderAll();
    });
    tdWUse.appendChild(wBtn);
    trW.appendChild(tdWUse);
    dom.inventoryBody.appendChild(trW);

    if (gameState.mythicEnabled) {
      const curioState = ensureMythicCurioState();
      const head = document.createElement("tr");
      const headCell = document.createElement("td");
      headCell.colSpan = 3;
      headCell.textContent = "Mythic curios";
      headCell.className = "ot-text-muted";
      head.appendChild(headCell);
      dom.inventoryBody.appendChild(head);

      curioState.slots.forEach(function (cid, idx) {
        const row = document.createElement("tr");
        const cName = document.createElement("td");
        cName.textContent = "Slot " + (idx + 1);
        row.appendChild(cName);
        const cVal = document.createElement("td");
        const def = cid ? getCurioDef(cid) : null;
        cVal.textContent = def ? def.name + " — " + (def.shortDesc || "") : "Empty";
        row.appendChild(cVal);
        const cBtn = document.createElement("td");
        if (cid) {
          const btn = document.createElement("button");
          btn.className = "ot-inv-btn";
          btn.textContent = "Stow";
          btn.addEventListener("click", function () {
            unequipMythicCurio(idx);
            renderInventoryModal();
          });
          cBtn.appendChild(btn);
        }
        row.appendChild(cBtn);
        dom.inventoryBody.appendChild(row);
      });

      const ownedRow = document.createElement("tr");
      const ownedLabel = document.createElement("td");
      ownedLabel.textContent = "Owned";
      ownedRow.appendChild(ownedLabel);
      const ownedList = document.createElement("td");
      ownedList.colSpan = 2;
      if (!curioState.owned.length) {
        ownedList.textContent = "No curios found.";
      } else {
        ownedList.innerHTML = curioState.owned
          .map(function (cid) {
            const def = getCurioDef(cid);
            const slotted = curioState.slots.indexOf(cid) >= 0;
            const btn = slotted
              ? ""
              : `<button class="ot-inv-btn" data-equip="${cid}">Equip</button>`;
            return `<div>${def ? def.name : cid} ${btn}</div>`;
          })
          .join("");
      }
      ownedRow.appendChild(ownedList);
      dom.inventoryBody.appendChild(ownedRow);

      Array.from(dom.inventoryBody.querySelectorAll("[data-equip]")).forEach(function (btn) {
        btn.addEventListener("click", function () {
          const id = btn.getAttribute("data-equip");
          const openSlot = curioState.slots.indexOf(null) >= 0 ? curioState.slots.indexOf(null) : 0;
          equipMythicCurio(id, openSlot);
          renderInventoryModal();
        });
      });
    }
  }

  function ensureTradeUiState() {
    if (!gameState.ui) gameState.ui = {};
    if (!gameState.ui.trade)
      gameState.ui.trade = {
        open: false,
        tab: "buy",
        vendorKey: "forts",
        poiId: null,
      };
    if (!gameState.ui.trade.tab) gameState.ui.trade.tab = "buy";
    if (!gameState.ui.trade.vendorKey) gameState.ui.trade.vendorKey = "forts";
    if (!gameState.ui.trade.barter)
      gameState.ui.trade.barter = { offer: {}, ask: {} };
    if (!gameState.ui.trade.barter.offer) gameState.ui.trade.barter.offer = {};
    if (!gameState.ui.trade.barter.ask) gameState.ui.trade.barter.ask = {};
    return gameState.ui.trade;
  }

  function resolveTradeContext() {
    const tradeUi = ensureTradeUiState();
    let fort = null;
    if (tradeUi.vendorKey === "forts") {
      if (tradeUi.poiId) {
        fort = OT_POIS.find(function (p) {
          return p && p.id === tradeUi.poiId;
        });
      }
      if (!fort) fort = getNearbyFortPOI();
      if (fort && tradeUi.poiId !== fort.id) {
        tradeUi.poiId = fort.id;
      }
    }
    const poiId =
      tradeUi.vendorKey === "forts"
        ? (fort && fort.id) || tradeUi.poiId || "frontier"
        : tradeUi.poiId || "frontier";
    const tradeDef = getFortTradeDef(poiId);
    const vendorState = restockVendorForPoi(poiId, tradeDef);
    return { tradeUi: tradeUi, fort: fort, poiId: poiId, tradeDef: tradeDef, vendorState: vendorState };
  }

  function computeTradePricing(item, tradeDef, vendorState, terms) {
    const baseStockVal = (tradeDef.baseStock && tradeDef.baseStock[item.id]) || 0;
    const vendorStock = (vendorState.stocks && vendorState.stocks[item.id]) || 0;
    const scarcity01 = 1 - clamp(vendorStock / Math.max(1, baseStockVal || 1), 0, 1);
    const scarcityBuyMult = clamp(1 + 0.35 * scarcity01, 1, 1.35);
    const demand01 = clamp((baseStockVal - vendorStock) / Math.max(1, baseStockVal || 1), 0, 1);
    const demandSellMult = clamp(1 + 0.2 * demand01, 0.85, 1.2);
    const policy = getFortPolicyForTradeDef(tradeDef);
    const buyTariffPct = policy && isFinite(policy.buyTariffPct) ? policy.buyTariffPct : 0;
    const sellTariffPct = policy && isFinite(policy.sellTariffPct) ? policy.sellTariffPct : 0;
    const tariffBuyMult = clamp(1 + buyTariffPct, 0, 10);
    const tariffSellMult = clamp(1 - sellTariffPct, 0, 1);
    const unitBuy = roundToCents(item.cost * terms.costMult * scarcityBuyMult * tariffBuyMult);
    let unitSell = roundToCents(item.cost * 0.6 * terms.gainMult * demandSellMult * tariffSellMult);
    if (unitSell < 0) unitSell = 0;
    const maxSell = roundToCents(unitBuy * 0.9);
    if (unitSell > maxSell) unitSell = maxSell;
    const cap = getVendorStockCap(tradeDef, item.id, baseStockVal);
    return {
      unitBuy: unitBuy,
      unitSell: unitSell,
      scarcityBuyMult: scarcityBuyMult,
      demandSellMult: demandSellMult,
      tariffBuyMult: tariffBuyMult,
      tariffSellMult: tariffSellMult,
      vendorStock: vendorStock,
      baseStock: baseStockVal,
      cap: cap,
    };
  }

  function generateLedgerNotes(tradeDef, vendorState) {
    const base = tradeDef.baseStock || {};
    const stock = vendorState.stocks || {};
    const scarcity = function (id, fraction) {
      const b = base[id] || 0;
      if (b <= 0) return false;
      return (stock[id] || 0) < b * fraction;
    };
    const overstock = function (id, fraction) {
      const b = base[id] || 0;
      if (b <= 0) return false;
      return (stock[id] || 0) > b * fraction;
    };
    const notes = [];
    if (scarcity("coffee", 0.35)) notes.push("Coffee's gone dear. Folks pay in silence for a pound.");
    if (scarcity("ammo", 0.5) || scarcity("rifles", 0.5))
      notes.push("Powder is rationed—ask polite, buy light.");
    if (scarcity("wheels", 0.5) || scarcity("axles", 0.5) || scarcity("tongues", 0.5))
      notes.push("Spare iron's thin. Repairs take favors.");
    if (overstock("flour", 1.2)) notes.push("Flour stacks high. The sutler pays less for it.");

    const today = getDaySerial(gameState.date || new Date());
    const staticNotes = tradeDef.flavorNotes || [];
    if (staticNotes.length) {
      const rng = mulberry32(
        hashToInt(String(vendorState.seed || 0) + ":notes:" + today + ":" + (tradeDef.label || "sutler"))
      );
      const picks = staticNotes.slice().sort(function () {
        return rng() - 0.5;
      });
      picks.slice(0, 2).forEach(function (line) {
        if (notes.length < 4) notes.push(line);
      });
    }

    const policy = getFortPolicyForTradeDef(tradeDef);
    if (policy && notes.length < 4) {
      const policyLines = policy.notes || [];
      let policyLine = policy.desc;
      if (policyLines.length) {
        const rng = mulberry32(
          hashToInt(String(vendorState.seed || 0) + ":policy:" + today + ":" + (tradeDef.label || "sutler"))
        );
        policyLine = policyLines.slice().sort(function () {
          return rng() - 0.5;
        })[0];
      }
      if (policyLine) notes.push(policyLine);
    }

    if (policy && Array.isArray(policy.rivals) && policy.rivals.length && notes.length < 4) {
      const ledger = (ensureStoryState().tradeLedger || []).slice().reverse();
      const windowDay = today - 7;
      const recent = ledger.find(function (entry) {
        if (!entry || !entry.vendorPoi) return false;
        if (policy.rivals.indexOf(entry.vendorPoi) < 0) return false;
        const entryDay = getDaySerial(entry.ts || new Date());
        return entryDay >= windowDay;
      });
      if (recent) {
        const rivalDef = getFortTradeDef(recent.vendorPoi);
        const rivalLabel = (rivalDef && rivalDef.label) || "another fort";
        notes.push(`The clerk thumbs the stamp from ${rivalLabel} and raises an eyebrow.`);
      }
    }

    const minNotes = 2;
    while (notes.length < minNotes && notes.length < 4) {
      notes.push("Quiet day in the ledger—no new chatter.");
    }

    return notes.slice(0, 4);
  }

  const MAX_HAGGLE_ATTEMPTS_PER_DAY = 3;

  function getVendorLabelForKey(vendorKey) {
    if (vendorKey === "caravans") return "Passing Caravan";
    if (vendorKey === "open_eye") return "Inked-eye Peddler";
    if (vendorKey === "men_in_gray") return "Quiet Ledger";
    return "Trading Post";
  }

  function getTradeRestriction(itemId, mode, vendorKey, tier) {
    const info = { restricted: false, reason: "", tag: "" };
    const t = tier || getFactionRepTier(vendorKey || "forts");
    if (vendorKey === "caravans" && mode === "buy" && itemId === "rifles") {
      if (!(t.id === "trusted" || t.id === "ally")) {
        info.restricted = true;
        info.tag = "contraband";
        info.reason = "Caravan keeps rifles back until trust is earned.";
      }
    }
    if (vendorKey === "forts" && mode === "buy" && itemId === "rifles" && t.id === "hostile") {
      info.restricted = true;
      info.tag = "restricted";
      info.reason = "Hostile terms—no rifles sold.";
    }
    return info;
  }

  function ensureBarterState() {
    const tradeUi = ensureTradeUiState();
    if (!tradeUi.barter) tradeUi.barter = { offer: {}, ask: {} };
    if (!tradeUi.barter.offer) tradeUi.barter.offer = {};
    if (!tradeUi.barter.ask) tradeUi.barter.ask = {};
    return tradeUi.barter;
  }

  function formatBarterLineItems(basket) {
    const lines = [];
    Object.keys(basket || {}).forEach(function (id) {
      const qty = basket[id];
      if (qty > 0) {
        lines.push({ id: id, qty: qty, def: findSupplyDef(id) });
      }
    });
    return lines;
  }

  function computeBarterTotals(ctx, basketsOverride) {
    const tradeUi = ctx.tradeUi;
    const tradeDef = ctx.tradeDef;
    const vendorState = ctx.vendorState;
    const vendorKey = tradeUi.vendorKey || "forts";
    const termsInfo = getTradeTermsForFaction(vendorKey);
    const terms = termsInfo;
    const tier = termsInfo.tier || getFactionRepTier(vendorKey);
    const barter = basketsOverride || ensureBarterState();
    const offerLines = formatBarterLineItems(barter.offer || {});
    const askLines = formatBarterLineItems(barter.ask || {});
    let offerValue = 0;
    let askValue = 0;
    const problems = [];

    offerLines.forEach(function (line) {
      const def = line.def;
      if (!def) return;
      const pricing = computeTradePricing(def, tradeDef, vendorState, terms);
      offerValue += pricing.unitSell * line.qty;
      const owned = gameState.supplies[def.id] || 0;
      if (line.qty > owned + 1e-6) {
        problems.push(`You only have ${owned} ${def.name}.`);
      }
      if (pricing.vendorStock + line.qty > pricing.cap + 1e-6) {
        problems.push(`Vendor can't take more ${def.name} (cap ${Math.floor(pricing.cap)}).`);
      }
      const restriction = getTradeRestriction(def.id, "sell", vendorKey, tier);
      if (restriction.restricted) {
        problems.push(restriction.reason || `${def.name} can't be offered.`);
      }
    });

    askLines.forEach(function (line) {
      const def = line.def;
      if (!def) return;
      const pricing = computeTradePricing(def, tradeDef, vendorState, terms);
      askValue += pricing.unitBuy * line.qty;
      if (line.qty > pricing.vendorStock + 1e-6) {
        problems.push(`Not enough ${def.name} in stock.`);
      }
      const restriction = getTradeRestriction(def.id, "buy", vendorKey, tier);
      if (restriction.restricted) {
        problems.push(restriction.reason || `${def.name} can't be requested.`);
      }
    });

    return {
      offerValue: offerValue,
      askValue: askValue,
      offerLines: offerLines,
      askLines: askLines,
      problems: problems,
    };
  }

  function adjustBarterQty(side, itemId, delta, maxQty) {
    const barter = ensureBarterState();
    const bucket = side === "ask" ? barter.ask : barter.offer;
    if (!bucket[itemId]) bucket[itemId] = 0;
    bucket[itemId] = bucket[itemId] + delta;
    if (bucket[itemId] < 0) bucket[itemId] = 0;
    if (maxQty != null) bucket[itemId] = Math.min(bucket[itemId], maxQty);
    if (bucket[itemId] <= 0) delete bucket[itemId];
  }

  function getHaggleTracker(vendorKey, poiId) {
    const ss = ensureStoryState();
    const key = (vendorKey || "forts") + ":" + (poiId || "frontier");
    if (!ss.tradeHaggling) ss.tradeHaggling = {};
    const today = getDaySerial(gameState.date || new Date());
    if (!ss.tradeHaggling[key] || ss.tradeHaggling[key].day !== today) {
      ss.tradeHaggling[key] = { day: today, attempts: 0 };
    }
    if (typeof ss.tradeHaggling[key].attempts !== "number") ss.tradeHaggling[key].attempts = 0;
    if (typeof ss.tradeHaggling[key].day !== "number") ss.tradeHaggling[key].day = today;
    return ss.tradeHaggling[key];
  }

  function canHaggleToday(vendorKey, poiId) {
    const tracker = getHaggleTracker(vendorKey, poiId);
    return tracker.attempts < MAX_HAGGLE_ATTEMPTS_PER_DAY;
  }

  function remainingHaggleAttempts(vendorKey, poiId) {
    const tracker = getHaggleTracker(vendorKey, poiId);
    return Math.max(0, MAX_HAGGLE_ATTEMPTS_PER_DAY - (tracker.attempts || 0));
  }

  function consumeHaggleAttempt(vendorKey, poiId) {
    const tracker = getHaggleTracker(vendorKey, poiId);
    tracker.attempts = Math.min(MAX_HAGGLE_ATTEMPTS_PER_DAY, (tracker.attempts || 0) + 1);
  }

  function getHaggleBaseChance(tierId) {
    if (tierId === "ally") return 0.7;
    if (tierId === "trusted") return 0.55;
    if (tierId === "neutral") return 0.4;
    if (tierId === "wary") return 0.25;
    return 0.15;
  }

  function getBarterAcceptRatio(tierId) {
    if (tierId === "ally") return 0.95;
    if (tierId === "trusted") return 0.98;
    if (tierId === "neutral") return 1.02;
    if (tierId === "wary") return 1.08;
    return 1.15;
  }

  function recordTradeLedgerEntry(entry) {
    const ss = ensureStoryState();
    const tradeUi = ensureTradeUiState();
    const fort = getNearbyFortPOI();
    const vendorKey = entry.vendor || tradeUi.vendorKey || "forts";
    const payload = {
      ts: gameState.date instanceof Date ? new Date(gameState.date) : new Date(),
      location: entry.location || (fort && fort.name) || gameState.locationName,
      vendor: vendorKey,
      vendorPoi: entry.vendorPoi || (fort && fort.id) || tradeUi.poiId || null,
      action: entry.action,
      itemId: entry.itemId,
      itemName: entry.itemName,
      qty: entry.qty,
      unitPrice: entry.unitPrice,
      total: entry.total,
      moneyAfter: gameState.money || 0,
      rep: (ss.factionRep && ss.factionRep[vendorKey]) || 0,
      repLabel: getTradeTermsForFaction(vendorKey).label,
    };
    ss.tradeLedger.push(payload);
    if (ss.tradeLedger.length > 80) {
      ss.tradeLedger.splice(0, ss.tradeLedger.length - 80);
    }
  }

  function findRecentTrade(predicate, maxLookback = 15) {
    const ledger = (ensureStoryState().tradeLedger || []);
    for (let i = ledger.length - 1, n = 0; i >= 0 && n < maxLookback; i--, n++) {
      const e = ledger[i];
      if (!e) continue;
      const hrsAgo = hoursSinceDate(e.ts);
      if (predicate(e, hrsAgo)) return { entry: e, hoursAgo: hrsAgo };
    }
    return null;
  }

  function applyTradeConsequences(vendorKey, action, receivedItemIds, qtyMap, ctx) {
    if (vendorKey !== "men_in_gray") return;
    const receivedList = Array.isArray(receivedItemIds) ? receivedItemIds : [];
    const receivedContraband = receivedList.some(function (id) {
      if (id !== "rifles" && id !== "ammo") return false;
      const qty = qtyMap && qtyMap[id];
      return typeof qty === "number" ? qty > 0 : true;
    });
    if (!receivedContraband) return;
    adjustFactionRep("men_in_gray", 2, null, ctx);
    adjustFactionRep("forts", -1, null, ctx);
    const ss = ensureStoryState();
    if (ss.mythicEnabled !== false) {
      ss.mythicRumor = clamp((ss.mythicRumor || 0) + 1, 0, 100);
    }
    setEventFlag("gray_contraband_recent_time", getCurrentTrailHour(gameState));
  }

  function renderTradeLedger(notes) {
    if (dom.tradeLedgerNotes) {
      dom.tradeLedgerNotes.innerHTML = "";
      const list = Array.isArray(notes) ? notes.slice(0, 4) : [];
      if (!list.length) {
        const line = document.createElement("div");
        line.className = "ot-trade-ledger-note ot-text-muted";
        line.textContent = "No notes logged.";
        dom.tradeLedgerNotes.appendChild(line);
      } else {
        list.forEach(function (lineText) {
          const line = document.createElement("div");
          line.className = "ot-trade-ledger-note";
          line.textContent = lineText;
          dom.tradeLedgerNotes.appendChild(line);
        });
      }
    }

    if (!dom.tradeLedgerBody) return;
    const entries = (ensureStoryState().tradeLedger || []).slice(-10).reverse();
    if (!entries.length) {
      dom.tradeLedgerBody.innerHTML =
        '<div class="ot-trade-ledger-entry">No recent trades logged.</div>';
      return;
    }
    dom.tradeLedgerBody.innerHTML = "";
    entries.forEach(function (e) {
      const row = document.createElement("div");
      row.className = "ot-trade-ledger-entry";
      let verb = e.action === "sell" ? "Sell" : "Buy";
      const label = e.itemName || e.itemId || "goods";
      if (e.action === "barter") {
        verb = "Barter";
        row.textContent = `${verb} — ${label}`;
      } else {
        row.textContent = `${verb} ${e.qty} ${label} — ${formatMoney(e.total || 0)}`;
      }
      const meta = document.createElement("small");
      const ts = e.ts instanceof Date ? e.ts : new Date(e.ts);
      const timeLabel = formatDateTime(ts);
      const repLabel = e.repLabel || "";
      meta.textContent = `${e.location || "On the trail"} · ${repLabel} (${e.rep || 0}) · ${timeLabel}`;
      row.appendChild(meta);
      dom.tradeLedgerBody.appendChild(row);
    });
  }

  function renderTradeModal() {
    if (!dom.tradeModal || !dom.tradeBody) return;
    if (dom.tradeMsg) dom.tradeMsg.textContent = "";
    const ctx = resolveTradeContext();
    const tradeUi = ctx.tradeUi;
    const fort = ctx.fort;
    const tradeDef = ctx.tradeDef;
    const vendorState = ctx.vendorState;
    const vendorKey = tradeUi.vendorKey || "forts";
    const termsInfo = getTradeTermsForFaction(vendorKey);
    const terms = termsInfo;
    const tier = termsInfo.tier;
    const policy = getFortPolicyForTradeDef(tradeDef);
    const buyTariffPct = policy && isFinite(policy.buyTariffPct) ? Math.round(policy.buyTariffPct * 100) : 0;
    const sellTariffPct = policy && isFinite(policy.sellTariffPct) ? Math.round(policy.sellTariffPct * 100) : 0;

    if (dom.tradeTitle)
      dom.tradeTitle.textContent = vendorKey === "forts" ? "Trading Post" : getVendorLabelForKey(vendorKey);
    if (dom.tradeSub) {
      const subParts = [];
      if (vendorKey === "forts") subParts.push(fort ? fort.name : "Frontier post");
      else subParts.push((tradeDef && tradeDef.label) || getVendorLabelForKey(vendorKey));
      subParts.push(formatDateTime(gameState.date));
      subParts.push(terms.label + " terms");
      dom.tradeSub.textContent = subParts.join(" · ");
    }

    const totalWeight = computeTotalWeight();
    const draft = computeDraftPower();
    const loadPct = draft > 0 ? Math.round((totalWeight / draft) * 100) : 0;
    const overloadNote = draft > 0 && totalWeight > draft ? " (overloaded)" : "";
    if (dom.tradeSummary) {
      const summaryLoad =
        "Cash: " +
        formatMoney(gameState.money || 0) +
        " · Load: " +
        Math.round(totalWeight) +
        " lb / " +
        Math.max(1, Math.round(draft)) +
        " lb pull";
      dom.tradeSummary.textContent =
        summaryLoad +
        (draft > 0 ? ` (${loadPct}% capacity${overloadNote})` : " (no draft power)") +
        ` · Buy x${terms.costMult.toFixed(2)} / Sell x${terms.gainMult.toFixed(2)} (${tier.label} ${tier.value >= 0 ? "+" : ""}${tier.value})` +
        ` · Policy: ${policy ? policy.label : "Standard ledger"} · Tariff: +${buyTariffPct}% buy / -${sellTariffPct}% sell`;
    }

    if (dom.btnTradeBuyTab && dom.btnTradeSellTab && dom.btnTradeBarterTab) {
      dom.btnTradeBuyTab.classList.toggle(
        "ot-trade-tab-active",
        tradeUi.tab === "buy"
      );
      dom.btnTradeSellTab.classList.toggle(
        "ot-trade-tab-active",
        tradeUi.tab === "sell"
      );
      dom.btnTradeBarterTab.classList.toggle(
        "ot-trade-tab-active",
        tradeUi.tab === "barter"
      );
    }

    const catalog = (tradeDef.catalog || [])
      .map(function (id) {
        return SUPPLY_ITEMS.find(function (item) {
          return item && item.id === id;
        });
      })
      .filter(function (item) {
        return item && item.cost > 0 && item.readOnly !== true;
      })
      .sort(function (a, b) {
        if (a.category === b.category) return a.name.localeCompare(b.name);
        return a.category.localeCompare(b.category);
      });

    dom.tradeBody.innerHTML = "";
    const money = gameState.money || 0;
    const haggleRemaining = remainingHaggleAttempts(vendorKey, ctx.poiId);
    const barterState = ensureBarterState();

    const ledgerNotes = generateLedgerNotes(tradeDef, vendorState);

    if (haggleRemaining <= 0 && dom.tradeMsg)
      dom.tradeMsg.textContent = dom.tradeMsg.textContent || "No more haggling today.";

    catalog.forEach(function (item) {
      const tr = document.createElement("tr");
      const owned = gameState.supplies[item.id] || 0;
      const ownedLabel = owned % 1 === 0 ? owned : owned.toFixed(1);
      const pricing = computeTradePricing(item, tradeDef, vendorState, terms);
      const buyRestriction = getTradeRestriction(item.id, "buy", vendorKey, tier);
      const sellRestriction = getTradeRestriction(item.id, "sell", vendorKey, tier);
      const activeRestriction =
        tradeUi.tab === "buy"
          ? buyRestriction
          : tradeUi.tab === "sell"
          ? sellRestriction
          : buyRestriction.restricted
          ? buyRestriction
          : sellRestriction;
      const nameLabel = activeRestriction.restricted ? `${item.name} (${activeRestriction.tag || "restricted"})` : item.name;

      const tdName = document.createElement("td");
      tdName.textContent = nameLabel;
      if (buyRestriction.restricted || sellRestriction.restricted) tdName.classList.add("ot-text-muted");
      if (activeRestriction.reason) tdName.title = activeRestriction.reason;
      tr.appendChild(tdName);

      const tdOwned = document.createElement("td");
      tdOwned.textContent = ownedLabel;
      tr.appendChild(tdOwned);

      const tdStock = document.createElement("td");
      const stockLabel = pricing.vendorStock % 1 === 0 ? pricing.vendorStock : pricing.vendorStock.toFixed(1);
      tdStock.textContent = stockLabel;
      tr.appendChild(tdStock);

      const tdBuy = document.createElement("td");
      tdBuy.textContent = pricing.unitBuy > 0 ? formatMoney(pricing.unitBuy) : "—";
      tdBuy.title = `Rep x${terms.costMult.toFixed(2)} · Scarcity x${pricing.scarcityBuyMult.toFixed(2)}`;
      if (policy) tdBuy.title += ` · Tariff x${pricing.tariffBuyMult.toFixed(2)}`;
      if (buyRestriction.restricted && buyRestriction.reason)
        tdBuy.title += ` · ${buyRestriction.reason}`;
      tr.appendChild(tdBuy);

      const tdSell = document.createElement("td");
      tdSell.textContent = pricing.unitSell > 0 ? formatMoney(pricing.unitSell) : "—";
      tdSell.title = `Rep x${terms.gainMult.toFixed(2)} · Demand x${pricing.demandSellMult.toFixed(2)}`;
      if (policy) tdSell.title += ` · Tariff x${pricing.tariffSellMult.toFixed(2)}`;
      tr.appendChild(tdSell);

      const tdAction = document.createElement("td");
      const addBtn = function (label, handler, disabled, title) {
        const btn = document.createElement("button");
        btn.className = "ot-mini-btn";
        btn.textContent = label;
        btn.disabled = !!disabled;
        if (title) btn.title = title;
        btn.addEventListener("click", handler);
        tdAction.appendChild(btn);
      };

      if (tradeUi.tab === "buy") {
        const offerDisabledReason =
          buyRestriction.restricted
            ? buyRestriction.reason
            : !canHaggleToday(vendorKey, ctx.poiId)
            ? "No more offers today."
            : pricing.vendorStock < 1
            ? "Out of stock."
            : money < Math.max(1, Math.round(item.cost))
            ? "Need enough on hand to make an offer."
            : "";
        addBtn(
          "Buy 1",
          function () {
            tradeBuy(item.id, 1, pricing.unitBuy);
          },
          money < pricing.unitBuy || pricing.vendorStock < 1 || buyRestriction.restricted,
          buyRestriction.restricted ? buyRestriction.reason : null
        );
        addBtn(
          "Buy 5",
          function () {
            tradeBuy(item.id, 5, pricing.unitBuy);
          },
          money < pricing.unitBuy * 5 || pricing.vendorStock < 5 || buyRestriction.restricted,
          buyRestriction.restricted ? buyRestriction.reason : null
        );
        addBtn(
          "Buy 10",
          function () {
            tradeBuy(item.id, 10, pricing.unitBuy);
          },
          money < pricing.unitBuy * 10 || pricing.vendorStock < 10 || buyRestriction.restricted,
          buyRestriction.restricted ? buyRestriction.reason : null
        );
        addBtn(
          "Offer",
          function () {
            offerBuy(item.id, 1);
          },
          !!offerDisabledReason,
          offerDisabledReason
        );
      } else if (tradeUi.tab === "sell") {
        addBtn(
          "Sell 1",
          function () {
            tradeSell(item.id, 1, pricing.unitSell);
          },
          owned <= 0
        );
        addBtn(
          "Sell 5",
          function () {
            tradeSell(item.id, 5, pricing.unitSell);
          },
          owned <= 0
        );
        addBtn(
          "Sell all",
          function () {
            tradeSell(item.id, owned, pricing.unitSell);
          },
          owned <= 0
        );
        const available = Math.max(0, pricing.cap - pricing.vendorStock);
        const sellOfferReason =
          sellRestriction.restricted
            ? sellRestriction.reason
            : !canHaggleToday(vendorKey, ctx.poiId)
            ? "No more offers today."
            : owned <= 0
            ? "Nothing to offer."
            : available <= 0
            ? "They can't take more right now."
            : "";
        addBtn(
          "Offer",
          function () {
            offerSell(item.id, 1);
          },
          !!sellOfferReason,
          sellOfferReason
        );
      } else if (tradeUi.tab === "barter") {
        const availableSpace = Math.max(
          0,
          pricing.cap - pricing.vendorStock - (barterState.offer[item.id] || 0)
        );
        const availableStock = Math.max(0, pricing.vendorStock - (barterState.ask[item.id] || 0));
        const maxOffer = Math.min(owned, Math.max(0, pricing.cap - pricing.vendorStock));
        const maxAsk = Math.max(0, pricing.vendorStock);
        addBtn(
          "Offer +1",
          function () {
            adjustBarterQty("offer", item.id, 1, maxOffer);
            renderTradeModal();
          },
          owned <= 0 || availableSpace <= 0 || sellRestriction.restricted,
          sellRestriction.restricted
            ? sellRestriction.reason
            : availableSpace <= 0
            ? "Vendor can't take more."
            : owned <= 0
            ? "Nothing to offer."
            : null
        );
        addBtn(
          "Ask +1",
          function () {
            adjustBarterQty("ask", item.id, 1, maxAsk);
            renderTradeModal();
          },
          availableStock <= 0 || buyRestriction.restricted,
          buyRestriction.restricted
            ? buyRestriction.reason
            : availableStock <= 0
            ? "Out of stock."
            : null
        );
      }
      tr.appendChild(tdAction);
      dom.tradeBody.appendChild(tr);
    });

    if (dom.barterPanel) {
      if (tradeUi.tab !== "barter") {
        dom.barterPanel.style.display = "none";
      } else {
        dom.barterPanel.style.display = "block";
        dom.barterPanel.innerHTML = "";
        const totals = computeBarterTotals(ctx);

        const bundleLabel = function (lines, side) {
          const wrapper = document.createElement("div");
          const heading = document.createElement("h4");
          heading.textContent = side === "offer" ? "You offer" : "You request";
          wrapper.appendChild(heading);
          const list = document.createElement("div");
          list.className = "ot-barter-list";
          if (!lines.length) {
            const empty = document.createElement("div");
            empty.className = "ot-text-muted";
            empty.textContent = "Empty";
            list.appendChild(empty);
          } else {
            lines.forEach(function (line) {
              const row = document.createElement("div");
              row.className = "ot-barter-line";
              const label = document.createElement("div");
              label.textContent = `${line.qty} ${line.def ? line.def.name : line.id}`;
              row.appendChild(label);
              const btn = document.createElement("button");
              btn.className = "ot-mini-btn";
              btn.textContent = "−";
              btn.title = "Remove 1";
              btn.addEventListener("click", function () {
                adjustBarterQty(side, line.id, -1);
                renderTradeModal();
              });
              row.appendChild(btn);
              list.appendChild(row);
            });
          }
          wrapper.appendChild(list);
          return wrapper;
        };

        const cols = document.createElement("div");
        cols.className = "ot-barter-columns";
        cols.appendChild(bundleLabel(totals.offerLines, "offer"));
        cols.appendChild(bundleLabel(totals.askLines, "ask"));
        dom.barterPanel.appendChild(cols);

        const totalsRow = document.createElement("div");
        totalsRow.className = "ot-barter-totals";
        const offerVal = document.createElement("div");
        offerVal.textContent = `Offer Value: ${formatMoney(totals.offerValue)}`;
        const askVal = document.createElement("div");
        askVal.textContent = `Request Value: ${formatMoney(totals.askValue)}`;
        const balance = document.createElement("div");
        let hint = "Fair";
        if (totals.askValue <= 0 || totals.offerValue <= 0) hint = "Needs both sides";
        else if (totals.offerValue >= totals.askValue * 1.05) hint = "Generous";
        else if (totals.offerValue < totals.askValue * 0.97) hint = "Short";
        balance.textContent = hint;
        totalsRow.appendChild(offerVal);
        totalsRow.appendChild(askVal);
        totalsRow.appendChild(balance);
        dom.barterPanel.appendChild(totalsRow);

        if (totals.problems.length) {
          const warn = document.createElement("div");
          warn.className = "ot-modal-sub";
          warn.textContent = totals.problems[0];
          dom.barterPanel.appendChild(warn);
        }

        const haggleNote = document.createElement("div");
        haggleNote.className = "ot-modal-sub";
        haggleNote.textContent = `Haggle attempts left: ${haggleRemaining}`;
        dom.barterPanel.appendChild(haggleNote);

        const actions = document.createElement("div");
        actions.className = "ot-barter-actions";
        const btnClear = document.createElement("button");
        btnClear.className = "ot-btn-outline";
        btnClear.textContent = "Clear";
        btnClear.addEventListener("click", function () {
          barterState.offer = {};
          barterState.ask = {};
          renderTradeModal();
        });
        const btnPropose = document.createElement("button");
        btnPropose.className = "ot-btn";
        btnPropose.textContent = "Propose Barter";
        btnPropose.disabled =
          !totals.offerLines.length ||
          !totals.askLines.length ||
          totals.problems.length > 0 ||
          !canHaggleToday(vendorKey, ctx.poiId);
        btnPropose.addEventListener("click", function () {
          proposeBarter();
        });
        actions.appendChild(btnClear);
        actions.appendChild(btnPropose);
        dom.barterPanel.appendChild(actions);
      }
    }

    renderTradeLedger(ledgerNotes);
  }

  function openVendorTradeModal(vendorKey, poiId) {
    if (!dom.tradeModal) return;
    const tradeUi = ensureTradeUiState();
    tradeUi.open = true;
    tradeUi.tab = "buy";
    tradeUi.vendorKey = vendorKey || "forts";
    tradeUi.poiId = poiId || tradeUi.poiId || "frontier";
    tradeUi.barter = { offer: {}, ask: {} };
    if (dom.tradeMsg) dom.tradeMsg.textContent = "";
    dom.tradeModal.classList.add("active");
    renderTradeModal();
  }

  function openTradeModal() {
    const fort = getNearbyFortPOI();
    if (!fort || !dom.tradeModal) return;
    openVendorTradeModal("forts", fort.id);
  }

  function closeTradeModal() {
    hideModal(dom.tradeModal);
    const tradeUi = ensureTradeUiState();
    tradeUi.open = false;
    saveGame();
    renderAll();
  }

  function tradeBuy(itemId, qty, cachedUnitBuy) {
    const ctx = resolveTradeContext();
    const tradeUi = ctx.tradeUi;
    const tradeDef = ctx.tradeDef;
    const vendorState = ctx.vendorState;
    const vendorKey = tradeUi.vendorKey || "forts";
    const item = findSupplyDef(itemId);
    if (!item || qty <= 0) return;
    const useQty = Math.max(1, qty);
    const terms = getTradeTermsForFaction(vendorKey);
    const pricing = computeTradePricing(item, tradeDef, vendorState, terms);
    const unitBuy = cachedUnitBuy || pricing.unitBuy;
    const restriction = getTradeRestriction(item.id, "buy", vendorKey, terms.tier || getFactionRepTier(vendorKey));
    if (restriction.restricted) {
      if (dom.tradeMsg) dom.tradeMsg.textContent = restriction.reason || "They won't part with that right now.";
      return;
    }
    const vendorStock = pricing.vendorStock;
    if (vendorStock < useQty) {
      if (dom.tradeMsg)
        dom.tradeMsg.textContent =
          "Sutler is out of stock (only " + Math.max(0, Math.floor(vendorStock)) + " left).";
      return;
    }
    const totalCost = roundToCents(unitBuy * useQty);
    if ((gameState.money || 0) < totalCost) {
      if (dom.tradeMsg) dom.tradeMsg.textContent = "Not enough funds.";
      return;
    }
    gameState.money = Math.max(0, (gameState.money || 0) - totalCost);
    vendorState.stocks[itemId] = clamp(vendorStock - useQty, 0, pricing.cap);
    gameState.supplies[itemId] = (gameState.supplies[itemId] || 0) + useQty;
    recordTradeLedgerEntry({
      action: "buy",
      itemId: itemId,
      itemName: item.name,
      qty: useQty,
      unitPrice: unitBuy,
      total: totalCost,
      vendor: tradeUi.vendorKey,
      vendorPoi: ctx.poiId,
    });
    applyTradeConsequences(vendorKey, "buy", [itemId], { [itemId]: useQty }, { poiId: ctx.poiId });
    saveGame();
    renderAll();
    renderTradeModal();
  }

  function tradeSell(itemId, qty, cachedUnitSell) {
    const ctx = resolveTradeContext();
    const tradeUi = ctx.tradeUi;
    const tradeDef = ctx.tradeDef;
    const vendorState = ctx.vendorState;
    const vendorKey = tradeUi.vendorKey || "forts";
    const item = findSupplyDef(itemId);
    if (!item || qty <= 0) return;
    const owned = gameState.supplies[itemId] || 0;
    const requested = Math.min(Math.max(1, qty), owned);
    if (requested <= 0) {
      if (dom.tradeMsg) dom.tradeMsg.textContent = "No stock to sell.";
      return;
    }
    const termsInfo = getTradeTermsForFaction(vendorKey);
    const terms = termsInfo;
    const pricing = computeTradePricing(item, tradeDef, vendorState, terms);
    const unitSellCap = roundToCents(pricing.unitBuy * 0.9);
    let unitSell =
      cachedUnitSell != null
        ? Math.min(cachedUnitSell, unitSellCap)
        : pricing.unitSell;
    const availableSpace = Math.max(0, pricing.cap - pricing.vendorStock);
    if (availableSpace <= 0) {
      if (dom.tradeMsg) dom.tradeMsg.textContent = "They won't take any more of that right now.";
      return;
    }
    const useQty = Math.min(requested, availableSpace);
    if (useQty <= 0) {
      if (dom.tradeMsg) dom.tradeMsg.textContent = "They won't take any more of that right now.";
      return;
    }
    if (requested > availableSpace && dom.tradeMsg)
      dom.tradeMsg.textContent =
        "They won't take any more of that right now (space for " + Math.floor(availableSpace) + ").";
    const total = roundToCents(unitSell * useQty);
    gameState.money = (gameState.money || 0) + total;
    gameState.supplies[itemId] = owned - useQty;
    vendorState.stocks[itemId] = clamp(pricing.vendorStock + useQty, 0, pricing.cap);
    recordTradeLedgerEntry({
      action: "sell",
      itemId: itemId,
      itemName: item.name,
      qty: useQty,
      unitPrice: unitSell,
      total: total,
      vendor: tradeUi.vendorKey,
      vendorPoi: ctx.poiId,
    });
    saveGame();
    renderAll();
    renderTradeModal();
  }

  async function offerBuy(itemId, qty) {
    const ctx = resolveTradeContext();
    const tradeUi = ctx.tradeUi;
    const tradeDef = ctx.tradeDef;
    const vendorState = ctx.vendorState;
    const vendorKey = tradeUi.vendorKey || "forts";
    const setMsg = function (msg) {
      if (dom.tradeMsg) dom.tradeMsg.textContent = msg;
    };
    const item = findSupplyDef(itemId);
    const useQty = Math.max(1, qty || 1);
    if (!item) return;
    const termsInfo = getTradeTermsForFaction(vendorKey);
    const pricing = computeTradePricing(item, tradeDef, vendorState, termsInfo);
    const restriction = getTradeRestriction(item.id, "buy", vendorKey, termsInfo.tier);
    if (restriction.restricted) {
      setMsg(restriction.reason || "They won't part with that right now.");
      return;
    }
    if (pricing.vendorStock < useQty) {
      setMsg("Out of stock.");
      return;
    }
    const basePrice = pricing.unitBuy;
    const baseFundsCheck = Math.min(basePrice, Math.round(item.cost || basePrice));
    if ((gameState.money || 0) < baseFundsCheck) {
      setMsg("Need funds on hand to bargain.");
      return;
    }
    if (!canHaggleToday(vendorKey, ctx.poiId)) {
      setMsg("No more haggling today.");
      return;
    }

    const selection = await presentEncounter({
      id: `haggle_buy_${itemId}`,
      title: `Offer for ${item.name}`,
      subtitle: getVendorLabelForKey(vendorKey),
      body: [`The ledger shows ${formatMoney(basePrice)} per unit. You run a finger along a lower figure.`],
      options: [
        { id: "offer10", label: "Offer 10% less", tone: "neutral" },
        { id: "offer20", label: "Offer 20% less", tone: "warm" },
        { id: "pay", label: "Pay listed price", tone: "warm" },
        { id: "walk", label: "Walk away", tone: "neutral" },
      ],
      defaultId: "offer10",
    });

    if (!selection || selection === "walk") return;
    if (selection === "pay") {
      tradeBuy(itemId, useQty, basePrice);
      return;
    }

    const discount = selection === "offer20" ? 0.2 : 0.1;
    consumeHaggleAttempt(vendorKey, ctx.poiId);
    const floorPrice = roundToCents(pricing.unitBuy * 0.75);
    let offerPrice = clamp(roundToCents(basePrice * (1 - discount)), floorPrice, basePrice);
    const tierId = (termsInfo.tier && termsInfo.tier.id) || "neutral";
    const shortage = pricing.baseStock > 0 ? clamp((pricing.baseStock - pricing.vendorStock) / Math.max(1, pricing.baseStock), 0, 1) : 0;
    const baseChance = getHaggleBaseChance(tierId);
    let acceptChance = clamp(baseChance - discount * 0.6 - shortage * 0.25, 0, 0.9);
    let counterChance = clamp(baseChance - discount * 0.2 - shortage * 0.1, 0.05, 0.6);
    const roll = Math.random();
    let outcome = "refuse";
    if (roll < acceptChance) outcome = "accept";
    else if (roll < acceptChance + counterChance) outcome = "counter";

    if (outcome === "accept") {
      tradeBuy(itemId, useQty, offerPrice);
      setMsg(`Deal struck at ${formatMoney(offerPrice)}.`);
      return;
    }

    if (outcome === "counter") {
      const counterPct = Math.max(0.05, discount * 0.5);
      const counterPrice = clamp(roundToCents(basePrice * (1 - counterPct)), floorPrice, basePrice);
      const counter = await presentEncounter({
        id: `haggle_buy_counter_${itemId}`,
        title: "Ledger counteroffer",
        body: [`They tap the page: ${formatMoney(counterPrice)} per unit—no lower.`],
        options: [
          { id: "accept", label: "Accept counter", tone: "warm" },
          { id: "refuse", label: "Refuse", tone: "neutral" },
        ],
        defaultId: "accept",
      });
      if (counter === "accept") {
        const totalCost = counterPrice * useQty;
        if ((gameState.money || 0) < totalCost) {
          const msg = "Not enough funds for the counter.";
          setMsg(msg);
          renderTradeModal();
          setMsg(msg);
          return;
        }
        tradeBuy(itemId, useQty, counterPrice);
        const msg = `They counter at ${formatMoney(counterPrice)}.`;
        setMsg(msg);
        return;
      } else {
        const msg = "No deal. The trader shuts the book for now.";
        setMsg(msg);
        renderTradeModal();
        setMsg(msg);
        return;
      }
    }

    const msg = "No deal. The trader shuts the book for now.";
    setMsg(msg);
    renderTradeModal();
    setMsg(msg);
  }

  function applyBarterDeal(ctx, offerBasket, askBasket) {
    const tradeUi = ctx.tradeUi;
    const tradeDef = ctx.tradeDef;
    const vendorState = ctx.vendorState;
    const vendorKey = tradeUi.vendorKey || "forts";
    const terms = getTradeTermsForFaction(vendorKey);
    const offerLines = formatBarterLineItems(offerBasket || {});
    const askLines = formatBarterLineItems(askBasket || {});

    offerLines.forEach(function (line) {
      if (!line.def) return;
      const owned = gameState.supplies[line.id] || 0;
      const pricing = computeTradePricing(line.def, tradeDef, vendorState, terms);
      const currentStock = vendorState.stocks[line.id] || 0;
      const capSpace = Math.max(0, pricing.cap - currentStock);
      const qty = Math.max(0, Math.min(line.qty, owned, capSpace));
      if (qty <= 0) return;
      gameState.supplies[line.id] = Math.max(0, owned - qty);
      vendorState.stocks[line.id] = clamp(currentStock + qty, 0, pricing.cap);
    });

    askLines.forEach(function (line) {
      if (!line.def) return;
      const stock = vendorState.stocks[line.id] || 0;
      const takeQty = Math.max(0, Math.min(line.qty, stock));
      if (takeQty <= 0) return;
      vendorState.stocks[line.id] = Math.max(0, stock - takeQty);
      gameState.supplies[line.id] = (gameState.supplies[line.id] || 0) + takeQty;
    });

    const offerSummary = offerLines.length
      ? offerLines
          .map(function (l) {
            return `${l.qty} ${l.def ? l.def.name : l.id}`;
          })
          .join(" + ")
      : "nothing";
    const askSummary = askLines.length
      ? askLines
          .map(function (l) {
            return `${l.qty} ${l.def ? l.def.name : l.id}`;
          })
          .join(" + ")
      : "nothing";

    const askQtyMap = {};
    askLines.forEach(function (line) {
      if (!line || !line.id) return;
      askQtyMap[line.id] = (askQtyMap[line.id] || 0) + Math.max(0, line.qty || 0);
    });

    recordTradeLedgerEntry({
      action: "barter",
      itemName: `${offerSummary} → ${askSummary}`,
      qty: 1,
      unitPrice: 0,
      total: 0,
      vendor: tradeUi.vendorKey,
      vendorPoi: ctx.poiId,
    });
    applyTradeConsequences(vendorKey, "barter", askLines.map(function (l) { return l.id; }), askQtyMap, {
      poiId: ctx.poiId,
    });
  }

  async function proposeBarter() {
    const ctx = resolveTradeContext();
    const tradeUi = ctx.tradeUi;
    const vendorKey = tradeUi.vendorKey || "forts";
    const termsInfo = getTradeTermsForFaction(vendorKey);
    const tierId = (termsInfo.tier && termsInfo.tier.id) || "neutral";
    const acceptRatio = getBarterAcceptRatio(tierId);
    const barter = ensureBarterState();
    const offerBasket = Object.assign({}, barter.offer);
    const askBasket = Object.assign({}, barter.ask);
    const totals = computeBarterTotals(ctx, { offer: offerBasket, ask: askBasket });
    const setMsg = function (msg) {
      if (dom.tradeMsg) dom.tradeMsg.textContent = msg;
    };

    if (!totals.offerLines.length || !totals.askLines.length) {
      setMsg("Build an offer and request first.");
      return;
    }
    if (totals.problems.length) {
      setMsg(totals.problems[0]);
      return;
    }
    if (!canHaggleToday(vendorKey, ctx.poiId)) {
      setMsg("No more haggling today.");
      return;
    }
    if (totals.askValue <= 0 || totals.offerValue <= 0) {
      setMsg("Need a meaningful exchange.");
      return;
    }

    consumeHaggleAttempt(vendorKey, ctx.poiId);

    const offerDesc = totals.offerLines
      .map(function (l) {
        return `${l.qty} ${l.def ? l.def.name : l.id}`;
      })
      .join(", ");
    const askDesc = totals.askLines
      .map(function (l) {
        return `${l.qty} ${l.def ? l.def.name : l.id}`;
      })
      .join(", ");

    const acceptThreshold = totals.askValue * acceptRatio;
    const counterThreshold = totals.askValue * acceptRatio * 0.9;

    if (totals.offerValue >= acceptThreshold) {
      const choice = await presentEncounter({
        id: `barter_accept_${vendorKey}_${ctx.poiId || "frontier"}`,
        title: "Barter terms accepted",
        subtitle: getVendorLabelForKey(vendorKey),
        body: [`You offer: ${offerDesc}`, `You request: ${askDesc}`],
        options: [
          { id: "accept", label: "Accept", tone: "warm" },
          { id: "cancel", label: "Cancel", tone: "neutral" },
        ],
        defaultId: "accept",
      });
      if (choice === "accept") {
        applyBarterDeal(ctx, offerBasket, askBasket);
        barter.offer = {};
        barter.ask = {};
        saveGame();
        renderAll();
        renderTradeModal();
        setMsg("Barter completed.");
      } else {
        renderTradeModal();
        setMsg("You hold your offer back.");
      }
      return;
    }

    if (totals.offerValue >= counterThreshold) {
      const counterAsk = Object.assign({}, askBasket);
      let counterTotals = computeBarterTotals(ctx, { offer: offerBasket, ask: counterAsk });
      const maxValue = totals.offerValue / acceptRatio;
      const terms = termsInfo;
      const tradeDef = ctx.tradeDef;
      const vendorState = ctx.vendorState;
      let guard = 0;
      while (counterTotals.askValue > maxValue && counterTotals.askLines.length && guard < 200) {
        const sorted = counterTotals.askLines.slice().sort(function (a, b) {
          const pa = a.def ? computeTradePricing(a.def, tradeDef, vendorState, terms).unitBuy : 0;
          const pb = b.def ? computeTradePricing(b.def, tradeDef, vendorState, terms).unitBuy : 0;
          return pb - pa;
        });
        const target = sorted[0];
        counterAsk[target.id] = Math.max(0, (counterAsk[target.id] || 0) - 1);
        if (counterAsk[target.id] <= 0) delete counterAsk[target.id];
        counterTotals = computeBarterTotals(ctx, { offer: offerBasket, ask: counterAsk });
        guard++;
      }

      if (!counterTotals.askLines.length) {
        renderTradeModal();
        setMsg("No deal. They tap the ledger shut.");
        return;
      }

      const counterDesc = counterTotals.askLines
        .map(function (l) {
          return `${l.qty} ${l.def ? l.def.name : l.id}`;
        })
        .join(", ");

      const counterChoice = await presentEncounter({
        id: `barter_counter_${vendorKey}_${ctx.poiId || "frontier"}`,
        title: "Ledger counteroffer",
        subtitle: getVendorLabelForKey(vendorKey),
        body: ["They'll do it, but for less:", `You offer: ${offerDesc}`, `You receive: ${counterDesc}`],
        options: [
          { id: "accept", label: "Accept counter", tone: "warm" },
          { id: "refuse", label: "Refuse", tone: "neutral" },
        ],
        defaultId: "accept",
      });

      if (counterChoice === "accept") {
        applyBarterDeal(ctx, offerBasket, counterAsk);
        barter.offer = {};
        barter.ask = {};
        saveGame();
        renderAll();
        renderTradeModal();
        setMsg("Counter accepted.");
      } else {
        renderTradeModal();
        setMsg("No deal. They tap the ledger shut.");
      }
      return;
    }

    renderTradeModal();
    setMsg("No deal. They tap the ledger shut.");
  }

  async function offerSell(itemId, qty) {
    const ctx = resolveTradeContext();
    const tradeUi = ctx.tradeUi;
    const tradeDef = ctx.tradeDef;
    const vendorState = ctx.vendorState;
    const vendorKey = tradeUi.vendorKey || "forts";
    const setMsg = function (msg) {
      if (dom.tradeMsg) dom.tradeMsg.textContent = msg;
    };
    const item = findSupplyDef(itemId);
    if (!item) return;
    const owned = gameState.supplies[item.id] || 0;
    const useQty = Math.max(1, Math.min(owned, qty || 1));
    if (useQty <= 0) {
      setMsg("No stock to offer.");
      return;
    }
    const termsInfo = getTradeTermsForFaction(vendorKey);
    const pricing = computeTradePricing(item, tradeDef, vendorState, termsInfo);
    const availableSpace = Math.max(0, pricing.cap - pricing.vendorStock);
    if (availableSpace <= 0) {
      setMsg("They can't take more right now.");
      return;
    }
    const unitSellCap = roundToCents(pricing.unitBuy * 0.9);
    const basePrice = pricing.unitSell;
    if (!canHaggleToday(vendorKey, ctx.poiId)) {
      setMsg("No more haggling today.");
      return;
    }

    const selection = await presentEncounter({
      id: `haggle_sell_${itemId}`,
      title: `Offer to sell ${item.name}`,
      subtitle: getVendorLabelForKey(vendorKey),
      body: [`Ledger shows ${formatMoney(basePrice)} each. You could press for more.`],
      options: [
        { id: "ask10", label: "Ask 10% more", tone: "neutral" },
        { id: "ask20", label: "Ask 20% more", tone: "warm" },
        { id: "take", label: "Take listed price", tone: "warm" },
        { id: "walk", label: "Walk away", tone: "neutral" },
      ],
      defaultId: "ask10",
    });

    if (!selection || selection === "walk") return;
    if (selection === "take") {
      tradeSell(itemId, useQty, basePrice);
      return;
    }

    const bump = selection === "ask20" ? 0.2 : 0.1;
    consumeHaggleAttempt(vendorKey, ctx.poiId);
    const tierId = (termsInfo.tier && termsInfo.tier.id) || "neutral";
    const demand = pricing.baseStock > 0 ? clamp((pricing.baseStock - pricing.vendorStock) / Math.max(1, pricing.baseStock), 0, 1) : 0;
    let askPrice = clamp(roundToCents(basePrice * (1 + bump)), basePrice, unitSellCap);
    const baseChance = getHaggleBaseChance(tierId);
    let acceptChance = clamp(baseChance + demand * 0.15 - bump * 0.4, 0, 0.88);
    let counterChance = clamp(baseChance + demand * 0.05 - bump * 0.15, 0.05, 0.6);
    const roll = Math.random();
    let outcome = "refuse";
    if (roll < acceptChance) outcome = "accept";
    else if (roll < acceptChance + counterChance) outcome = "counter";

    if (outcome === "accept") {
      tradeSell(itemId, Math.min(useQty, availableSpace), askPrice);
      setMsg(`They take it at ${formatMoney(askPrice)}.`);
      return;
    }

    if (outcome === "counter") {
      const counterPct = Math.max(0.05, bump * 0.5);
      const counterPrice = clamp(roundToCents(basePrice * (1 + counterPct)), basePrice, unitSellCap);
      const counter = await presentEncounter({
        id: `haggle_sell_counter_${itemId}`,
        title: "Counteroffer on the page",
        body: [`They slide the ledger back: ${formatMoney(counterPrice)} per unit.`],
        options: [
          { id: "accept", label: "Accept counter", tone: "warm" },
          { id: "refuse", label: "Refuse", tone: "neutral" },
        ],
        defaultId: "accept",
      });
      if (counter === "accept") {
        tradeSell(itemId, Math.min(useQty, availableSpace), counterPrice);
        const msg = `They counter at ${formatMoney(counterPrice)}.`;
        setMsg(msg);
        return;
      } else {
        const msg = "No deal. The trader shuts the book for now.";
        setMsg(msg);
        renderTradeModal();
        setMsg(msg);
        return;
      }
    }

    const msg = "No deal. The trader shuts the book for now.";
    setMsg(msg);
    renderTradeModal();
    setMsg(msg);
  }

  function renderOnTrailHeader() {
    const paceCfg = PACE_CONFIG[gameState.pace] || PACE_CONFIG.steady;
    const rationCfg = RATION_CONFIG[gameState.rations] || RATION_CONFIG.filling;
    dom.ontrailPace.textContent = paceCfg.label;
    dom.ontrailRations.textContent = rationCfg.label;
    dom.ontrailMode.textContent =
      gameState.mode === "travel" ? "On the move" : "In camp";

    if (dom.ontrailBlock) {
      const block = getScheduleBlock(gameState.date);
      let label = "Night";
      if (block === "morning") label = "Morning (pre-dawn–noon)";
      else if (block === "noon") label = "Nooning (midday halt)";
      else if (block === "evening") label = "Evening (camp chores)";
      dom.ontrailBlock.textContent = label;
    }

    const w = gameState.weatherState || {};
    if (dom.weatherSummary) {
      dom.weatherSummary.textContent =
        (gameState.weather ? gameState.weather + " · " : "") +
        formatWeatherSummary(w);
    }
    if (dom.weatherNote) {
      const regionKey = regionToWeatherRegion(gameState.region || "plains");
      const seasonal = describeSeasonRisk(regionKey, gameState.date, gameState.startProfile);
      const flavor = describeWeatherFlavor(regionKey, w);
      dom.weatherNote.textContent = seasonal || flavor;
    }
  }

  function renderReputation() {
    ensureReputationState();
    if (!dom.reputationChip) return;
    const tier = getReputationTier();
    dom.reputationChip.textContent = tier.label;
    dom.reputationChip.className = "ot-rep-chip " + (tier.colorClass || "ot-rep-chip-neutral");
    dom.reputationChip.title = `${tier.desc} (Score ${Math.round(gameState.reputation || 0)})`;
  }

  function renderFactionStandings() {
    ensureReputationState();
    const chips = dom.factionChips || {};
    const classForTier = function (tierId) {
      if (tierId === "ally" || tierId === "trusted") return "ot-rep-chip-virtuous";
      if (tierId === "wary" || tierId === "hostile") return "ot-rep-chip-notorious";
      return "ot-rep-chip-neutral";
    };
    const hints = {
      forts: "Better sutler terms",
      caravans: "Better caravan trades",
      open_eye: "Watchful blessings or ire",
      men_in_gray: "Quiet dealings",
    };
    const applyChip = function (key, label) {
      const el = chips[key];
      if (!el) return;
      const tier = getFactionRepTier(key);
      el.className = "ot-rep-chip " + classForTier(tier.id);
      el.textContent = label + ": " + tier.label;
      el.title = `${tier.label} (${Math.round(tier.value)}) · ${hints[key] || "Trade terms"}`;
    };

    applyChip("forts", "Forts");
    applyChip("caravans", "Caravans");
    applyChip("open_eye", "Open Eye");
    const mythicOn = ensureStoryState().mythicEnabled !== false;
    if (chips.men_in_gray) {
      chips.men_in_gray.style.display = mythicOn ? "inline-flex" : "none";
      if (mythicOn) applyChip("men_in_gray", "Men in Gray");
    }
  }

  function renderAfflictionAlerts() {
    const container = dom.afflictionAlerts;
    if (!container) return;
    container.innerHTML = "";
    const alerts = [];
    getAllPeople().forEach(function (p) {
      if (!p || !p.afflictions) return;
      p.afflictions.forEach(function (a) {
        if (!a || a.resolved) return;
        if (a.stage === "acute" || a.severity >= 2) {
          alerts.push({
            id: a.id + "_" + p.id,
            label:
              (a.id === "cholera"
                ? "💧"
                : a.id === "mountain_pneumonia"
                ? "🌨"
                : a.id === "snakebite"
                ? "🐍"
                : a.id === "broken_bone"
                ? "🦴"
                : "✶") +
              " " +
              (a.label || "Affliction"),
            severity: a.severity || 1,
          });
        }
      });
    });
    if (!alerts.length) {
      container.style.display = "none";
      return;
    }
    container.style.display = "flex";
    alerts.slice(0, 4).forEach(function (a) {
      const pill = document.createElement("div");
      pill.className = "ot-affliction-pill";
      if (a.severity >= 3) pill.classList.add("severe");
      else if (a.severity >= 2) pill.classList.add("moderate");
      pill.textContent = a.label;
      container.appendChild(pill);
    });
  }


  function updatePriorityCellAppearance(btn, prio) {
    btn.classList.remove("prio-off", "prio-1", "prio-2", "prio-3", "prio-4");
    if (prio <= 0) {
      btn.classList.add("prio-off");
    } else {
      btn.classList.add("prio-" + prio);
    }
  }

  function renderPriorityWarnings() {
    const coverage = {};
    JOB_DEFS.forEach(function (job) {
      coverage[job.id] = false;
    });
    const people = getAllPeople();
    people.forEach(function (p) {
      if (!p) return;
      ensurePersonDelegationFields(p);
      const priorities = p.priorities || {};
      JOB_DEFS.forEach(function (job) {
        const v = typeof priorities[job.id] === "number" ? priorities[job.id] : 0;
        if (v > 0) coverage[job.id] = true;
      });
    });
    const vitalIds = ["cook", "hunt", "guard", "repair", "doctor", "fetch_water"];
    const warnings = [];
    vitalIds.forEach(function (jobId) {
      if (!coverage[jobId]) {
        const job = JOB_DEFS.find(function (j) {
          return j.id === jobId;
        });
        const label = job ? job.label : jobId;
        warnings.push("No one is assigned as " + label.toLowerCase() + ".");
      }
    });
    const urgentSick = getAllPeople().some(function (p) {
      return (
        p &&
        p.afflictions &&
        p.afflictions.some(function (a) {
          return a && !a.resolved && a.stage === "acute";
        })
      );
    });
    if (urgentSick && !coverage.doctor) {
      warnings.push("Serious illness in camp but no doctor assigned.");
    }
    if (!warnings.length) {
      warnings.push("All vital roles have at least one person assigned.");
    }
    dom.prioritiesWarnings.textContent = warnings.join(" ");
  }

  function renderPrioritiesModal() {
    const people = getAllPeople();
    dom.prioritiesHeadRow.innerHTML = "";
    dom.prioritiesBody.innerHTML = "";

    const thName = document.createElement("th");
    thName.textContent = "Companion";
    dom.prioritiesHeadRow.appendChild(thName);

    JOB_DEFS.forEach(function (job) {
      const th = document.createElement("th");
      th.textContent = job.label;
      dom.prioritiesHeadRow.appendChild(th);
    });

    people.forEach(function (person) {
      if (!person) return;
      ensurePersonDelegationFields(person);
      const tr = document.createElement("tr");
      const tdName = document.createElement("td");
      tdName.textContent = person.name;
      tr.appendChild(tdName);

      JOB_DEFS.forEach(function (job) {
        const td = document.createElement("td");
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "ot-priority-cell";
        const priorities = person.priorities || {};
        let prio = typeof priorities[job.id] === "number" ? priorities[job.id] : 0;
        btn.textContent = prio > 0 ? prio : "—";
        updatePriorityCellAppearance(btn, prio);
        btn.addEventListener("click", function () {
          let current =
            typeof person.priorities[job.id] === "number"
              ? person.priorities[job.id]
              : 0;
          current = (current + 1) % 5;
          person.priorities[job.id] = current;
          btn.textContent = current > 0 ? current : "—";
          updatePriorityCellAppearance(btn, current);
          renderPriorityWarnings();
          saveGame();
        });
        td.appendChild(btn);
        tr.appendChild(td);
      });

      dom.prioritiesBody.appendChild(tr);
    });

    renderPriorityWarnings();
  }

  function renderAll() {
    if (gameState.phase === "start") {
      renderLeaderStartPreview();
      renderDepartureSeasonDesc();
      updateStartArt();
      return;
    }

    if (gameState.phase === "outfit") {
      updateOutfitSummary();
      return;
    }

    if (gameState.phase === "travel") {
      const isExplorerView = gameState.travelView === "explorer";
      if (isExplorerView) {
        initExplorerWorldIfNeeded();
      }
      renderStorytellerDescription(gameState.storytellerPresetId || "classic");
      renderOnTrailHeader();
      renderReputation();
      renderFactionStandings();
      renderLeaderStatus();
      renderPartyManifest();
      renderHourTasks();
      renderScene();
      renderAfflictionAlerts();
      renderTrailHeader();
      renderExplorerChip();
      if (isExplorerView) {
        renderExplorerWorld();
      }
      renderTrailMap();
      syncMapModalState();
      renderCompanionDetail();
      renderTrailLog();
      renderCascadeSummary();
      renderSuppliesOverview();
      renderTradingPostAccess();
      renderFooter();
    }
  }

  /* ========= SAVE / LOAD =================================================== */

  function normalizeLegacyMeals() {
    if (
      gameState.supplies &&
      gameState.supplies.cooked_meals &&
      !gameState.supplies.meal_simple &&
      !gameState.supplies.meal_hearty &&
      !gameState.supplies.meal_feast
    ) {
      const old = gameState.supplies.cooked_meals || 0;
      gameState.supplies.meal_simple = Math.round(old * 0.4);
      gameState.supplies.meal_hearty = Math.round(old * 0.4);
      gameState.supplies.meal_feast = old - gameState.supplies.meal_simple - gameState.supplies.meal_hearty;
    }
  }

  function normalizeLegacySupplyAliases() {
    if (!gameState.supplies) return;
    const s = gameState.supplies;

    if (s.wheel) {
      s.wheels = (s.wheels || 0) + (s.wheel || 0);
      delete s.wheel;
    }
    if (s.axle) {
      s.axles = (s.axles || 0) + (s.axle || 0);
      delete s.axle;
    }
    if (s.medicine) {
      s.med_kits = (s.med_kits || 0) + (s.medicine || 0);
      delete s.medicine;
    }
  }

  function rehydrateTradeLedger() {
    const ss = ensureStoryState();
    if (!Array.isArray(ss.tradeLedger)) {
      ss.tradeLedger = [];
      return;
    }
    ss.tradeLedger = ss.tradeLedger
      .filter(Boolean)
      .map(function (entry) {
        const copy = Object.assign({}, entry);
        if (copy.ts && !(copy.ts instanceof Date)) copy.ts = new Date(copy.ts);
        return copy;
      });
  }

  function saveGame() {
    try {
      const payload = {
        gameState: gameState,
      };
      localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
    } catch (e) {
      console.warn("Unable to save game:", e);
    }
  }

  function loadGame() {
    try {
      const txt = localStorage.getItem(SAVE_KEY);
      if (!txt) return false;
      const payload = JSON.parse(txt);
      if (!payload || !payload.gameState) return false;

      Object.assign(gameState, payload.gameState);
      gameState.date = new Date(gameState.date);

      if (!gameState.supplies) resetSupplies();
      if (!gameState.startingFreeSupplies) gameState.startingFreeSupplies = {};
      if (!Array.isArray(gameState.startingFreeSuppliesNotes))
        gameState.startingFreeSuppliesNotes = [];
      if (!gameState.companions) gameState.companions = [];
      if (!Array.isArray(gameState.log)) gameState.log = [];
      if (!Array.isArray(gameState.nutritionHistory)) {
        gameState.nutritionHistory = [];
      }
      if (
        !gameState.currentNutrition ||
        !gameState.currentNutrition.dayKey
      ) {
        gameState.currentNutrition = {
          dayKey: getDayKey(gameState.date),
          staples: 0,
          meatFat: 0,
          fruitVeg: 0,
          coffeeTea: 0,
        };
      }
      if (!gameState.nutritionStatus) {
        gameState.nutritionStatus = null;
      }

      if (!gameState.startProfileId) {
        gameState.startProfileId = gameState.seasonStart || "late_april";
      }
      if (!gameState.startProfile) {
        gameState.startProfile =
          START_PROFILES[gameState.startProfileId] || START_PROFILES.late_april;
      }
      if (gameState.startDayOfYear == null && gameState.date) {
        gameState.startDayOfYear = getDayOfYear(gameState.date);
      }
      if (!gameState.partyId) {
        gameState.partyId =
          (gameState.leader && gameState.leader.name
            ? gameState.leader.name
            : "party") +
          "-" +
          gameState.startProfileId;
      }
      if (!gameState.weatherSeed) {
        gameState.weatherSeed = hashToInt(
          `${gameState.partyId}-${gameState.date.getFullYear()}`
        );
      }
      initWeatherSystem(gameState.date.getFullYear(), gameState.partyId);
      if (!Array.isArray(gameState.weatherHistory)) {
        gameState.weatherHistory = [];
      }

      if (!gameState.waterQuality) gameState.waterQuality = "safe";
      if (!gameState.lastWaterSourceType) gameState.lastWaterSourceType = "well";
      if (gameState.lastWaterBoiled == null) gameState.lastWaterBoiled = true;
      if (!gameState.waterPlan) gameState.waterPlan = null;
      if (!Array.isArray(gameState.cascadeEvents)) gameState.cascadeEvents = [];
      if (gameState.tensionDebug == null) gameState.tensionDebug = false;
      if (gameState.showStorytellerDebug == null)
        gameState.showStorytellerDebug = false;
      if (!gameState.spoilage) gameState.spoilage = { lastDayKey: null };
      if (!gameState.socialHistory) gameState.socialHistory = { rescues: [] };
      if (!Array.isArray(gameState.socialHistory.rescues)) gameState.socialHistory.rescues = [];
      if (!gameState.routeChoices) gameState.routeChoices = {};
      ensureReputationState();
      if (gameState.lastCampfireMomentKey == null) gameState.lastCampfireMomentKey = null;
      if (!gameState.actingLeaderId) gameState.actingLeaderId = null;
      if (!gameState.startingPoint) gameState.startingPoint = "independence";
      if (!gameState.hexMap)
        gameState.hexMap = { follow: true, camQ: 0, camR: 0, zoom: 1 };

      ensureTraillinesState();
      ensureExplorerState();
      ensureStoryState();
      if (!gameState.ui) gameState.ui = {};
      if (!gameState.ui.trade)
        gameState.ui.trade = {
          open: false,
          tab: "buy",
          vendorKey: "forts",
          poiId: null,
        };
      if (!gameState.ui.trade.tab) gameState.ui.trade.tab = "buy";
      if (!gameState.ui.trade.vendorKey) gameState.ui.trade.vendorKey = "forts";
      rehydrateTradeLedger();

      getAllPeople().forEach(function (p) {
        ensurePersonStoryFields(p);
      });


      // Rehydrate log entry dates
      gameState.log = gameState.log
        .map(function (entry) {
          if (!entry) return null;
          const d =
            entry.date instanceof Date ? entry.date : new Date(entry.date);
          return {
            date: d,
            text: entry.text || "",
            tone: entry.tone,
            tag: entry.tag,
            location: entry.location,
            characters: entry.characters || [],
          };
        })
        .filter(Boolean);

      if (typeof gameState.mapListVisible !== "boolean") {
        gameState.mapListVisible = false;
      }
      if (typeof gameState.mapOpen !== "boolean") {
        gameState.mapOpen = false;
      }

      // New: safety for daily rhythm fields on old saves
      if (typeof gameState.lastDayRhythmBonus !== "number") {
        gameState.lastDayRhythmBonus = 0;
      }

      if (!gameState.dayRhythm || !gameState.dayRhythm.dayKey) {
        // Older save with no rhythm object yet – create a fresh one for today
        ensureDayRhythmForDate(gameState.date);
      } else {
        // Back-fill any missing properties in case of version drift
        var dr = gameState.dayRhythm;
        var key = dr.dayKey || getDayKey(gameState.date);
        gameState.dayRhythm = {
          dayKey: key,
          morningTravelHours: dr.morningTravelHours || 0,
          noonCampHours: dr.noonCampHours || 0,
          noonEventTriggered: !!dr.noonEventTriggered,
          eveningCampChoice: dr.eveningCampChoice || null,
          nightTravelHours: dr.nightTravelHours || 0,
          nightGuardHours: dr.nightGuardHours || 0,
          morningSuggestionShown: !!dr.morningSuggestionShown,
          noonSuggestionShown: !!dr.noonSuggestionShown,
          eveningSuggestionShown: !!dr.eveningSuggestionShown,
        };
      }

      getAllPeople().forEach(function (p) {
        ensureAfflictions(p);
      });

      normalizeLegacyMeals();
      normalizeLegacySupplyAliases();
      ensureDelegationState();
      updateRegionAndLocation();
      refreshWeather();
      return true;
    } catch (e) {
      console.warn("Unable to load save:", e);
      return false;
    }
  }

  function hideModal(el) {
    if (el && el.classList) {
      el.classList.remove("active");
    }
  }


  function resetGame() {
    localStorage.removeItem(SAVE_KEY);
    location.reload();
  }

  function setTravelView(view) {
    if (view !== "journal" && view !== "explorer") view = "journal";
    gameState.travelView = view;

    if (dom.btnViewJournal && dom.btnViewExplorer) {
      dom.btnViewJournal.classList.toggle(
        "ot-view-toggle-btn-active",
        view === "journal"
      );
      dom.btnViewExplorer.classList.toggle(
        "ot-view-toggle-btn-active",
        view === "explorer"
      );
    }

    const travelScreen = dom.screens && dom.screens.travel;
    if (travelScreen) {
      travelScreen.classList.toggle("ot-view-mode-journal", view === "journal");
      travelScreen.classList.toggle(
        "ot-view-mode-explorer",
        view === "explorer"
      );
    }

    if (view === "explorer") {
      initExplorerWorldIfNeeded();
      resizeTrailCanvas();
      renderExplorerWorld();
    }

    saveGame();
    renderAll();
  }

  /* ========= EVENT WIRING ================================================== */

  function resetTasksForCurrentMode() {
    const people = getAllPeople();
    people.forEach(function (p, idx) {
      if (!p) return;
      if (idx === 0) {
        p.task = gameState.mode === "travel" ? "travel" : "auto";
      } else {
        p.task = "auto";
      }
    });
  }

  // Evening camp macros: “Proper camp (2h)” and “Rushed camp (1h)”
  async function runCampMacro(hours, campQuality) {
    if (gameState.mode !== "camp") {
      addLog(
        "You can only run camp routines while you are in camp. Toggle travel / camp first."
      );
      return;
    }

    playSound("campfire_loop", { loop: true, volume: 0.18 });

    const block = getScheduleBlock(gameState.date);

    // Track this on the daily rhythm object (used for next-day bonus/penalty)
    const dr = ensureDayRhythmForDate(gameState.date);
    dr.eveningCampChoice = campQuality;

    // Let the delegation system pick good chores for camp mode
    resetTasksForCurrentMode();
    buildCampPlanForNight(hours, campQuality);

    if (campQuality === "proper") {
      addLog(
        "You spend extra time making a careful camp: stock watered and grazed, wood and water gathered, and a proper supper cooked."
      );
    } else {
      addLog(
        "You throw together a rough camp with minimal chores before night, saving time but leaving things less well prepared."
      );
    }

    // Advance time with a context flag so camp-quality effects apply
    await advanceHours(hours, { campQuality: campQuality });
  }

  function wireEvents() {
    if (dom.departureSeason) {
      dom.departureSeason.addEventListener("change", function () {
        renderDepartureSeasonDesc();
      });
    }

    dom.departureSelect.addEventListener("change", updateStartArt);
    if (!ensurePartyDraftState().initialized) {
      ensurePartyDraftState().initialized = true;
      generateFullDraft();
    } else {
      applyDraftToInputs();
      renderAllDraftInfo();
    }
    if (dom.btnGenerateParty) {
      dom.btnGenerateParty.addEventListener("click", function () {
        generateFullDraft();
        renderAllDraftInfo();
        saveGame();
      });
    }
    if (dom.mythicToggle) {
      dom.mythicToggle.value = gameState.mythicEnabled === false ? "off" : "on";
      dom.mythicToggle.addEventListener("change", function () {
        gameState.mythicEnabled = dom.mythicToggle.value !== "off";
        ensureStoryState().mythicEnabled = gameState.mythicEnabled;
      });
    }
    dom.btnBeginOutfit.addEventListener("click", startNewGameFromForm);
    dom.btnAddRecommended.addEventListener("click", addRecommendedLoad);
    dom.btnBeginJourney.addEventListener("click", beginJourney);
    renderStorytellerOptions(
      dom.storytellerPreset,
      gameState.storytellerPresetId || "classic"
    );
    renderStorytellerDescription(gameState.storytellerPresetId || "classic");
    if (dom.tensionDebug) {
      dom.tensionDebug.checked = !!gameState.tensionDebug;
      dom.tensionDebug.addEventListener("change", function () {
        gameState.tensionDebug = dom.tensionDebug.checked;
        gameState.showStorytellerDebug = dom.tensionDebug.checked;
        renderTensionDebug(ensureStoryState(), buildStoryContext());
      });
    }
    if (dom.storytellerPreset) {
      dom.storytellerPreset.addEventListener("change", function () {
        const presetId = dom.storytellerPreset.value || "classic";
        setStorytellerPreset(presetId, { resetTimers: true });
        renderStorytellerDescription(presetId);
        saveGame();
      });
    }

    renderStorytellerOptions(
      dom.storytellerMidrun,
      gameState.storytellerPresetId || "classic"
    );
    if (dom.btnToggleNarrator) {
      dom.btnToggleNarrator.addEventListener("click", function () {
        if (!dom.narratorPicker) return;
        const visible = dom.narratorPicker.style.display !== "none";
        dom.narratorPicker.style.display = visible ? "none" : "block";
      });
    }
    if (dom.storytellerMidrun) {
      dom.storytellerMidrun.addEventListener("change", function () {
        const presetId = dom.storytellerMidrun.value || "classic";
        const oldPreset = gameState.storytellerPresetId || "classic";
        if (presetId === oldPreset) return;
        const check = canSwapStorytellerPreset(presetId);
        if (!check.ok) {
          if (dom.narratorHint) dom.narratorHint.textContent = check.reason;
          dom.storytellerMidrun.value = oldPreset;
          return;
        }
        setStorytellerPreset(presetId, { resetTimers: false });
        noteStorytellerSwap();
        renderStorytellerDescription(presetId);
        const preset = STORYTELLER_PRESETS[presetId] || STORYTELLER_PRESETS.classic;
        const tone =
          "You resolve to travel under " +
          preset.label.toLowerCase() +
          " — " +
          (preset.tagline || preset.hint || "a different narrator mood") + ".";
        addLog(tone, { tone: "meta" });
        saveGame();
        renderStorytellerOptions(dom.storytellerPreset, presetId);
        renderNarratorRules();
      });
    }
    dom.btnAdvance1.addEventListener("click", function () {
      withAdvanceLock(function () {
        return advanceHours(1);
      });
    });
    dom.btnAdvance4.addEventListener("click", function () {
      withAdvanceLock(function () {
        return advanceHours(4);
      });
    });
    if (dom.btnViewJournal) {
      dom.btnViewJournal.addEventListener("click", function () {
        setTravelView("journal");
      });
    }
    if (dom.btnViewExplorer) {
      dom.btnViewExplorer.addEventListener("click", function () {
        setTravelView("explorer");
      });
    }
    dom.btnToggleMode.addEventListener("click", function () {
      gameState.mode = gameState.mode === "travel" ? "camp" : "travel";
      resetTasksForCurrentMode();
      addLog(
        gameState.mode === "travel"
          ? "You break camp and move out."
          : "You halt the wagons and make camp."
      );
      saveGame();
      renderAll();
    });
    dom.btnChangePace.addEventListener("click", function () {
      const options = ["steady", "slow", "grueling"];
      const idx = options.indexOf(gameState.pace);
      const next = options[(idx + 1) % options.length];
      gameState.pace = next;
      addLog(
        "You change the pace to " +
          PACE_CONFIG[next].label.toLowerCase() +
          "."
      );
      saveGame();
      renderAll();
    });
    dom.btnChangeRations.addEventListener("click", function () {
      const options = ["filling", "normal", "meager", "barebones"];
      const idx = options.indexOf(gameState.rations);
      const next = options[(idx + 1) % options.length];
      gameState.rations = next;
      addLog(
        "You shift the party to " +
          RATION_CONFIG[next].label.toLowerCase() +
          "."
      );
      saveGame();
      renderAll();
    });

    dom.btnOpenInventory.addEventListener("click", function () {
      renderInventoryModal();
      dom.inventoryModal.classList.add("active");
    });
    dom.btnCloseInventory.addEventListener("click", function () {
      dom.inventoryModal.classList.remove("active");
    });
    if (dom.btnOpenTrade) {
      dom.btnOpenTrade.addEventListener("click", openTradeModal);
    }
    if (dom.tradeBackdrop && dom.tradeModal) {
      dom.tradeBackdrop.addEventListener("click", closeTradeModal);
    }
    if (dom.btnCloseTrade) {
      dom.btnCloseTrade.addEventListener("click", closeTradeModal);
    }
    if (dom.btnTradeBuyTab) {
      dom.btnTradeBuyTab.addEventListener("click", function () {
        const tradeUi = ensureTradeUiState();
        tradeUi.tab = "buy";
        renderTradeModal();
      });
    }
    if (dom.btnTradeSellTab) {
      dom.btnTradeSellTab.addEventListener("click", function () {
        const tradeUi = ensureTradeUiState();
        tradeUi.tab = "sell";
        renderTradeModal();
      });
    }
    if (dom.btnTradeBarterTab) {
      dom.btnTradeBarterTab.addEventListener("click", function () {
        const tradeUi = ensureTradeUiState();
        tradeUi.tab = "barter";
        renderTradeModal();
      });
    }
    if (dom.btnOpenSocial) {
      dom.btnOpenSocial.addEventListener("click", function () {
        renderSocialWeb();
        if (dom.socialModal) dom.socialModal.classList.add("active");
      });
    }
    if (dom.socialBackdrop && dom.socialModal) {
      dom.socialBackdrop.addEventListener("click", function () {
        dom.socialModal.classList.remove("active");
      });
    }
    if (dom.btnOpenMap) {
      dom.btnOpenMap.addEventListener("click", function () {
        openMapModal();
      });
    }
    if (dom.btnCloseMap) {
      dom.btnCloseMap.addEventListener("click", function () {
        closeMapModal();
      });
    }
    if (dom.explorerChip) {
      dom.explorerChip.addEventListener("click", function (e) {
        const actionTarget = e.target.closest("[data-action]");
        if (!actionTarget) return;
        const view = ensureExplorerViewState();
        if (actionTarget.dataset.action === "toggle-minimap") {
          view.showMinimap = !view.showMinimap;
          explorerRuntime.hover = null;
          renderExplorerChip();
          renderExplorerWorld();
        } else if (actionTarget.dataset.action === "toggle-inspect") {
          view.inspect = !view.inspect;
          explorerRuntime.hover = null;
          explorerRuntime.pinnedInspect = null;
          hideExplorerTooltip();
          renderExplorerChip();
          renderExplorerWorld();
        }
      });
    }
    if (dom.explorerTooltip) {
      dom.explorerTooltip.addEventListener("click", function (e) {
        const target = e.target.closest("[data-action=\"close-inspect\"]");
        if (target) {
          explorerRuntime.pinnedInspect = null;
          hideExplorerTooltip();
        }
      });
    }
    if (dom.mapModal) {
      dom.mapModal.addEventListener("click", function (e) {
        if (e.target === dom.mapModal || e.target === dom.mapBackdrop) {
          closeMapModal();
        }
      });
    }
    if (dom.btnTravel1h) {
      dom.btnTravel1h.addEventListener("click", function () {
        withAdvanceLock(function () {
          return advanceHoursTowardDestination(1);
        });
      });
    }
    if (dom.btnTravel4h) {
      dom.btnTravel4h.addEventListener("click", function () {
        withAdvanceLock(function () {
          return advanceHoursTowardDestination(4);
        });
      });
    }
    if (dom.btnAutoTravel) {
      dom.btnAutoTravel.addEventListener("click", function () {
        withAdvanceLock(function () {
          return advanceHoursTowardDestination(12);
        });
      });
    }
    if (dom.btnClearTarget) {
      dom.btnClearTarget.addEventListener("click", function () {
        clearTravelDestination();
      });
    }
    if (dom.inventoryModal) {
      dom.inventoryModal.addEventListener("click", function (e) {
        if (e.target === dom.inventoryModal || e.target === dom.modalBackdrop) {
          dom.inventoryModal.classList.remove("active");
        }
      });
    }

    if (dom.btnOpenPriorities) {
      dom.btnOpenPriorities.addEventListener("click", function () {
        renderPrioritiesModal();
        dom.prioritiesModal.classList.add("active");
      });
    }
    if (dom.btnEditRoles) {
      dom.btnEditRoles.addEventListener("click", function () {
        renderPrioritiesModal();
        dom.prioritiesModal.classList.add("active");
      });
    }
    if (dom.btnClosePriorities) {
      dom.btnClosePriorities.addEventListener("click", function () {
        dom.prioritiesModal.classList.remove("active");
      });
    }
    if (dom.prioritiesModal) {
      dom.prioritiesModal.addEventListener("click", function (e) {
        if (
          e.target === dom.prioritiesModal ||
          e.target === dom.prioritiesBackdrop
        ) {
          dom.prioritiesModal.classList.remove("active");
        }
      });
    }

    if (dom.btnToggleMapList) {
      dom.btnToggleMapList.addEventListener("click", function () {
        gameState.mapListVisible = !gameState.mapListVisible;
        updateMapListVisibility();
        saveGame();
      });
    }

    if (dom.toggleFog) {
      dom.toggleFog.addEventListener("change", function () {
        ensureHexMapState();
        gameState.hexMap.fogEnabled = !!dom.toggleFog.checked;
        saveGame();
        renderExplorer();
      });
    }
    if (dom.toggleSilhouettes) {
      dom.toggleSilhouettes.addEventListener("change", function () {
        ensureHexMapState();
        gameState.hexMap.silhouettesEnabled = !!dom.toggleSilhouettes.checked;
        saveGame();
        renderExplorer();
      });
    }

    // Evening camp macros
    if (dom.btnEveningProperCamp) {
      dom.btnEveningProperCamp.addEventListener("click", function () {
        withAdvanceLock(function () {
          return runCampMacro(2, "proper");
        });
      });
    }
    if (dom.btnEveningRushedCamp) {
      dom.btnEveningRushedCamp.addEventListener("click", function () {
        withAdvanceLock(function () {
          return runCampMacro(1, "rough");
        });
      });
    }
    if (dom.btnCampfireMoment) {
      dom.btnCampfireMoment.addEventListener("click", function () {
        withAdvanceLock(function () {
          return triggerCampfireMoment();
        });
      });
    }

    if (dom.btnOpenCamp && dom.campOverlay) {
      dom.btnOpenCamp.addEventListener("click", function () {
        openCampOverlay();
      });
    }
    if (dom.btnCloseCamp && dom.campOverlay) {
      dom.btnCloseCamp.addEventListener("click", closeCampOverlay);
      dom.campOverlay.addEventListener("click", function (e) {
        if (e.target === dom.campOverlay) closeCampOverlay();
      });
    }
    if (dom.btnCampConfirm) {
      dom.btnCampConfirm.addEventListener("click", function () {
        withAdvanceLock(function () {
          return confirmCampTasks();
        });
      });
    }
    if (dom.btnCampAuto) {
      dom.btnCampAuto.addEventListener("click", autoPlanCampTasks);
    }

    document.addEventListener("keydown", function (evt) {
      if (evt.key === "Escape") {
        hideModal(dom.inventoryModal);
        hideModal(dom.prioritiesModal);
        hideModal(dom.campOverlay);
        closeMapModal();
        if (dom.tradeModal && dom.tradeModal.classList.contains("active")) {
          closeTradeModal();
        }
      }

      const typingInForm =
        evt.target &&
        evt.target.tagName &&
        evt.target.tagName.match(/input|textarea/i);

      const isExplorer =
        gameState.phase === "travel" && gameState.travelView === "explorer";
      const canMove =
        isExplorer &&
        gameState.mode === "travel" &&
        !typingInForm &&
        !gameState.mapOpen;

      if (canMove && !evt.metaKey && !evt.ctrlKey) {
        if (evt.key === "ArrowLeft" || evt.key === "a" || evt.key === "A") {
          handleExplorerStep(-1, 0);
          evt.preventDefault();
          return;
        } else if (
          evt.key === "ArrowRight" ||
          evt.key === "d" ||
          evt.key === "D"
        ) {
          handleExplorerStep(1, 0);
          evt.preventDefault();
          return;
        } else if (evt.key === "ArrowUp" || evt.key === "w" || evt.key === "W") {
          handleExplorerStep(0, -1);
          evt.preventDefault();
          return;
        } else if (
          evt.key === "ArrowDown" ||
          evt.key === "s" ||
          evt.key === "S"
        ) {
          handleExplorerStep(0, 1);
          evt.preventDefault();
          return;
        } else if (evt.key === "f" || evt.key === "F") {
          recenterExplorerCameraOnWagon({ follow: true });
          evt.preventDefault();
          return;
        } else if (evt.key === "c" || evt.key === "C") {
          recenterExplorerCameraOnWagon({});
          evt.preventDefault();
          return;
        }
      }

      if (
        (evt.key === "d" || evt.key === "D") &&
        !evt.metaKey &&
        !evt.ctrlKey &&
        !typingInForm
      ) {
        gameState.showStorytellerDebug = !gameState.showStorytellerDebug;
        if (dom.tensionDebug) dom.tensionDebug.checked = gameState.showStorytellerDebug;
        renderTensionDebug(ensureStoryState(), buildStoryContext());
      }

      if (!isExplorer) return;

      if (!typingInForm && !evt.metaKey && !evt.ctrlKey) {
        const view = ensureExplorerViewState();
        if (evt.key === "i" || evt.key === "I") {
          view.inspect = !view.inspect;
          explorerRuntime.hover = null;
          explorerRuntime.pinnedInspect = null;
          hideExplorerTooltip();
          renderExplorerChip();
          renderExplorerWorld();
          evt.preventDefault();
          return;
        } else if (evt.key === "m" || evt.key === "M") {
          view.showMinimap = !view.showMinimap;
          explorerRuntime.hover = null;
          renderExplorerChip();
          renderExplorerWorld();
          evt.preventDefault();
          return;
        } else if (evt.key === "p" || evt.key === "P") {
          view.showPerf = !view.showPerf;
          explorerRuntime.hover = null;
          renderExplorerWorld();
          evt.preventDefault();
          return;
        }
      }

      if (evt.key === "v" || evt.key === "V") {
        setTravelView(
          gameState.travelView === "explorer" ? "journal" : "explorer"
        );
      }
    });

    dom.btnReset.addEventListener("click", resetGame);
  }


  /* ========= CAMP TASKS, LOG, THOUGHTS =================================== */

  function ensureCampFlags() {
    if (!gameState.flags) gameState.flags = {};
  }

  function buildCampMenuWidget() {
    const root = document.getElementById("oldtrail-camp-menu-widget");
    if (!root || root.dataset.built) return;
    root.dataset.built = "1";
    root.innerHTML =
      '<div class="cm-shell"><div class="cm-inner">' +
      '<div class="cm-header"><div class="cm-title">Camp Tasks</div><div class="cm-loc" contenteditable="true">Camp at dusk</div></div>' +
      '<div class="cm-note">Mark what your party will tend to before sleep</div>' +
      '<div class="cm-body"><div class="cm-head"><div>Task</div><div>Time</div><div>Effects</div><div>Choose</div></div><div data-role="cm-rows"></div></div>' +
      '<div class="cm-footer"><div class="cm-summary"><div class="cm-line">Hours at camp: <span data-role="cm-hours">6</span></div><div class="cm-line">Used: <span data-role="cm-hours-used">0.0</span> · Remaining: <span data-role="cm-hours-remaining" class="cm-hours-remaining">6.0</span></div><div class="cm-line">Tonight\'s focus: <span data-role="cm-focus">None yet</span></div></div><div class="cm-reset" data-role="cm-reset">Clear choices</div></div>' +
      "</div></div>";

    (function () {
      const rowsContainer = root.querySelector('[data-role="cm-rows"]');
      const hoursEl = root.querySelector('[data-role="cm-hours"]');
      const hoursUsedEl = root.querySelector('[data-role="cm-hours-used"]');
      const hoursRemainingEl = root.querySelector('[data-role="cm-hours-remaining"]');
      const focusEl = root.querySelector('[data-role="cm-focus"]');
      const resetEl = root.querySelector('[data-role="cm-reset"]');
      let hoursAvailable = 6;
      let tasks = CAMP_TASKS.map(function (t) {
        return Object.assign({}, t, { selected: false });
      });

      function describeEffects(eff) {
        const parts = [];
        if (eff.hunger) parts.push("Food");
        if (eff.thirst) parts.push("Water");
        if (eff.warmth) parts.push("Warmth");
        if (eff.energy) parts.push("Energy");
        if (eff.morale) parts.push("Morale");
        if (eff.condition) parts.push("Condition");
        if (eff.wagon) parts.push("Wagon");
        if (eff.guard) parts.push("Guard");
        return parts.length ? parts.join(", ") : "—";
      }

      function formatHours(h) {
        return (Math.round(h * 10) / 10).toFixed(1);
      }

      function renderRows() {
        rowsContainer.innerHTML = "";
        tasks.forEach(function (task) {
          const row = document.createElement("div");
          row.className = "cm-row";
          row.setAttribute("data-id", task.id);
          const nameEl = document.createElement("div");
          nameEl.className = "cm-action-name";
          nameEl.textContent = task.label;
          const timeEl = document.createElement("div");
          timeEl.className = "cm-time";
          timeEl.textContent = formatHours(task.hours) + "h";
          const effectsEl = document.createElement("div");
          effectsEl.className = "cm-effects";
          effectsEl.textContent = describeEffects(task.effects || {});
          const toggle = document.createElement("div");
          toggle.className = "cm-toggle";
          const check = document.createElement("div");
          check.className = "cm-check";
          if (task.selected) check.classList.add("cm-check-on");
          check.textContent = task.selected ? "✓" : "";
          const label = document.createElement("div");
          label.className = "cm-check-label";
          label.textContent = task.selected ? "Planned" : "Skip";
          toggle.appendChild(check);
          toggle.appendChild(label);
          toggle.addEventListener("click", function (evt) {
            evt.stopPropagation();
            task.selected = !task.selected;
            updateSummary();
            renderRows();
          });
          row.title = task.desc || "";
          row.appendChild(nameEl);
          row.appendChild(timeEl);
          row.appendChild(effectsEl);
          row.appendChild(toggle);
          rowsContainer.appendChild(row);
        });
      }

      function updateSummary() {
        let used = 0;
        const totals = { food: 0, warmth: 0, morale: 0, rest: 0 };
        tasks.forEach(function (task) {
          if (!task.selected) return;
          used += task.hours;
          const e = task.effects || {};
          if (e.hunger) totals.food += e.hunger;
          if (e.thirst) totals.food += e.thirst;
          if (e.warmth) totals.warmth += e.warmth;
          if (e.morale) totals.morale += e.morale;
          if (e.energy || e.condition) totals.rest += (e.energy || 0) + (e.condition || 0);
        });
        hoursUsedEl.textContent = formatHours(used);
        const remaining = hoursAvailable - used;
        hoursRemainingEl.textContent = formatHours(remaining);
        hoursRemainingEl.classList.toggle("cm-warning", remaining < -0.01);
        const maxVal = Math.max(totals.food, totals.warmth, totals.morale, totals.rest);
        if (maxVal <= 0) {
          focusEl.textContent = "None yet";
        } else {
          const focusParts = [];
          if (totals.food === maxVal) focusParts.push("Food/Water");
          if (totals.warmth === maxVal) focusParts.push("Warmth");
          if (totals.morale === maxVal) focusParts.push("Morale");
          if (totals.rest === maxVal) focusParts.push("Rest");
          focusEl.textContent = focusParts.join(", ");
        }
      }

      resetEl.addEventListener("click", function (evt) {
        evt.stopPropagation();
        tasks.forEach(function (t) {
          t.selected = false;
        });
        updateSummary();
        renderRows();
      });

      function setTasks(list) {
        if (!Array.isArray(list)) return;
        tasks = list.map(function (t) {
          return Object.assign({}, t);
        });
        renderRows();
        updateSummary();
      }

      window.oldTrailCampMenu = {
        setHours: function (h) {
          hoursAvailable = Math.max(0, Number(h) || 0);
          hoursEl.textContent = formatHours(hoursAvailable);
          updateSummary();
        },
        setTasks: setTasks,
        getPlan: function () {
          const selected = tasks.filter(function (t) {
            return t.selected;
          });
          let used = 0;
          selected.forEach(function (t) {
            used += t.hours;
          });
          return {
            hoursAvailable: hoursAvailable,
            hoursUsed: used,
            hoursRemaining: hoursAvailable - used,
            tasks: selected,
          };
        },
      };

      hoursEl.textContent = formatHours(hoursAvailable);
      renderRows();
      updateSummary();
    })();
  }

  function buildCampPlanForNight(hours, campQuality) {
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    const windowHours = Math.max(4, Math.min(hours ? hours + 4 : 6, 8));
    const workHours = Math.max(1, Math.min(hours || 2, 4));
    const guardNeed = campQuality === "proper" ? 1.2 : 0.8;
    const tasksOrder = ["cook", "fetch_water", "repair", "doctor", "guard", "craft", "gather_wood"];
    const plan = {
      nightId: (gameState.date ? gameState.date.getTime() : Date.now()) + "_" + (campQuality || "camp"),
      startHour: gameState.date ? gameState.date.getHours() : 0,
      totalHours: windowHours,
      campQuality: campQuality || "camp",
      guardCoverage: 0,
      people: [],
    };

    people.forEach(function (p) {
      ensurePersonDelegationFields(p);
      const priorities = p.priorities || {};
      const scored = tasksOrder
        .map(function (tId) {
          const def = JOB_DEFS.find(function (j) {
            return j.taskId === tId;
          });
          const prio = def ? priorities[def.id] || 0 : 0;
          const skillVal = def && def.relatedSkill ? p.skills[def.relatedSkill] || 0 : 0;
          return { taskId: tId, score: prio > 0 ? prio * 10 - skillVal : 999 };
        })
        .sort(function (a, b) {
          return a.score - b.score;
        })
        .filter(function (s) {
          return s.score < 999;
        });

      const timeline = [];
      for (let h = 0; h < windowHours; h++) {
        const slotTask = h < workHours && scored[h] ? scored[h].taskId : "rest";
        timeline.push({ hourOffset: h, taskId: slotTask });
      }
      const summary = { cookHours: 0, fetchWaterHours: 0, guardHours: 0, doctorHours: 0, repairHours: 0, craftHours: 0, forageHours: 0, restHours: 0 };
      timeline.forEach(function (slot) {
        if (slot.taskId === "cook") summary.cookHours += 1;
        else if (slot.taskId === "fetch_water") summary.fetchWaterHours += 1;
        else if (slot.taskId === "guard") summary.guardHours += 1;
        else if (slot.taskId === "doctor") summary.doctorHours += 1;
        else if (slot.taskId === "repair") summary.repairHours += 1;
        else if (slot.taskId === "craft") summary.craftHours += 1;
        else if (slot.taskId === "gather_wood") summary.forageHours += 1;
        else summary.restHours += 1;
      });

      plan.people.push({ personId: p.id, name: p.name, summary: summary, timeline: timeline });
    });

    plan.guardCoverage = plan.people.reduce(function (sum, entry) {
      return sum + entry.summary.guardHours * 0.5;
    }, 0);
    if (plan.guardCoverage < guardNeed && plan.people.length) {
      const bestGuard = plan.people.reduce(function (best, entry) {
        const person = people.find(function (pp) { return pp.id === entry.personId; });
        const skill = person && person.skills ? person.skills.guard || person.skills.travel || 0 : 0;
        return !best || skill > best.skill ? { entry: entry, skill: skill } : best;
      }, null);
      if (bestGuard) {
        bestGuard.entry.timeline[0].taskId = "guard";
        bestGuard.entry.summary.guardHours += 1;
        plan.guardCoverage += 0.5;
      }
    }

    gameState.campPlan = plan;
    return plan;
  }

  function renderCampChoreStrips(plan) {
    if (!dom.campChoreStrips) return;
    dom.campChoreStrips.innerHTML = "";
    if (!plan || !plan.people || !plan.people.length) return;
    plan.people.forEach(function (entry) {
      const row = document.createElement("div");
      row.className = "ot-chore-strip";
      const name = document.createElement("div");
      name.className = "ot-chore-name";
      name.textContent = entry.name || entry.personId;
      const role = document.createElement("div");
      role.className = "ot-chore-role";
      const summary = entry.summary || {};
      const roleBits = [];
      if (summary.cookHours) roleBits.push("Cook");
      if (summary.fetchWaterHours) roleBits.push("Water");
      if (summary.guardHours) roleBits.push("Guard");
      if (summary.repairHours) roleBits.push("Repair");
      if (roleBits.length === 0) roleBits.push("Rest");
      role.textContent = roleBits.join(" · ");
      const text = document.createElement("div");
      text.className = "ot-chore-summary";
      text.textContent =
        (summary.cookHours ? summary.cookHours + "h cook, " : "") +
        (summary.fetchWaterHours ? summary.fetchWaterHours + "h water, " : "") +
        (summary.guardHours ? summary.guardHours + "h guard, " : "") +
        (summary.repairHours ? summary.repairHours + "h repair, " : "") +
        (summary.restHours ? summary.restHours + "h rest" : "");
      const tl = document.createElement("div");
      tl.className = "ot-chore-timeline";
      const colorMap = {
        cook: "ot-ct-cook",
        fetch_water: "ot-ct-water",
        guard: "ot-ct-guard",
        repair: "ot-ct-repair",
        doctor: "ot-ct-doctor",
        craft: "ot-ct-craft",
        gather_wood: "ot-ct-forage",
        rest: "ot-ct-rest",
        sleep: "ot-ct-rest",
      };
      const timeline = entry.timeline || [];
      for (let i = 0; i < plan.totalHours; i++) {
        const slot = timeline[i] || { taskId: "rest" };
        const span = document.createElement("span");
        span.className = colorMap[slot.taskId] || "ot-ct-empty";
        tl.appendChild(span);
      }
      row.appendChild(name);
      row.appendChild(role);
      const summaryWrap = document.createElement("div");
      summaryWrap.appendChild(text);
      summaryWrap.appendChild(tl);
      row.appendChild(summaryWrap);
      dom.campChoreStrips.appendChild(row);
    });
  }

  function renderCampRolesSummary() {
    if (!dom.campRolesSummary) return;
    const plan = gameState.campPlan || buildCampPlanForNight(2, "preview");
    if (!plan || !plan.people || !plan.people.length) {
      dom.campRolesSummary.textContent = "Assign priorities to shape camp chores.";
      renderCampChoreStrips(null);
      return;
    }
    dom.campRolesSummary.textContent =
      "Night plan: " + plan.people.length + " people, guard " + plan.guardCoverage.toFixed(1) + "h";
    renderCampChoreStrips(plan);
  }

  function buildCraftingWidget() {
    const root = document.getElementById("oldtrail-crafting-widget");
    if (!root || root.dataset.built) return;
    root.dataset.built = "1";
    root.innerHTML =
      '<div class="ot-craft-header"><span>Crafting</span><select id="ot-craft-select" class="ot-select" style="flex:1"></select></div>' +
      '<div class="ot-craft-grid" id="ot-craft-grid"></div>' +
      '<div class="ot-craft-output" id="ot-craft-output">—</div>' +
      '<div class="ot-craft-status" id="ot-craft-status">Choose a recipe</div>' +
      '<div style="margin-top:6px; display:flex; gap:6px; align-items:center">' +
      '<button class="ot-btn-gold" id="ot-btn-craft-do">Craft</button>' +
      '<div id="ot-craft-req" class="ot-text-muted" style="font-size:11px"></div>' +
      "</div>";

    const grid = root.querySelector("#ot-craft-grid");
    const select = root.querySelector("#ot-craft-select");
    const statusEl = root.querySelector("#ot-craft-status");
    const outputEl = root.querySelector("#ot-craft-output");
    const reqEl = root.querySelector("#ot-craft-req");
    const craftBtn = root.querySelector("#ot-btn-craft-do");

    const cells = [];
    for (let i = 0; i < 9; i++) {
      const cell = document.createElement("div");
      cell.className = "ot-craft-cell";
      grid.appendChild(cell);
      cells.push(cell);
    }
    const arrow = document.createElement("div");
    arrow.textContent = "➜";
    arrow.style.textAlign = "center";
    arrow.style.color = "#f7cf7f";
    grid.appendChild(arrow);
    const spacer = document.createElement("div");
    spacer.style.display = "none";
    grid.appendChild(spacer);

    function renderSelect() {
      select.innerHTML = "";
      CRAFTING_RECIPES.forEach(function (rec) {
        const opt = document.createElement("option");
        opt.value = rec.id;
        opt.textContent = rec.name;
        select.appendChild(opt);
      });
    }

    function setPattern(pattern) {
      const p = pattern || "";
      for (let i = 0; i < cells.length; i++) {
        const on = p.charAt(i) === "1";
        cells[i].style.background = on
          ? "linear-gradient(135deg, rgba(247,207,127,0.25), rgba(240,183,91,0.15))"
          : "rgba(255,255,255,0.06)";
        cells[i].style.borderColor = on
          ? "rgba(247,207,127,0.45)"
          : "rgba(255,255,255,0.08)";
      }
    }

    function setOutput(label, iconText) {
      outputEl.textContent = iconText || label || "—";
    }

    function setStatus(text) {
      statusEl.textContent = text || "";
    }

    function renderRecipeRequirements(rec) {
      if (!rec) {
        reqEl.textContent = "";
        return;
      }
      const need = rec.inputs
        .map(function (i) {
          const have = gameState.supplies[i.key] || 0;
          return i.amount + " " + i.key + " (" + have + " on hand)";
        })
        .join(", ");
      reqEl.textContent = "Requires: " + need;
    }

    function currentRecipe() {
      const recId = select.value;
      return CRAFTING_RECIPES.find(function (r) {
        return r.id === recId;
      });
    }

    function craftRecipe() {
      const rec = currentRecipe();
      if (!rec) return;
      for (let i = 0; i < rec.inputs.length; i++) {
        const need = rec.inputs[i];
        const have = gameState.supplies[need.key] || 0;
        if (have < need.amount) {
          setStatus("Not enough " + need.key + " to craft.");
          return;
        }
      }
      rec.inputs.forEach(function (inp) {
        gameState.supplies[inp.key] = (gameState.supplies[inp.key] || 0) - inp.amount;
      });
      const crafter =
        gameState.selectedIndex === 0
          ? gameState.leader
          : gameState.companions[gameState.selectedIndex - 1] || gameState.leader;
      const outcome = rollSkillOutcome(crafter || gameState.leader, "craft", 1, {
        weather: gameState.weatherState,
      });
      let made = rec.output.amount;
      if (outcome.outcome === "success") made += 1;
      if (outcome.outcome === "fail") made = Math.max(1, Math.floor(made * 0.5));
      gameState.supplies[rec.output.key] =
        (gameState.supplies[rec.output.key] || 0) + made;
      setStatus("Crafted " + made + " " + rec.name + " (" + outcome.outcome + ").");
      addLog(
        "Crafted " +
          rec.name +
          " at camp (" +
          outcome.outcome +
          ").",
        { tone: outcome.outcome === "fail" ? "warning" : "event" }
      );
      playSound("craft_tick");
      renderSupplies();
      renderRecipeRequirements(rec);
    }

    select.addEventListener("change", function () {
      const rec = currentRecipe();
      if (!rec) return;
      setPattern(rec.pattern);
      setOutput(rec.icon || rec.name, rec.icon || rec.name);
      setStatus(rec.desc);
      renderRecipeRequirements(rec);
    });
    craftBtn.addEventListener("click", craftRecipe);

    window.oldTrailCrafting = {
      setPattern: setPattern,
      setOutput: setOutput,
      setStatus: setStatus,
      clearGrid: function () {
        setPattern("000000000");
        setOutput("—");
      },
    };

    renderSelect();
    if (CRAFTING_RECIPES.length) {
      select.value = CRAFTING_RECIPES[0].id;
      select.dispatchEvent(new Event("change"));
    }
  }

  function openCampOverlay() {
    buildCampMenuWidget();
    buildCraftingWidget();
    if (window.oldTrailCampMenu) {
      oldTrailCampMenu.setHours(6);
      oldTrailCampMenu.setTasks(
        CAMP_TASKS.map(function (t) {
          return Object.assign({}, t, { selected: false });
        })
      );
    }
    renderCampRolesSummary();
    if (dom.campOverlay) dom.campOverlay.classList.add("ot-show");
    dom.campOverlay.classList.add("ot-show");
  }

  function closeCampOverlay() {
    if (dom.campOverlay) dom.campOverlay.classList.remove("ot-show");
  }

  async function applyCampTasks(plan) {
    if (!plan || !plan.tasks || !plan.tasks.length) return;
    ensureCampFlags();
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    plan.tasks.forEach(function (task) {
      const eff = task.effects || {};
      people.forEach(function (p) {
        if (eff.hunger) adjustPersonStat(p, "hunger", eff.hunger);
        if (eff.thirst) adjustPersonStat(p, "thirst", eff.thirst);
        if (eff.warmth) adjustPersonStat(p, "warmth", eff.warmth);
        if (eff.morale) adjustPersonStat(p, "morale", eff.morale);
        if (eff.energy) adjustPersonStat(p, "energy", eff.energy);
        if (eff.condition) adjustPersonStat(p, "condition", eff.condition);
      });
      if (eff.wagon) {
        gameState.wagonCondition = clamp(
          (gameState.wagonCondition || 0) + eff.wagon,
          0,
          120
        );
      }
      if (eff.guard) {
        gameState.guardLevel += eff.guard;
        gameState.flags.stoodGuard = true;
      }
      if (eff.supplies) {
        Object.keys(eff.supplies).forEach(function (k) {
          gameState.supplies[k] = (gameState.supplies[k] || 0) + eff.supplies[k];
        });
      }
    });
    const hours = Math.max(1, Math.round(plan.hoursUsed));
    await advanceHours(hours, {
      campQuality: plan.hoursUsed >= 2 ? "proper" : "rough",
    });
    addLog(
      "Camp chores complete: " +
        plan.tasks
          .map(function (t) {
            return t.label;
          })
          .join(", ") +
        ".",
      { tone: "event" }
    );
  }

  function autoSelectCampTasks(gameState) {
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    const avgHunger =
      people.reduce(function (sum, p) {
        return sum + p.hunger;
      }, 0) / (people.length || 1);
    const avgThirst =
      people.reduce(function (sum, p) {
        return sum + p.thirst;
      }, 0) / (people.length || 1);
    const avgEnergy =
      people.reduce(function (sum, p) {
        return sum + p.energy;
      }, 0) / (people.length || 1);

    let hours = 6;
    const picks = [];
    function tryAdd(id) {
      const t = CAMP_TASKS.find(function (x) {
        return x.id === id;
      });
      if (t && hours - t.hours >= -1) {
        hours -= t.hours;
        picks.push(Object.assign({}, t, { selected: true }));
      }
    }

    const crisis = detectCrisisNeeds();
    if (crisis.indexOf("fetch_water") >= 0) tryAdd("fetch_and_boil_water");
    if (crisis.indexOf("cook") >= 0) tryAdd("cook_hot_meal");
    if (crisis.indexOf("repair") >= 0 || gameState.wagonCondition < 70)
      tryAdd("repair_wagon_and_tackle");
    if (avgThirst < 70) tryAdd("fetch_and_boil_water");
    if (avgHunger < 70) tryAdd("cook_hot_meal");
    if (avgEnergy < 60) tryAdd("extra_sleep");
    tryAdd("gather_fuel");
    if (picks.length === 0) tryAdd("read_book");

    return CAMP_TASKS.map(function (t) {
      const found = picks.find(function (p) {
        return p.id === t.id;
      });
      return Object.assign({}, t, { selected: !!found });
    });
  }

  function campfireMomentAvailable() {
    if (!dom.btnCampfireMoment) return false;
    const block = getScheduleBlock(gameState.date);
    if (gameState.mode !== "camp") return false;
    if (block !== "evening" && block !== "night") return false;
    const key = getDayKey(gameState.date) + ":" + block;
    return gameState.lastCampfireMomentKey !== key;
  }

  function refreshCampfireButton() {
    if (!dom.btnCampfireMoment) return;
    const available = campfireMomentAvailable();
    dom.btnCampfireMoment.disabled = !available || encounterActive || isAdvancingTime;
    dom.btnCampfireMoment.textContent = available
      ? "Campfire moment (1h)"
      : "Campfire moment (rested)";
  }

  async function triggerCampfireMoment() {
    if (!campfireMomentAvailable()) {
      addLog("The camp is not settled for a quiet hour yet.");
      return;
    }
    const block = getScheduleBlock(gameState.date);
    const key = getDayKey(gameState.date) + ":" + block;
    const choice = await presentEncounter({
      id: "campfire_moment",
      title: "Campfire moment",
      subtitle: formatDateTime(gameState.date) + " · " + gameState.locationName,
      body: [
        "The fire burns low. A hymn hums from one wagon, while another shuffles cards. Tempers and hopes could be nudged by how you spend this hour.",
      ],
      tags: ["camp"],
      options: [
        { id: "join", label: "Join the song and stories", tone: "warm", hint: "Raise morale; a kind word costs little." },
        { id: "mediate", label: "Check in on simmering tensions", tone: "neutral", hint: "Smooth frayed nerves before morning." },
        { id: "turn_in", label: "Call for early rest", tone: "danger", hint: "Rest first, talk later." },
      ],
      defaultId: "turn_in",
    });

    const people = getAllPeople();
    if (choice === "join") {
      people.forEach(function (p) {
        adjustPersonStat(p, "morale", 3);
      });
      adjustReputation(2, "Warm campfire welcome", { flag: "campfire_kind" });
      addLog("You share stories and a hymn. Spirits lift as embers drift up into the dark.", { tone: "morale" });
    } else if (choice === "mediate") {
      const pair = pickRivalPair() || (people.length >= 2 ? { a: people[0], b: people[1] } : null);
      if (pair && pair.a && pair.b) {
        adjustOpinion(pair.a, pair.b, 4, "campfire_moment");
        adjustOpinion(pair.b, pair.a, 4, "campfire_moment");
      }
      people.forEach(function (p) {
        adjustPersonStat(p, "morale", 1);
      });
      adjustReputation(1, "Settled disputes by the fire", { flag: "campfire_mediator" });
      addLog("You listen more than you speak, easing small grudges before they harden.", { tone: "social" });
    } else {
      people.forEach(function (p) {
        adjustPersonStat(p, "energy", 2);
        adjustPersonStat(p, "morale", -1);
      });
      adjustReputation(-1, "Sent everyone to their bedrolls early");
      addLog("You bank the fire early. Rest comes, but a few mutter into their blankets.", { tone: "warning" });
    }

    gameState.lastCampfireMomentKey = key;
    await advanceHours(1, { reason: "campfire_moment" });
    refreshCampfireButton();
    renderAll();
  }

  function autoPlanCampTasks() {
    if (!window.oldTrailCampMenu) return;
    const tasks = autoSelectCampTasks(gameState);
    oldTrailCampMenu.setTasks(tasks);
    dom.campSummaryNote.textContent = "Auto-selected chores based on needs.";
    renderCampRolesSummary();
  }

  async function confirmCampTasks() {
    if (!window.oldTrailCampMenu) return;
    const plan = oldTrailCampMenu.getPlan();
    if (!plan.tasks.length) {
      dom.campSummaryNote.textContent = "No chores selected.";
      return;
    }
    await applyCampTasks(plan);
    closeCampOverlay();
    renderAll();
  }

  function initTrailLogWidget() {
    const root = document.getElementById("old-trail-log-widget");
    if (!root || window.ksOldTrailLog) return;
    const listEl = root.querySelector(".ot-log-list");
    const maxEntries = 6;
    let queue = [];
    let typing = false;

    function createEntry(message) {
      const entry = document.createElement("div");
      entry.className = "ot-log-entry";
      if (message.tone === "event") entry.classList.add("ot-entry-event");
      if (message.tone === "warning") entry.classList.add("ot-entry-warning");
      if (message.tone === "morale") entry.classList.add("ot-entry-morale");
      const metaRow = document.createElement("div");
      metaRow.className = "ot-log-meta";
      const tag = document.createElement("span");
      tag.className = "ot-log-tag";
      tag.textContent = message.tag || "DAY " + (message.day || "0");
      const loc = document.createElement("span");
      loc.className = "ot-log-location";
      loc.textContent = message.location || "On the trail";
      metaRow.appendChild(tag);
      metaRow.appendChild(loc);
      const text = document.createElement("div");
      text.className = "ot-log-text";
      entry.appendChild(metaRow);
      entry.appendChild(text);
      const previousActive = listEl.querySelector(".ot-entry-active");
      if (previousActive) previousActive.classList.remove("ot-entry-active");
      entry.classList.add("ot-entry-active");
      listEl.appendChild(entry);
      while (listEl.children.length > maxEntries) {
        listEl.removeChild(listEl.firstChild);
      }
      requestAnimationFrame(function () {
        entry.classList.add("ot-entry-in");
      });
      playSound("log_pop");
      return entry;
    }

    function typeText(entry, text, done) {
      const textEl = entry.querySelector(".ot-log-text");
      if (!textEl) return;
      textEl.textContent = "";
      const cursor = document.createElement("span");
      cursor.className = "ot-cursor";
      cursor.textContent = "▌";
      textEl.appendChild(cursor);
      let index = 0;
      function step() {
        if (index >= text.length) {
          cursor.classList.add("ot-cursor-done");
          setTimeout(function () {
            if (cursor.parentNode) cursor.parentNode.removeChild(cursor);
          }, 200);
          if (done) done();
          return;
        }
        const ch = text.charAt(index);
        const node = document.createTextNode(ch);
        textEl.insertBefore(node, cursor);
        index += 1;
        let delay = 18;
        if (",.;!?".indexOf(ch) >= 0) delay = 120;
        setTimeout(step, delay);
      }
      step();
    }

    function processQueue() {
      if (!queue.length) {
        typing = false;
        return;
      }
      typing = true;
      const message = queue.shift();
      const entry = createEntry(message);
      typeText(entry, message.text, function () {
        typing = false;
        processQueue();
      });
    }

    function addMessage(text, meta) {
      queue.push({
        text: text,
        tag: meta && meta.tag,
        location: meta && meta.location,
        tone: meta && meta.tone,
        day: meta && meta.day,
      });
      if (!typing) processQueue();
    }

    function clearAll() {
      queue = [];
      typing = false;
      while (listEl.firstChild) listEl.removeChild(listEl.firstChild);
    }

    window.ksOldTrailLog = { add: addMessage, clear: clearAll };
  }

  let thoughtIndex = 0;
  const THOUGHT_DEFS = [
    {
      id: "clear_morning_plains",
      moods: ["Upbeat"],
      regions: ["plains", "great_plains"],
      weatherTags: ["clear"],
      riskTags: [],
      minHoursBetweenUses: 36,
      weight: 3,
      templates: [
        "{name} squints into golden grass. 'Hard to believe this ocean of prairie ever ends.'",
      ],
    },
    {
      id: "stormy_night",
      moods: ["Uneasy", "Worn"],
      weatherTags: ["storm"],
      minHoursBetweenUses: 24,
      weight: 4,
      templates: [
        "Wind shakes the wagon canvas. {name} mutters, 'Hope the ropes hold.'",
      ],
    },
    {
      id: "river_anxiety",
      moods: ["Uneasy"],
      regions: ["snake_plain", "columbia"],
      weatherTags: ["rain"],
      riskTags: ["water_shortage"],
      minHoursBetweenUses: 30,
      weight: 3,
      templates: [
        "Looking toward the river, {name} whispers, 'Water's a gift and a threat both.'",
      ],
    },
    {
      id: "behind_schedule",
      moods: ["Worn"],
      riskTags: ["behind_schedule"],
      minHoursBetweenUses: 48,
      weight: 4,
      templates: [
        "'We can't afford to dawdle,' {name} says quietly. 'Snow won't wait for us.'",
      ],
    },
    {
      id: "mountain_awe",
      moods: ["Upbeat", "Uneasy"],
      regions: ["rockies", "blue_mountains"],
      minHoursBetweenUses: 48,
      weight: 2,
      templates: [
        "{name} watches the peaks. 'Those ridges look close until you try to cross them.'",
      ],
    },
    {
      id: "broken_morale",
      moods: ["Broken"],
      minHoursBetweenUses: 60,
      weight: 5,
      templates: [
        "{name}'s eyes are distant. 'I'm not sure I have another dawn in me.'",
      ],
    },
    {
      id: "plains_sunrise_upbeat",
      moods: ["Upbeat"],
      regions: ["plains", "central_plains"],
      weatherTags: ["clear"],
      minHoursBetweenUses: 24,
      weight: 3,
      templates: [
        "Sunrise spills across the prairie grass. {name} smiles, 'Days like this make the miles feel kind.'",
      ],
    },
    {
      id: "rain_muck_uneasy",
      moods: ["Uneasy"],
      regions: ["central_plains", "high_plains"],
      weatherTags: ["rain"],
      minHoursBetweenUses: 18,
      weight: 3,
      templates: [
        "Mud sucks at the wheels. {name} mutters, 'We'll be scraping muck off everything for days.'",
      ],
    },
    {
      id: "snake_heat_worn",
      moods: ["Worn"],
      regions: ["snake_plain"],
      weatherTags: ["heat"],
      minHoursBetweenUses: 28,
      weight: 4,
      templates: [
        "Heat shimmers off the dry ground. {name} wipes sweat away. 'Snake Country is sucking the strength out of us.'",
      ],
    },
    {
      id: "mountain_snow_broken",
      moods: ["Worn", "Broken"],
      regions: ["mountains", "blue_mountains"],
      weatherTags: ["snow", "cold_snap"],
      minHoursBetweenUses: 36,
      weight: 3,
      templates: [
        "Snow stings exposed skin. {name} whispers, 'If winter catches us up here, we're done.'",
      ],
    },
    {
      id: "columbia_push_uneasy",
      moods: ["Uneasy", "Worn"],
      regions: ["columbia"],
      minHoursBetweenUses: 30,
      weight: 2,
      templates: [
        "River spray mists the wagon canvas. {name} keeps glancing at the cliffs. 'No room for mistakes now.'",
      ],
    },
    {
      id: "willamette_relief_upbeat",
      moods: ["Upbeat", "Uneasy"],
      regions: ["willamette"],
      weatherTags: ["clear"],
      minHoursBetweenUses: 40,
      weight: 2,
      templates: [
        "Green slopes open ahead. {name} laughs softly, 'Smells like home soil might really be close.'",
      ],
    },
    {
      id: "romance_budding_glance",
      moods: ["Upbeat", "Uneasy"],
      socialTags: ["romance_budding"],
      minHoursBetweenUses: 48,
      weight: 2,
      templates: [
        "In the firelight, {name} keeps stealing quiet glances toward the other side of camp.",
      ],
    },
    {
      id: "feud_grit_teeth",
      moods: ["Uneasy", "Worn"],
      socialTags: ["feud_active", "resentment"],
      minHoursBetweenUses: 42,
      weight: 3,
      templates: [
        "{name} grinds their teeth as chores are divided. 'Some folks aren't pulling their weight.'",
      ],
    },
    {
      id: "triangle_watchful",
      moods: ["Uneasy"],
      socialTags: ["triangle"],
      minHoursBetweenUses: 60,
      weight: 1,
      templates: [
        "Eyes linger a little too long across the fire. {name} senses tension in the quiet conversation nearby.",
      ],
    },
    {
      id: "water_short_risk",
      moods: ["Uneasy", "Worn"],
      riskTags: ["water_shortage"],
      minHoursBetweenUses: 28,
      weight: 3,
      templates: [
        "Canteens slosh mostly with air. {name} says, 'We need a river soon or the oxen will fold.'",
      ],
    },
    {
      id: "spoiled_meal_worry",
      moods: ["Uneasy"],
      riskTags: ["bad_food"],
      minHoursBetweenUses: 34,
      weight: 2,
      templates: [
        "{name} pokes at supper. 'Hope this pot doesn't sit long. I've no wish to get sick out here.'",
      ],
    },
    {
      id: "schedule_slip_worn",
      moods: ["Worn"],
      riskTags: ["behind_schedule"],
      minHoursBetweenUses: 40,
      weight: 3,
      templates: [
        "{name} studies the sun. 'Days are getting shorter and we're still miles back.'",
      ],
    },
    {
      id: "old_graves_refrain",
      moods: ["Uneasy", "Worn"],
      regions: ["central_plains", "high_plains"],
      minHoursBetweenUses: 72,
      weight: 2,
      templates: [
        "Fresh graves pass by the trail. {name} falls quiet. 'They started just like us.'",
      ],
    },
    {
      id: "fort_romance_palisade",
      moods: ["Upbeat", "Uneasy"],
      locationTags: ["fort"],
      socialTags: ["romance_arc"],
      minHoursBetweenUses: 40,
      templates: [
        "Shadows lean against the palisade at {landmark}. {name} lingers nearby, grateful for a quiet corner with {friend} after the road.",
      ],
    },
    {
      id: "ferry_romance_after_rescue",
      moods: ["Upbeat", "Uneasy"],
      locationTags: ["ferry", "river"],
      socialTags: ["romance_arc", "recent_rescue"],
      minHoursBetweenUses: 46,
      templates: [
        "Mist rises off the current. {name} squeezes {rescuer}'s hand, remembering how close the river came to taking them both.",
      ],
    },
    {
      id: "fort_feud_civil_talk",
      moods: ["Uneasy", "Worn"],
      locationTags: ["fort"],
      socialTags: ["feud_arc", "feud_truce"],
      minHoursBetweenUses: 64,
      templates: [
        "Among traders at {landmark}, {name} and {rival} share a bench and finally talk without sparks. Maybe the walls help keep tempers in.",
      ],
    },
    {
      id: "river_feud_grumble",
      moods: ["Uneasy", "Worn"],
      locationTags: ["river"],
      socialTags: ["feud_arc"],
      minHoursBetweenUses: 44,
      templates: [
        "Watching the wagons test the ford, {name} mutters that {rival}'s last shortcut nearly drowned them. The current isn't the only thing running cold.",
      ],
    },
    {
      id: "triangle_ferry_glances",
      moods: ["Uneasy"],
      locationTags: ["ferry", "river"],
      socialTags: ["triangle_arc"],
      minHoursBetweenUses: 58,
      templates: [
        "The ferry deck rocks. {name} watches glances dart between {friend} and {rival}, the river a mirror for tangled feelings.",
      ],
    },
    {
      id: "rescue_reverence_bank",
      moods: ["Upbeat", "Uneasy"],
      locationTags: ["river"],
      socialTags: ["recent_rescue"],
      minHoursBetweenUses: 52,
      templates: [
        "At the bank, {name} keeps tracing the rope burns on their wrist. 'I'd have gone under without you,' they whisper toward {rescuer}.",
      ],
    },
    {
      id: "fort_romance_reunion",
      moods: ["Upbeat"],
      locationTags: ["fort"],
      socialTags: ["romance_arc"],
      minHoursBetweenUses: 48,
      templates: [
        "Supplies stacked high, {name} steals a laugh with {friend} between wagons at {landmark}. For a moment the trail feels like a courtship instead of a march.",
      ],
    },
    {
      id: "feud_reconcile_fire",
      moods: ["Worn"],
      locationTags: ["fort", "mountain_pass"],
      socialTags: ["feud_arc", "feud_truce"],
      minHoursBetweenUses: 70,
      templates: [
        "After the last storm scare, {name} nods toward {rival}. 'We got through that together. Let's keep it that way.' The words hang like truce smoke.",
      ],
    },
    {
      id: "pass_romance_warm_fire",
      moods: ["Upbeat", "Uneasy"],
      locationTags: ["mountain_pass"],
      socialTags: ["romance_arc"],
      weatherTags: ["cold_snap", "snow"],
      minHoursBetweenUses: 54,
      templates: [
        "Snow flurries around the coals. {name} shifts closer to {friend} at the pass, grateful for warmth and the excuse to stay side by side.",
      ],
    },
    {
      id: "ferry_romance_wary_current",
      moods: ["Uneasy"],
      locationTags: ["ferry", "river"],
      socialTags: ["romance_arc", "romance_steady"],
      minHoursBetweenUses: 48,
      templates: [
        "{name} watches the ropes strain at {landmark}. 'Hold on to me,' they murmur to {friend}, half joke, half plea.",
      ],
    },
    {
      id: "triangle_fort_distance",
      moods: ["Uneasy", "Worn"],
      locationTags: ["fort"],
      socialTags: ["triangle_arc"],
      minHoursBetweenUses: 62,
      templates: [
        "Even inside {landmark}'s busy yard, {name} feels apart. {friend} and {rival} trade jokes with the sutler while {name} counts the crates instead.",
      ],
    },
    {
      id: "late_snow_refrain",
      moods: ["Worn", "Broken"],
      locationTags: ["mountain_pass"],
      cascadeTags: ["late_snow"],
      minHoursBetweenUses: 36,
      templates: [
        "Drifts creep back over the ruts. {name} mutters, 'Every time we dig out, the pass buries us again.'",
      ],
    },
    {
      id: "late_snow_bitter_joke",
      moods: ["Uneasy", "Worn"],
      regions: ["mountains", "blue_mountains"],
      cascadeTags: ["late_snow"],
      minHoursBetweenUses: 44,
      templates: [
        "'Maybe the snow just likes our company,' {name} says, teeth chattering. 'We've camped here long enough to charge rent.'",
      ],
    },
    {
      id: "wagon_trouble_running_gag",
      moods: ["Uneasy"],
      cascadeTags: ["wagon_trouble"],
      minHoursBetweenUses: 28,
      templates: [
        "Another wheel squeals. {name} jokes weakly, 'Should give this wagon a name since we nurse it more than ourselves.'",
      ],
    },
    {
      id: "wagon_trouble_fort_delay",
      moods: ["Worn"],
      locationTags: ["fort"],
      cascadeTags: ["wagon_trouble"],
      minHoursBetweenUses: 48,
      templates: [
        "While traders roll past, {name} eyes the cracked spokes. 'If we stall at {landmark} any longer, spring will find us still bargaining.'",
      ],
    },
    {
      id: "wagon_trouble_prayer",
      moods: ["Uneasy", "Worn"],
      cascadeTags: ["wagon_trouble"],
      minHoursBetweenUses: 34,
      templates: [
        "{name} pats the mended tongue. 'Just one day without breaking, old friend. Just one.'",
      ],
    },
    {
      id: "lingering_illness_sigh",
      moods: ["Worn", "Broken"],
      cascadeTags: ["lingering_illness"],
      minHoursBetweenUses: 42,
      templates: [
        "Coughs rattle through camp again. {name} whispers, 'Thought that fever left us back by the Platte.'",
      ],
    },
    {
      id: "lingering_illness_gallows",
      moods: ["Uneasy"],
      cascadeTags: ["lingering_illness"],
      minHoursBetweenUses: 36,
      templates: [
        "'If coughing were coin we'd buy a new wagon,' {name} jokes, then sighs. The laugh dies quick in the cold air.",
      ],
    },
    {
      id: "lingering_illness_watchful",
      moods: ["Uneasy", "Worn"],
      cascadeTags: ["lingering_illness"],
      minHoursBetweenUses: 50,
      templates: [
        "{name} keeps checking on {friend}. 'The hills change but that sick look sticks around. We need a change of luck.'",
      ],
    },
    {
      id: "late_snow_route_blame",
      moods: ["Uneasy"],
      locationTags: ["mountain_pass"],
      cascadeTags: ["late_snow"],
      socialTags: ["leadership_conflict"],
      minHoursBetweenUses: 46,
      templates: [
        "Snowflakes drift and {name} side-eyes {leader}. 'Said we'd beat the storms. Feels like the storms are beating us.'",
      ],
    },
    {
      id: "wagon_trouble_repeat_crossing",
      moods: ["Worn"],
      locationTags: ["river"],
      cascadeTags: ["wagon_trouble"],
      minHoursBetweenUses: 42,
      templates: [
        "Another crossing, another groan from the axle. {name} swears they can hear the wagon cursing back.",
      ],
    },
    {
      id: "leadership_doubt_route",
      moods: ["Uneasy", "Worn"],
      socialTags: ["leadership_conflict"],
      minHoursBetweenUses: 40,
      templates: [
        "{name} whispers to {friend}, 'Does {leader} really know this bend? We've doubled back more than once.'",
      ],
    },
    {
      id: "leadership_support_climb",
      moods: ["Upbeat", "Uneasy"],
      socialTags: ["leadership_conflict"],
      locationTags: ["mountain_pass"],
      minHoursBetweenUses: 44,
      templates: [
        "The grade steepens. {name} calls out, 'Stay with {leader}. Better one sure line than a dozen guesses.'",
      ],
    },
    {
      id: "gratitude_doctor_warmth",
      moods: ["Upbeat", "Uneasy"],
      socialTags: ["gratitude_doctor"],
      minHoursBetweenUses: 38,
      templates: [
        "Bandages changed, {name} murmurs thanks toward {friend}. 'Those steady hands kept me walking today.'",
      ],
    },
    {
      id: "gratitude_doctor_campfire",
      moods: ["Upbeat"],
      socialTags: ["gratitude_doctor"],
      locationTags: ["fort"],
      minHoursBetweenUses: 46,
      templates: [
        "At {landmark}'s fire pit, {name} quietly sets aside the best portion for the one who dosed and sat with them.",
      ],
    },
    {
      id: "chores_rivalry_guard",
      moods: ["Uneasy"],
      socialTags: ["chores_rivalry"],
      minHoursBetweenUses: 30,
      templates: [
        "{name} eyes {rival} turning in early. 'Funny how some folks dodge guard duty when the wind howls.'",
      ],
    },
    {
      id: "chores_navigation_spat",
      moods: ["Uneasy", "Worn"],
      socialTags: ["chores_rivalry", "feud_arc"],
      minHoursBetweenUses: 36,
      templates: [
        "As landmarks blur, {name} snaps, 'If {rival} picks another 'shortcut,' I'll take the map myself.'",
      ],
    },
    {
      id: "chores_cook_grumble",
      moods: ["Uneasy"],
      socialTags: ["chores_rivalry"],
      minHoursBetweenUses: 28,
      templates: [
        "Stirring the pot, {name} mutters, 'Next meal, someone else can burn their hands while {rival} naps.'",
      ],
    },
    {
      id: "leader_blame_miles",
      moods: ["Worn"],
      socialTags: ["leadership_conflict"],
      minHoursBetweenUses: 42,
      templates: [
        "Counting miles, {name} sighs, 'If {leader} hadn't pushed past the ferry, we'd have fresher oxen and calmer tempers.'",
      ],
    },
    {
      id: "navigation_trust_friend",
      moods: ["Upbeat", "Uneasy"],
      socialTags: ["chores_rivalry"],
      minHoursBetweenUses: 34,
      templates: [
        "{name} walks beside {friend}. 'Your eye for the trail beats any map. Glad you're out front today.'",
      ],
    },
    {
      id: "gratitude_rescue_carry",
      moods: ["Upbeat", "Uneasy"],
      socialTags: ["recent_rescue"],
      minHoursBetweenUses: 44,
      templates: [
        "Every step past {location}, {name} remembers being hauled up from the muck. 'I owe {rescuer} more than supper,' they think.",
      ],
    },
    {
      id: "chores_burden",
      moods: ["Uneasy", "Worn"],
      socialTags: ["chores_skew"],
      minHoursBetweenUses: 26,
      templates: [
        "'{leader} keeps handing me the guard shift,' {name} grumbles. 'Do they think I enjoy staring into the dark?'",
      ],
    },
    {
      id: "leadership_grit",
      moods: ["Uneasy"],
      socialTags: ["leadership_conflict"],
      minHoursBetweenUses: 36,
      templates: [
        "Camp hushes when {leader} walks by. {name} whispers, 'We need one voice, not bickering—storm's coming.'",
      ],
    },
    {
      id: "rescue_callback",
      moods: ["Upbeat", "Uneasy"],
      socialTags: ["recent_rescue"],
      minHoursBetweenUses: 32,
      templates: [
        "Ever since the ferry, {name} can't help glancing at the rope burns. 'I owe {rescuer} supper for life,' they think.",
      ],
    },
    {
      id: "acting_leader_check",
      moods: ["Uneasy", "Worn"],
      socialTags: ["leadership_conflict"],
      minHoursBetweenUses: 48,
      templates: [
        "{name} weighs the map in hand. 'Maybe letting {leader} call the shots for now keeps us together,' they muse.",
      ],
    },
  ];

  function buildThoughtContext(person, gameState, storyState) {
    const ctx = {
      env: {
        region: gameState.region,
        locationName: gameState.locationName,
        tags: [],
      },
      risk: (storyState && storyState.risk) || {},
      cascadeTags: [],
      social: {
        bestFriend: null,
        strongestRival: null,
        inRomanceArc: false,
        inFeudArc: false,
        inTriangleArc: false,
        leadershipConflict: false,
        gratitudeDoctor: false,
        lastRescue: null,
        leaderPerson: gameState.leader || null,
      },
      tasks: {
        lastChore: null,
      },
    };

    function pushTag(arr, tag) {
      if (arr.indexOf(tag) === -1) arr.push(tag);
    }

    const locName = (gameState.locationName || "").toLowerCase();
    if (locName.indexOf("fort") >= 0) pushTag(ctx.env.tags, "fort");
    if (locName.indexOf("ferry") >= 0) pushTag(ctx.env.tags, "ferry");
    if (
      locName.indexOf("crossing") >= 0 ||
      locName.indexOf("ford") >= 0 ||
      locName.indexOf("river") >= 0
    ) {
      pushTag(ctx.env.tags, "river");
    }
    if (
      locName.indexOf("pass") >= 0 ||
      locName.indexOf("summit") >= 0 ||
      locName.indexOf("gap") >= 0 ||
      locName.indexOf("mountain") >= 0
    ) {
      pushTag(ctx.env.tags, "mountain_pass");
    }

    const risk = (storyState && storyState.risk) || {};
    const riskDurations = (storyState && storyState.riskDurations) || {};
    if (risk.behind_schedule && (risk.extended_cold_exposure || risk.cold_exposure)) {
      pushTag(ctx.cascadeTags, "late_snow");
    }
    if (risk.overloaded_wagon || risk.wagon_trouble) {
      pushTag(ctx.cascadeTags, "wagon_trouble");
    }
    if (risk.long_illness || (riskDurations.long_illness || 0) > 12) {
      pushTag(ctx.cascadeTags, "lingering_illness");
    }

    const cascadeEntries = ((storyState && storyState.cascadeLog) || []).slice(-12).reverse();
    cascadeEntries.forEach(function (entry) {
      if (!entry) return;
      if (entry.type === "wagon_failure") pushTag(ctx.cascadeTags, "wagon_trouble");
      if (entry.type === "snowbound") pushTag(ctx.cascadeTags, "late_snow");
      if (entry.category === "illness") pushTag(ctx.cascadeTags, "lingering_illness");
      if (entry.extra && entry.extra.rescuer && entry.extra.rescued) {
        if (entry.extra.rescuer === person.id || entry.extra.rescued === person.id) {
          const rescuer =
            (getAllPeople && getAllPeople().find(function (p) { return p && p.id === entry.extra.rescuer; })) || null;
          const rescued =
            (getAllPeople && getAllPeople().find(function (p) { return p && p.id === entry.extra.rescued; })) || null;
          ctx.social.lastRescue = {
            role: entry.extra.rescuer === person.id ? "rescuer" : "rescued",
            other: entry.extra.rescuer === person.id ? rescued : rescuer,
          };
        }
      }
    });

    const rels = (person && person.relationships) || {};
    let bestFriend = null;
    let strongestRival = null;
    Object.keys(rels).forEach(function (rid) {
      const rel = rels[rid];
      if (!rel) return;
      if (!bestFriend || (rel.opinion || 0) > (bestFriend.opinion || 0)) {
        bestFriend = { id: rid, opinion: rel.opinion };
      }
      if (!strongestRival || (rel.opinion || 0) < (strongestRival.opinion || 0)) {
        strongestRival = { id: rid, opinion: rel.opinion };
      }
    });
    if (bestFriend && bestFriend.opinion > 0) {
      ctx.social.bestFriend =
        (getAllPeople && getAllPeople().find(function (p) { return p && p.id === bestFriend.id; })) || null;
    }
    if (strongestRival && strongestRival.opinion < 0) {
      ctx.social.strongestRival =
        (getAllPeople && getAllPeople().find(function (p) { return p && p.id === strongestRival.id; })) || null;
    }

    const arcs = (storyState && storyState.socialArcs) || {};
    Object.keys(arcs).forEach(function (key) {
      const arc = arcs[key];
      if (!arc || key.indexOf(person.id) === -1) return;
      if (arc.tag === "romance") ctx.social.inRomanceArc = true;
      if (arc.tag === "triangle") ctx.social.inTriangleArc = true;
      if (arc.tag === "feud") ctx.social.inFeudArc = true;
      if (arc.status === "truce") pushTag(ctx.cascadeTags, "feud_truce");
    });
    if (storyState && storyState.leadershipDisputeState && storyState.leadershipDisputeState.active) {
      ctx.social.leadershipConflict = true;
    }

    const leader = getActiveLeader();
    if (leader && leader.id !== person.id) {
      ctx.social.leaderPerson = leader;
      const relToLeader = leader && rels[leader.id];
      if (relToLeader && (relToLeader.opinion || 0) < -6) {
        ctx.social.leadershipConflict = true;
      }
    } else if (leader && leader.id === person.id) {
      const others = (getAllPeople && getAllPeople()) || [];
      const unhappy = others.some(function (p) {
        if (!p || p.id === leader.id) return false;
        const rel = p.relationships && p.relationships[leader.id];
        return rel && (rel.opinion || 0) < -8;
      });
      ctx.social.leadershipConflict = unhappy;
    }

    const doctorings = (gameState && gameState.doctoringThisHour) || [];
    ctx.social.gratitudeDoctor = doctorings.some(function (entry) {
      if (!entry) return false;
      return (entry.patient && entry.patient.id === person.id) || (entry.doctor && entry.doctor.id === person.id);
    });

    const tasks = (storyState && storyState.lastHourCampTasks) || {};
    if (tasks.cookedById === person.id) ctx.tasks.lastChore = "cook";
    else if (tasks.huntedById === person.id) ctx.tasks.lastChore = "hunter";
    else if (tasks.fetchedWaterById === person.id) ctx.tasks.lastChore = "water";
    else if (tasks.repairedById === person.id) ctx.tasks.lastChore = "repair";
    else if (tasks.guardedByIds && tasks.guardedByIds.indexOf(person.id) >= 0) ctx.tasks.lastChore = "guard";

    if (person.taskHistory && person.taskHistory.recent && person.taskHistory.recent.length) {
      const recent = person.taskHistory.recent.filter(function (entry) {
        return entry && entry.hour >= getCurrentTrailHour(gameState) - 48;
      });
      const tally = {};
      recent.forEach(function (entry) {
        tally[entry.task] = (tally[entry.task] || 0) + 1;
      });
      const maxTask = Object.keys(tally).reduce(function (best, key) {
        return !best || tally[key] > tally[best] ? key : best;
      }, null);
      if (maxTask && tally[maxTask] >= Math.max(3, recent.length * 0.6)) {
        ctx.tasks.skew = maxTask;
      }
    }

    ctx.socialTagList = [];
    if (ctx.social.inRomanceArc) pushTag(ctx.socialTagList, "romance_arc");
    if (ctx.social.inFeudArc) pushTag(ctx.socialTagList, "feud_arc");
    if (ctx.social.inTriangleArc) pushTag(ctx.socialTagList, "triangle_arc");
    if (ctx.social.leadershipConflict) pushTag(ctx.socialTagList, "leadership_conflict");
    if (ctx.social.gratitudeDoctor) pushTag(ctx.socialTagList, "gratitude_doctor");
    if (ctx.tasks.lastChore) pushTag(ctx.socialTagList, "chores_rivalry");
    if (ctx.tasks.skew) pushTag(ctx.socialTagList, "chores_skew");
    if (ctx.social.lastRescue) pushTag(ctx.socialTagList, "recent_rescue");

    return ctx;
  }

  function fillThoughtTemplate(template, person, ctx) {
    const env = (ctx && ctx.env) || {};
    const social = (ctx && ctx.social) || {};
    const replacements = {
      "{name}": person ? person.name : "",
      "{friend}": social.bestFriend ? social.bestFriend.name : "a friend",
      "{rival}": social.strongestRival ? social.strongestRival.name : "a rival",
      "{location}": env.locationName || "the trail",
      "{landmark}": env.locationName || "the trail",
      "{rescuer}": social.lastRescue && social.lastRescue.other ? social.lastRescue.other.name : "our rescuer",
      "{leader}": social.leaderPerson ? social.leaderPerson.name : "our lead",
    };
    let text = template || "";
    Object.keys(replacements).forEach(function (key) {
      const value = replacements[key] || "";
      text = text.split(key).join(value);
    });
    return text;
  }

  function ensureThoughtHistory() {
    if (!gameState.thoughtHistory) gameState.thoughtHistory = { lastUsedByThoughtId: {} };
    if (!gameState.thoughtHistory.lastUsedByThoughtId)
      gameState.thoughtHistory.lastUsedByThoughtId = {};
    return gameState.thoughtHistory;
  }
  function initThoughtBubble() {
    if (window.oldTrailThoughts) return;
    const root = document.getElementById("oldtrail-thoughts-bubble");
    if (!root) {
      window.oldTrailThoughts = { show: function () {} };
      return;
    }
    const nameEl = root.querySelector(".tb-name");
    const textEl = root.querySelector(".tb-text");
    const fillEl = root.querySelector(".tb-mood-fill");
    const labelEl = root.querySelector(".tb-mood-label");
    const closeEl = root.querySelector(".tb-close");
    function moodColor(m) {
      if (m < 0.35) return "linear-gradient(90deg,#b81d13,#f4876c)";
      if (m < 0.7) return "linear-gradient(90deg,#f2a71b,#ffd966)";
      return "linear-gradient(90deg,#0b9444,#41d95b)";
    }
    function show(companion, mood0to1, text) {
      if (!companion) return;
      root.style.display = "block";
      nameEl.textContent = companion.name;
      textEl.textContent = '"' + text + '"';
      fillEl.style.width = Math.round(Math.max(0, Math.min(1, mood0to1)) * 100) + "%";
      fillEl.style.backgroundImage = moodColor(mood0to1);
      labelEl.textContent = companion.moodState || (mood0to1 > 0.66
        ? "Upbeat"
        : mood0to1 > 0.35
        ? "Uneasy"
        : "Worn");
    }
    function hide() {
      root.style.display = "none";
    }
    root.addEventListener("click", hide);
    if (closeEl) closeEl.addEventListener("click", hide);
    window.oldTrailThoughts = { show: show };
  }

  function companionThoughtLine(person) {
    if (!person) return "";
    const ss = ensureStoryState();
    const ctxThought = buildThoughtContext(person, gameState, ss || {});
    const risk = (gameState.storyState && gameState.storyState.risk) || {};
    const weather = gameState.weatherState || {};
    const region = ctxThought.env.region || gameState.region;
    const history = ensureThoughtHistory();
    const nowHour = Math.floor((gameState.date ? gameState.date.getTime() : Date.now()) / 3600000);
    const weatherTags = [];
    if (weather.storm) weatherTags.push("storm");
    if (weather.precip === "rain") weatherTags.push("rain");
    if (weather.precip === "snow") weatherTags.push("snow");
    if (weather.precip === "none") weatherTags.push("clear");
    if (typeof weather.tempC === "number") {
      if (weather.tempC >= 28) weatherTags.push("heat");
      if (weather.tempC <= 0) weatherTags.push("cold_snap");
    }
    const riskTags = Object.keys(risk).filter(function (k) {
      return risk[k];
    });

    const socialTags = [];
    function addSocialTag(tag) {
      if (socialTags.indexOf(tag) === -1) socialTags.push(tag);
    }
    (ctxThought.socialTagList || []).forEach(addSocialTag);
    const arcs = (ss && ss.socialArcs) || {};
    Object.keys(arcs).forEach(function (key) {
      const arc = arcs[key];
      if (!arc || key.indexOf(person.id) === -1) return;
      if (arc.tag === "romance") {
        if ((arc.stage || 0) >= 2) addSocialTag("romance_budding");
        if ((arc.stage || 0) >= 4) addSocialTag("romance_steady");
      }
      if (arc.tag === "triangle") addSocialTag("triangle");
      if (arc.tag === "feud") {
        if ((arc.stage || 0) >= 1) addSocialTag("feud_active");
        if (arc.status === "truce") addSocialTag("feud_truce");
      }
    });
    const rels = person.relationships || {};
    Object.keys(rels).forEach(function (rid) {
      const rel = rels[rid];
      if (!rel) return;
      if (rel.opinion >= 65) addSocialTag("loyal_friend");
      if (rel.opinion <= -35) addSocialTag("resentment");
    });

    const candidates = THOUGHT_DEFS.filter(function (t) {
      if (t.moods && t.moods.length && t.moods.indexOf(person.moodState) === -1) return false;
      if (t.regions && t.regions.length && t.regions.indexOf(region) === -1) return false;
      if (t.weatherTags && t.weatherTags.length) {
        const match = t.weatherTags.some(function (tag) {
          return weatherTags.indexOf(tag) >= 0;
        });
        if (!match) return false;
      }
      if (t.riskTags && t.riskTags.length) {
        const matchRisk = t.riskTags.some(function (tag) {
          return riskTags.indexOf(tag) >= 0;
        });
        if (!matchRisk) return false;
      }
      if (t.locationTags && t.locationTags.length) {
        const matchLocation = t.locationTags.some(function (tag) {
          return (ctxThought.env.tags || []).indexOf(tag) >= 0;
        });
        if (!matchLocation) return false;
      }
      if (t.cascadeTags && t.cascadeTags.length) {
        const matchCascade = t.cascadeTags.some(function (tag) {
          return (ctxThought.cascadeTags || []).indexOf(tag) >= 0;
        });
        if (!matchCascade) return false;
      }
      if (t.socialTags && t.socialTags.length) {
        const matchSocial = t.socialTags.some(function (tag) {
          return socialTags.indexOf(tag) >= 0;
        });
        if (!matchSocial) return false;
      }
      const last = history.lastUsedByThoughtId[t.id];
      if (last != null && t.minHoursBetweenUses && nowHour - last < t.minHoursBetweenUses) return false;
      return true;
    });

    if (!candidates.length) {
      return person.moodState === "Broken"
        ? "I don't know how much longer I can keep this up."
        : "Quietly watching the firelight dance on the wagon hoops.";
    }

    const weighted = candidates.map(function (c) {
      return { def: c, weight: c.weight || 1 };
    });
    const pick = weightedPick(weighted);
    const chosen = pick ? pick.def : candidates[0];
    history.lastUsedByThoughtId[chosen.id] = nowHour;
    const template = choice(chosen.templates || ["..."]);
    return fillThoughtTemplate(template, person, ctxThought);
  }

  function showCompanionThoughtForHour() {
    const people = getAllPeople().filter(function (p) {
      return p && p.alive;
    });
    if (!people.length || !window.oldTrailThoughts) return;
    const p = people[thoughtIndex % people.length];
    thoughtIndex += 1;
    const mood = clamp((p.morale || 50) / 100, 0, 1);
    const line = companionThoughtLine(p);
    window.oldTrailThoughts.show(p, mood, line);
  }

  /* ========= BOOTSTRAP ===================================================== */

  function init() {
    initDom();
    initTrailLogWidget();
    initThoughtBubble();
    wireEvents();

    const loaded = loadGame();
    if (!loaded || !gameState.leader) {
      renderLeaderStartPreview();
      renderDepartureSeasonDesc();
      updateStartArt();
      showScreen("start");
    } else {
      if (gameState.phase === "outfit") {
        buildOutfitTable();
        updateOutfitIntro();
        updateOutfitArt();
        showScreen("outfit");
      } else {
        showScreen("travel");
      }
    }

    if (gameState.phase === "outfit") {
      buildOutfitTable();
    }
    renderAll();
  }

  try {
    init();
  } catch (err) {
    console.error("Old Trail fatal init error:", err);
    var root = document.getElementById("oldtrail-root") || document.body;
    if (root) {
      var banner = document.createElement("div");
      banner.textContent = "Old Trail failed to start — open console for details.";
      banner.style.marginTop = "8px";
      banner.style.padding = "10px 12px";
      banner.style.background = "#4a1b1b";
      banner.style.color = "#f1e9dd";
      banner.style.border = "1px solid rgba(255, 121, 121, 0.6)";
      banner.style.borderRadius = "10px";
      banner.style.fontSize = "12px";
      root.appendChild(banner);
    }
  }
})();
</script>
<!-- Validation checklist (Fort ledger scarcity pass):
- Start a new run; no console errors.
- Enter travel phase and approach a fort; “Trading Post” button appears; modal opens/closes cleanly.
- Buy/sell works; vendor stock decreases/increases; buy buttons disable when stock is insufficient.
- Prices shift reasonably with scarcity (never negative/NaN; multipliers clamped).
- Wait/advance 2–3 days and reopen trade; stock restocks toward caps (no duplication explosions).
- Save + reload mid-run; trade modal still works; vendor inventories persist; no crashes.
- Trail log remains clean (no spam per transaction); trade history shows in the trade ledger panel.
- Mythic OFF: nothing new leaks into Men in Gray behaviors (this pass should not add mythic triggers at all).
-->
<!-- Validation checklist (Barter tab):
- Start new run; no console errors.
- Reach a fort and open Trade; Buy/Sell tabs still function and haggle offers spend attempts.
- Switch to Barter tab; Offer/Request bundles update totals; Clear empties baskets.
- Propose Barter consumes a haggle attempt, applies accepted/countered trades without negative stocks or dupes, and refuses cleanly.
- Haggle attempts exhausted disables proposing; panel explains remaining attempts.
- Trade ledger shows “Barter — …” lines; no trail log spam.
- Save/reload mid-run; trade modal and barter baskets open without crashes.
-->
<!-- Validation checklist (Dream-West B11/B12/B13 seeds):
- Start new run; no console errors.
- Fast-forward 5–10 days; B-11/B-12/B-13 seeds surface with seed_lastHour + seed_b_global_time + per-seed cooldown spacing.
- B-11 follow-up triggers once after dispute/forge at a fort or mission; clears pending flags; no repeats.
- B-13 follow-up triggers once at a fort/mission before deadline; clears pending flags; no repeats.
- Mythic OFF: no new mythic-only triggers were added; Men in Gray behaviors unchanged.
- Save + reload mid-run; ledger still renders and events function without crashes.
- Trail log: one line per seed run; smaller beats stay in pawn thoughts (no spam).
-->
<!-- Validation checklist (Explorer minimap/inspect caching pass):
- Start a new run, switch to Explorer view: minimap visible, no console errors.
- Drag-pan works as before; wheel zoom works as before.
- Click/drag on minimap pans camera (no accidental main-drag conflicts).
- Minimap POI markers render; unseen markers are visibly dimmer than seen.
- Toggle Minimap/Inspect via explorer chip buttons; state persists during the session.
- Inspect ON: tap on terrain pins tooltip; close button works; tooltip doesn’t block core interactions.
- Inspect OFF: pinned tooltip clears/hides.
- Performance: Explorer rendering is noticeably lighter (no per-tile art redraw each frame); no visual regressions.
- Ensure no trail log spam introduced.
-->
